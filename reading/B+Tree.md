# B+ 트리(B+ Tree) 학습 자료

## 1. B+ 트리란?

B+ 트리는 데이터베이스와 파일 시스템에서 효율적인 데이터 검색, 삽입, 삭제를 위해 사용되는 **균형 트리 자료 구조**입니다. B 트리의 변형으로, 특히 **범위 쿼리**와 **순차 접근**에 최적화되어 있습니다. B+ 트리는 데이터를 리프 노드에만 저장하고, 내부 노드는 인덱싱만을 담당하여 검색 효율성을 높입니다.

### 주요 특징
- **균형 트리**: 모든 리프 노드가 동일한 깊이에 위치.
- **리프 노드 중심**: 모든 데이터는 리프 노드에 저장되며, 내부 노드는 키와 포인터로 구성.
- **리프 노드 연결**: 리프 노드들이 연결 리스트로 연결되어 순차 접근이 빠름.
- **높은 팬아웃(fan-out)**: 각 노드가 많은 자식을 가질 수 있어 트리 높이가 낮아짐.
- **효율적인 디스크 I/O**: 디스크 기반 시스템에서 페이지 단위로 데이터를 읽어오는 데 최적화.

B+ 트리는 MySQL(InnoDB), PostgreSQL, MongoDB 등 많은 데이터베이스에서 인덱스 구조로 사용됩니다.

---

## 2. B+ 트리의 구조

B+ 트리는 다음과 같은 요소로 구성됩니다:

1. **루트 노드**: 트리의 최상단 노드, 검색 시작점.
2. **내부 노드**: 키와 자식 노드 포인터를 저장, 데이터는 저장하지 않음.
3. **리프 노드**: 실제 데이터를 저장하며, 연결 리스트로 연결.
4. **차수(order)**: 노드가 가질 수 있는 최대 자식 수(또는 최대 키 수).

### B+ 트리 규칙
- 노드는 **최소 ⌈m/2⌉**에서 **최대 m**개의 자식을 가짐(m은 차수).
- 루트 노드는 최소 2개의 자식을 가짐(단일 노드 제외).
- 모든 리프 노드는 동일한 깊이에 위치.
- 리프 노드는 다음 리프 노드에 대한 포인터를 가짐(연결 리스트).

### 다이어그램: B+ 트리 구조 예시
아래는 차수 4(m=4)인 B+ 트리의 예시입니다. 최대 3개의 키와 4개의 포인터를 가질 수 있습니다.

```
       [ 50 | 100 ]
       /    |     \
[10|20|30] [60|70|80] [110|120|130]
 /  |  | \  / |  | \  /  |  | \
[10] [20] [30] [60] [70] [80] [110] [120] [130]
 |     |    |    |     |    |    |     |     |
Data  Data Data Data  Data Data Data  Data  Data
  ↔     ↔    ↔    ↔     ↔    ↔    ↔     ↔     ↔
```

- **설명**:
  - **루트 노드**: `[50 | 100]`은 두 개의 키를 가지며, 세 개의 자식 노드를 가리킴.
  - **내부 노드**: `[10|20|30]`, `[60|70|80]`, `[110|120|130]`은 키와 자식 포인터로 구성.
  - **리프 노드**: 실제 데이터(또는 데이터 포인터)를 저장하며, 연결 리스트로 연결(↔).
  - **검색 경로**: 키 70을 검색하려면 루트에서 100 이하, 내부 노드에서 60~80 범위, 리프에서 70을 찾음.

---

## 3. B+ 트리와 B 트리의 차이

B+ 트리는 B 트리의 변형이지만, 다음과 같은 차이점이 있습니다:

| 특징                | B 트리                            | B+ 트리                           |
|--------------------|-----------------------------------|-----------------------------------|
| **데이터 저장 위치** | 모든 노드(내부, 리프)에 데이터 저장 | 리프 노드에만 데이터 저장          |
| **리프 노드 연결**  | 연결 리스트 없음                  | 리프 노드가 연결 리스트로 연결     |
| **내부 노드 역할**  | 키와 데이터 모두 저장             | 키와 포인터만 저장(인덱싱 전용)   |
| **범위 쿼리**       | 비효율적(순차 탐색 어려움)        | 효율적(리프 노드 연결 리스트 사용) |
| **디스크 I/O**      | 상대적으로 더 많은 I/O 가능       | 리프 중심 설계로 I/O 효율적       |

### B+ 트리의 장점
- **범위 쿼리 효율성**: 리프 노드의 연결 리스트로 순차 접근이 빠름.
- **디스크 I/O 최적화**: 데이터가 리프에만 저장되어 내부 노드가 더 많은 키를 저장 가능, 트리 높이 감소.
- **검색 성능**: 내부 노드가 인덱싱 전용이므로 검색 경로가 간단.

---

## 4. B+ 트리의 동작

### 4.1 검색
- 루트에서 시작해 키를 비교하며 하위 노드로 이동.
- 리프 노드에 도달하면 해당 키와 데이터를 반환.
- 예: 키 70 검색
  1. 루트 `[50|100]`에서 70은 50~100 범위 → `[60|70|80]` 노드로 이동.
  2. `[60|70|80]`에서 70 찾음 → 리프 노드 `[70]`에서 데이터 반환.

### 4.2 삽입
1. 적절한 리프 노드를 찾아 키 삽입.
2. 노드가 가득 찬 경우:
   - 노드를 분할(split).
   - 중간 키를 상위 노드로 승격(promote).
   - 상위 노드도 가득 차면 반복.
3. 트리 높이가 필요 시 증가.

#### 삽입 다이어그램 (키 75 삽입)
**삽입 전**:
```
       [ 50 | 100 ]
       /    |     \
[10|20|30] [60|70|80] [110|120|130]
```

**삽입 후** (리프 노드 `[60|70|80]`에 75 삽입, 분할 발생):
```
       [ 50 | 75 | 100 ]
       /    |    |     \
[10|20|30] [60|70] [80] [110|120|130]
```

- **설명**: `[60|70|80]`에 75 삽입 시 노드가 가득 차므로 `[60|70]`과 `[80]`로 분할, 중간 키 75가 상위 노드로 승격.

### 4.3 삭제
1. 리프 노드에서 키 삭제.
2. 노드의 키 수가 최소보다 적어지면:
   - 이웃 노드에서 키를 빌리거나(borrowing).
   - 이웃 노드와 병합(merge).
3. 상위 노드도 갱신, 트리 높이 감소 가능.

---

## 5. B+ 트리의 장점과 단점

### 장점
1. **범위 쿼리 효율성**: 리프 노드의 연결 리스트로 순차 검색이 빠름.
2. **디스크 I/O 최적화**: 많은 키를 저장해 트리 높이가 낮아 디스크 읽기 효율적.
3. **균형 유지**: 삽입/삭제 시 자동 균형 조정.
4. **대용량 데이터 처리**: 데이터베이스 인덱스에 적합.

### 단점
1. **복잡성**: 삽입/삭제 시 분할/병합 로직이 복잡.
2. **메모리 사용**: 리프 노드 연결 리스트와 내부 노드의 키 복사로 추가 메모리 필요.
3. **작은 데이터셋 비효율**: 소규모 데이터에서는 단순 배열이나 해시 테이블이 더 효율적.

---

## 6. B+ 트리 사용 사례

B+ 트리는 다음과 같은 상황에서 주로 사용됩니다:
1. **데이터베이스 인덱스**:
   - MySQL(InnoDB), PostgreSQL, Oracle 등에서 테이블 인덱스로 사용.
   - 예: `SELECT * FROM users WHERE age BETWEEN 20 AND 30`.
2. **파일 시스템**:
   - NTFS, ext4 등에서 파일 메타데이터 인덱싱.
3. **NoSQL 데이터베이스**:
   - MongoDB, Cassandra 등에서 대용량 데이터 검색 최적화.
4. **캐시 시스템**:
   - 범위 기반 데이터 조회를 위한 인덱스.

---

## 7. B+ 트리 구현 예제 (Pseudo Code)

간단한 B+ 트리 검색 알고리즘을 의사 코드로 표현:

```java
class BPlusTree {
    Node root;

    // 검색
    Data search(int key) {
        Node current = root;
        while (!current.isLeaf()) {
            // 내부 노드에서 적절한 자식 선택
            int i = 0;
            while (i < current.keyCount && key > current.keys[i]) {
                i++;
            }
            current = current.children[i];
        }
        // 리프 노드에서 키 검색
        for (int i = 0; i < current.keyCount; i++) {
            if (current.keys[i] == key) {
                return current.data[i];
            }
        }
        return null; // 키 없음
    }
}
```

- **설명**: 루트에서 시작해 키를 비교하며 리프 노드까지 이동, 리프에서 데이터 반환.

---

## 8. B+ 트리 다이어그램 (상세)

다음은 키 삽입 과정을 보여주는 상세 다이어그램입니다(차수 4, 키: 10, 20, 30, 40, 50, 60, 70 삽입 후).

**초기 상태** (10, 20 삽입):
```
[10|20]
```

**30 삽입**:
```
[10|20|30]
```

**40 삽입, 분할 발생**:
```
    [30]
   /    \
[10|20] [30|40]
  ↔       ↔
```

**50, 60, 70 삽입 후**:
```
       [30|50]
       /  |  \
[10|20] [30|40] [50|60|70]
  ↔       ↔       ↔
```

- **설명**:
  - 각 리프 노드는 최대 3개의 키 저장.
  - `[30|40]`에 50 삽입 시 분할, `[50|60|70]` 생성.
  - 리프 노드는 연결 리스트(↔)로 연결되어 범위 쿼리 효율적.

---

## 9. B+ 트리와 클린 아키텍처

B+ 트리는 데이터베이스 인덱스에서 사용되지만, 클린 아키텍처 관점에서는 **어댑터 계층**의 구현 세부사항에 해당합니다. 도메인 계층은 B+ 트리와 같은 저장소 세부사항에 의존하지 않으며, 이를 포트 인터페이스로 추상화합니다.

### 예시
```java
// 포트 (도메인 계층)
public interface UserRepositoryPort {
    User findById(String id);
}

// 어댑터 (B+ 트리 기반 저장소)
public class BPlusTreeUserRepositoryAdapter implements UserRepositoryPort {
    private BPlusTree userIndex;

    @Override
    public User findById(String id) {
        return userIndex.search(id);
    }
}
```

- **설명**: 도메인 계층은 B+ 트리의 구현을 알 필요 없이 `findById`로 데이터 요청.

---

## 10. 결론

B+ 트리는 데이터베이스와 파일 시스템에서 효율적인 검색과 범위 쿼리를 제공하는 강력한 자료 구조입니다. 리프 노드에 데이터를 집중시키고, 연결 리스트로 순차 접근을 지원하며, 디스크 I/O를 최소화하는 설계로 대용량 데이터 처리에 적합합니다.

### 요약
- **정의**: 리프 노드에 데이터를 저장하고, 내부 노드는 인덱싱 전용인 균형 트리.
- **장점**: 범위 쿼리 효율성, 디스크 I/O 최적화, 균형 유지.
- **단점**: 구현 복잡성, 소규모 데이터셋에서 비효율.
- **사용 사례**: 데이터베이스 인덱스, 파일 시스템, NoSQL.

B+ 트리를 이해하면 데이터베이스 인덱스의 동작 원리를 깊이 파악할 수 있으며, 클린 아키텍처에서 저장소 계층을 설계할 때 유용한 통찰을 얻을 수 있습니다.