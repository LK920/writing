# í‹°ì–´ë“œ(Tiered) ìºì‹± ì „ëµ í•™ìŠµ ê°€ì´ë“œ

## ğŸ“š ëª©ì°¨
1. [í‹°ì–´ë“œ ìºì‹± ì „ëµ ê°œë…](#1-í‹°ì–´ë“œ-ìºì‹±-ì „ëµ-ê°œë…)
2. [ìºì‹œ ê³„ì¸µ êµ¬ì¡°ì™€ íŠ¹ì„±](#2-ìºì‹œ-ê³„ì¸µ-êµ¬ì¡°ì™€-íŠ¹ì„±)
3. [í‹°ì–´ë“œ ìºì‹±ì´ í•´ê²°í•˜ëŠ” ë¬¸ì œì ](#3-í‹°ì–´ë“œ-ìºì‹±ì´-í•´ê²°í•˜ëŠ”-ë¬¸ì œì )
4. [í‹°ì–´ë“œ ìºì‹±ì˜ í•œê³„ì ](#4-í‹°ì–´ë“œ-ìºì‹±ì˜-í•œê³„ì )
5. [í•œê³„ì  ê·¹ë³µ ë°©ë²•](#5-í•œê³„ì -ê·¹ë³µ-ë°©ë²•)
6. [ì‹¤ì œ êµ¬í˜„ ì‚¬ë¡€](#6-ì‹¤ì œ-êµ¬í˜„-ì‚¬ë¡€)
7. [ì„±ëŠ¥ ìµœì í™” ì „ëµ](#7-ì„±ëŠ¥-ìµœì í™”-ì „ëµ)

---

## 1. í‹°ì–´ë“œ ìºì‹± ì „ëµ ê°œë…

### 1.1 í‹°ì–´ë“œ ìºì‹±ì´ë€?

**í‹°ì–´ë“œ ìºì‹±(Tiered Caching)**ì€ ì—¬ëŸ¬ ê³„ì¸µì˜ ìºì‹œë¥¼ ì¡°í•©í•˜ì—¬ **ì„±ëŠ¥**, **ë¹„ìš©**, **ìš©ëŸ‰**ì˜ ê· í˜•ì„ ìµœì í™”í•˜ëŠ” ìºì‹± ì „ëµì…ë‹ˆë‹¤.

#### í•µì‹¬ ì•„ì´ë””ì–´
- **ì†ë„ì™€ ìš©ëŸ‰ì˜ íŠ¸ë ˆì´ë“œì˜¤í”„**: ë¹ ë¥¸ ìºì‹œëŠ” ìš©ëŸ‰ì´ ì‘ê³  ë¹„ì‹¸ê³ , ëŠë¦° ìºì‹œëŠ” ìš©ëŸ‰ì´ í¬ê³  ì €ë ´
- **ë°ì´í„° ì ‘ê·¼ ë¹ˆë„ì— ë”°ë¥¸ ë°°ì¹˜**: Hot DataëŠ” ë¹ ë¥¸ ê³„ì¸µì—, Cold DataëŠ” ëŠë¦° ê³„ì¸µì—
- **ê³„ì¸µ ê°„ ìë™ ìŠ¹ê²©/ê°•ë“±**: ì ‘ê·¼ íŒ¨í„´ ë³€í™”ì— ë”°ë¼ ë°ì´í„°ê°€ ê³„ì¸µ ê°„ ì´ë™

### 1.2 í‹°ì–´ë“œ ìºì‹±ì´ í•„ìš”í•œ ì´ìœ 

#### 1.2.1 ë‹¨ì¼ ê³„ì¸µ ìºì‹œì˜ í•œê³„
```java
// ë¬¸ì œ ìƒí™©: Redisë§Œ ì‚¬ìš©í•˜ëŠ” ë‹¨ì¼ ê³„ì¸µ ìºì‹œ
@Service
public class ProductService {
    private final RedisTemplate<String, Product> redisTemplate;
    
    public Product getProduct(Long productId) {
        String key = "product:" + productId;
        Product cached = redisTemplate.opsForValue().get(key);
        
        if (cached != null) {
            return cached; // Redis Hit - 1-2ms
        }
        
        // Cache Miss - DB ì¡°íšŒ 50-100ms
        Product product = productRepository.findById(productId).orElse(null);
        if (product != null) {
            redisTemplate.opsForValue().set(key, product, Duration.ofHours(1));
        }
        return product;
    }
}

// ë¬¸ì œì :
// 1. Redis ë©”ëª¨ë¦¬ ë¹„ìš© ë†’ìŒ (GBë‹¹ $50-100)
// 2. ë„¤íŠ¸ì›Œí¬ ì§€ì—° ë°œìƒ (1-2ms)
// 3. Redis ì¥ì•  ì‹œ ì „ì²´ ìºì‹œ ë¬´íš¨í™”
// 4. ëŒ€ìš©ëŸ‰ ë°ì´í„° ì €ì¥ í•œê³„
```

#### 1.2.2 ë¹„ì¦ˆë‹ˆìŠ¤ ìš”êµ¬ì‚¬í•­ì˜ ë‹¤ì–‘ì„±
```java
// E-Commerce ì‹œìŠ¤í…œì˜ ë‹¤ì–‘í•œ ë°ì´í„° íŠ¹ì„±
ë°ì´í„° ìœ í˜•ë³„ ìš”êµ¬ì‚¬í•­:
- ì´ˆí•« ë°ì´í„° (ì¸ê¸°ìƒí’ˆ): ì´ˆê³ ì† ì ‘ê·¼ í•„ìš”, ì‘ì€ ìš©ëŸ‰
- í•« ë°ì´í„° (ì¼ë°˜ìƒí’ˆ): ë¹ ë¥¸ ì ‘ê·¼ í•„ìš”, ì¤‘ê°„ ìš©ëŸ‰  
- ì›œ ë°ì´í„° (ê³¼ê±°ìƒí’ˆ): ë³´í†µ ì ‘ê·¼, í° ìš©ëŸ‰
- ì½œë“œ ë°ì´í„° (íê¸°ìƒí’ˆ): ê°€ë” ì ‘ê·¼, ë§¤ìš° í° ìš©ëŸ‰
```

---

## 2. ìºì‹œ ê³„ì¸µ êµ¬ì¡°ì™€ íŠ¹ì„±

### 2.1 ì „í˜•ì ì¸ 3-Tier ìºì‹œ ì•„í‚¤í…ì²˜

```java
// L1: Local Memory Cache (ê°€ì¥ ë¹ ë¦„, ê°€ì¥ ì‘ìŒ)
// L2: Distributed Cache (Redis) (ì¤‘ê°„ ì†ë„, ì¤‘ê°„ ìš©ëŸ‰)
// L3: Database (ê°€ì¥ ëŠë¦¼, ê°€ì¥ í¼)

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  <- L1: Local Cache (JVM Heap)
â”‚   1-10MB        â”‚     - ì‘ë‹µì‹œê°„: 0.1ms
â”‚   Hit Rate: 30% â”‚     - ìš©ëŸ‰: ì œí•œì 
â”‚                 â”‚     - ë¹„ìš©: ê±°ì˜ ë¬´ë£Œ
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                 â”‚  <- L2: Redis Cache (ë¶„ì‚° ë©”ëª¨ë¦¬)
â”‚   100MB-10GB    â”‚     - ì‘ë‹µì‹œê°„: 1-2ms
â”‚   Hit Rate: 85% â”‚     - ìš©ëŸ‰: ì¤‘ê°„
â”‚                 â”‚     - ë¹„ìš©: ì¤‘ê°„
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                 â”‚  <- L3: Database (ì˜êµ¬ ì €ì¥ì†Œ)
â”‚   ë¬´ì œí•œ         â”‚     - ì‘ë‹µì‹œê°„: 50-100ms
â”‚   Hit Rate: 100%â”‚     - ìš©ëŸ‰: ë¬´ì œí•œ
â”‚                 â”‚     - ë¹„ìš©: ë‚®ìŒ
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 ê° ê³„ì¸µì˜ íŠ¹ì„± ë¶„ì„

#### 2.2.1 L1 Cache (Local Memory)
```java
// Caffeine ê¸°ë°˜ ë¡œì»¬ ìºì‹œ
@Configuration
public class LocalCacheConfig {
    
    @Bean
    public Cache<String, Product> productL1Cache() {
        return Caffeine.newBuilder()
            .maximumSize(1000)           // 1000ê°œ ìƒí’ˆë§Œ ì €ì¥
            .expireAfterAccess(5, TimeUnit.MINUTES)  // 5ë¶„ ë¯¸ì ‘ê·¼ì‹œ ë§Œë£Œ
            .recordStats()               // í†µê³„ ìˆ˜ì§‘
            .build();
    }
}

// íŠ¹ì„±:
// âœ… ì´ˆê³ ì† ì ‘ê·¼ (0.1ms)
// âœ… JVM ë‚´ë¶€, ë„¤íŠ¸ì›Œí¬ ì§€ì—° ì—†ìŒ
// âœ… ì§ë ¬í™”/ì—­ì§ë ¬í™” ë¶ˆí•„ìš”
// âŒ ì¸ìŠ¤í„´ìŠ¤ë³„ ë…ë¦½ì  (ë°ì´í„° ë¶ˆì¼ì¹˜ ê°€ëŠ¥)
// âŒ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì œí•œ (OutOfMemoryError ìœ„í—˜)
// âŒ ì• í”Œë¦¬ì¼€ì´ì…˜ ì¬ì‹œì‘ ì‹œ ì†Œì‹¤
```

#### 2.2.2 L2 Cache (Distributed Redis)
```java
// Redis ë¶„ì‚° ìºì‹œ
@Configuration
public class RedisCacheConfig {
    
    @Bean
    public RedisTemplate<String, Object> redisTemplate() {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(jedisConnectionFactory());
        
        // ì§ë ¬í™” ì„¤ì •
        template.setDefaultSerializer(new GenericJackson2JsonRedisSerializer());
        template.setKeySerializer(new StringRedisSerializer());
        
        return template;
    }
}

// íŠ¹ì„±:
// âœ… ë¹ ë¥¸ ì ‘ê·¼ (1-2ms)
// âœ… ë¶„ì‚° í™˜ê²½ì—ì„œ ê³µìœ  ê°€ëŠ¥
// âœ… ì˜ì†ì„± ì˜µì…˜ ì œê³µ (RDB, AOF)
// âœ… ëŒ€ìš©ëŸ‰ ë°ì´í„° ì €ì¥ ê°€ëŠ¥
// âŒ ë„¤íŠ¸ì›Œí¬ ì§€ì—° ë°œìƒ
// âŒ ì§ë ¬í™”/ì—­ì§ë ¬í™” ì˜¤ë²„í—¤ë“œ
// âŒ ë©”ëª¨ë¦¬ ë¹„ìš© ë†’ìŒ
```

#### 2.2.3 L3 Storage (Database)
```java
// ë°ì´í„°ë² ì´ìŠ¤ - ìµœì¢… ë°ì´í„° ì†ŒìŠ¤
@Repository
public class ProductRepository {
    
    @Query("SELECT p FROM Product p WHERE p.id = :id")
    public Optional<Product> findById(@Param("id") Long id);
}

// íŠ¹ì„±:
// âœ… ë¬´ì œí•œ ì €ì¥ ìš©ëŸ‰
// âœ… ACID ë³´ì¥
// âœ… ë³µì¡í•œ ì¿¼ë¦¬ ì§€ì›
// âœ… ì˜êµ¬ ë°ì´í„° ë³´ì¡´
// âŒ ìƒëŒ€ì ìœ¼ë¡œ ëŠë¦° ì ‘ê·¼ (50-100ms)
// âŒ I/O ë³‘ëª© ë°œìƒ ê°€ëŠ¥
// âŒ ë™ì‹œ ì ‘ì† ìˆ˜ ì œí•œ
```

---

## 3. í‹°ì–´ë“œ ìºì‹±ì´ í•´ê²°í•˜ëŠ” ë¬¸ì œì 

### 3.1 ë¹„ìš© íš¨ìœ¨ì„± ë¬¸ì œ í•´ê²°

#### 3.1.1 ë¬¸ì œ ìƒí™©: Redis ë‹¨ì¼ ê³„ì¸µì˜ ë†’ì€ ë¹„ìš©
```java
// ëª¨ë“  ë°ì´í„°ë¥¼ Redisì— ì €ì¥í•˜ëŠ” ê²½ìš°
Redis ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë¶„ì„:
- ì „ì²´ ìƒí’ˆ ìˆ˜: 100,000ê°œ
- ìƒí’ˆë‹¹ í‰ê·  í¬ê¸°: 2KB (ì§ë ¬í™” í›„)
- ì´ ë©”ëª¨ë¦¬ í•„ìš”ëŸ‰: 200MB

í•˜ì§€ë§Œ ì‹¤ì œ ì ‘ê·¼ íŒ¨í„´:
- ìƒìœ„ 1% ìƒí’ˆ: ì „ì²´ ìš”ì²­ì˜ 80% ì°¨ì§€ (ì´ˆí•« ë°ì´í„°)
- ìƒìœ„ 10% ìƒí’ˆ: ì „ì²´ ìš”ì²­ì˜ 95% ì°¨ì§€ (í•« ë°ì´í„°)
- ë‚˜ë¨¸ì§€ 90% ìƒí’ˆ: ì „ì²´ ìš”ì²­ì˜ 5% ì°¨ì§€ (ì½œë“œ ë°ì´í„°)

ë¹„ìš© ë¶„ì„:
- Redis 200MB: ì›” $40 (AWS ElastiCache ê¸°ì¤€)
- ì‹¤ì œ í•„ìš”í•œ í•« ë°ì´í„°: 20MB
- ë¶ˆí•„ìš”í•œ ë¹„ìš©: ì›” $36 (90%)
```

#### 3.1.2 í‹°ì–´ë“œ ìºì‹± ì ìš© í›„
```java
// 3-Tier ìºì‹± ì „ëµìœ¼ë¡œ ë¹„ìš© ìµœì í™”
@Service
public class TieredProductService {
    
    // L1: ì´ˆí•« ë°ì´í„° (1% ìƒí’ˆ, 80% ìš”ì²­)
    private final Cache<Long, Product> l1Cache = Caffeine.newBuilder()
        .maximumSize(1000)  // 2MB ë©”ëª¨ë¦¬ ì‚¬ìš©
        .build();
    
    // L2: í•« ë°ì´í„° (9% ìƒí’ˆ, 15% ìš”ì²­)  
    @Autowired
    private RedisTemplate<String, Product> l2Cache; // 18MB Redis ì‚¬ìš©
    
    // L3: ì „ì²´ ë°ì´í„° (90% ìƒí’ˆ, 5% ìš”ì²­)
    @Autowired
    private ProductRepository l3Database;
    
    public Product getProduct(Long productId) {
        // L1 ìºì‹œ í™•ì¸
        Product product = l1Cache.getIfPresent(productId);
        if (product != null) {
            return product; // 80% ì¼€ì´ìŠ¤, 0.1ms
        }
        
        // L2 ìºì‹œ í™•ì¸
        product = l2Cache.opsForValue().get("product:" + productId);
        if (product != null) {
            l1Cache.put(productId, product); // L1ìœ¼ë¡œ ìŠ¹ê²©
            return product; // 15% ì¼€ì´ìŠ¤, 1-2ms
        }
        
        // L3 ë°ì´í„°ë² ì´ìŠ¤ í™•ì¸
        product = l3Database.findById(productId).orElse(null);
        if (product != null) {
            l2Cache.opsForValue().set("product:" + productId, product, Duration.ofHours(1));
            // ì¸ê¸°ë„ì— ë”°ë¼ L1 ìŠ¹ê²© ê²°ì •
            if (isPopularProduct(productId)) {
                l1Cache.put(productId, product);
            }
        }
        return product; // 5% ì¼€ì´ìŠ¤, 50-100ms
    }
}

// ë¹„ìš© ì ˆê° íš¨ê³¼:
// - Redis ë©”ëª¨ë¦¬: 200MB â†’ 18MB (91% ì ˆê°)
// - ì›” ë¹„ìš©: $40 â†’ $4 (90% ì ˆê°)
// - ì„±ëŠ¥: 95% ìš”ì²­ì´ 3ms ì´ë‚´ ì‘ë‹µ (L1+L2)
```

### 3.2 ì„±ëŠ¥ ë³‘ëª© í•´ê²°

#### 3.2.1 ë¬¸ì œ: Redis ë„¤íŠ¸ì›Œí¬ ì§€ì—°
```java
// ë¬¸ì œ ìƒí™©: ëª¨ë“  ìš”ì²­ì´ Redisë¥¼ ê±°ì¹˜ëŠ” ê²½ìš°
@RestController
public class ProductController {
    
    @GetMapping("/api/product/{productId}")
    public ProductResponse getProduct(@PathVariable Long productId) {
        // ë§¤ë²ˆ Redis ë„¤íŠ¸ì›Œí¬ í˜¸ì¶œ (1-2ms)
        Product product = redisProductService.getProduct(productId);
        return ProductResponse.from(product);
    }
}

// ì„±ëŠ¥ ë¶„ì„:
// - í”¼í¬ ì‹œê°„ëŒ€ QPS: 10,000
// - Redis ì‘ë‹µ ì‹œê°„: í‰ê·  1.5ms
// - ë„¤íŠ¸ì›Œí¬ ì§€ì—°: 0.5ms
// - ì´ ì‘ë‹µ ì‹œê°„: 2ms (ëª©í‘œ < 1ms ë‹¬ì„± ë¶ˆê°€)
```

#### 3.2.2 í‹°ì–´ë“œ ìºì‹±ìœ¼ë¡œ ì„±ëŠ¥ í–¥ìƒ
```java
// L1 ìºì‹œë¡œ ë„¤íŠ¸ì›Œí¬ ì§€ì—° ì œê±°
@Service
public class HighPerformanceProductService {
    
    private final LoadingCache<Long, Product> l1Cache = Caffeine.newBuilder()
        .maximumSize(1000)
        .expireAfterWrite(5, TimeUnit.MINUTES)
        .refreshAfterWrite(3, TimeUnit.MINUTES) // ë°±ê·¸ë¼ìš´ë“œ ê°±ì‹ 
        .buildAsync(this::loadFromL2OrL3); // ë¹„ë™ê¸° ë¡œë”©
    
    public Product getProduct(Long productId) {
        try {
            return l1Cache.get(productId); // 0.1ms ì‘ë‹µ
        } catch (Exception e) {
            // L1 ì‹¤íŒ¨ ì‹œ L2/L3 í´ë°±
            return fallbackToLowerTiers(productId);
        }
    }
    
    private Product loadFromL2OrL3(Long productId) {
        // L2 Redis ì‹œë„
        Product product = redisTemplate.opsForValue().get("product:" + productId);
        if (product != null) {
            return product;
        }
        
        // L3 Database ì‹œë„
        return productRepository.findById(productId).orElse(null);
    }
}

// ì„±ëŠ¥ ê°œì„  ê²°ê³¼:
// - L1 íˆíŠ¸ (80%): 0.1ms ì‘ë‹µ
// - L2 íˆíŠ¸ (15%): 1.5ms ì‘ë‹µ  
// - L3 íˆíŠ¸ (5%): 50ms ì‘ë‹µ
// - ê°€ì¤‘ í‰ê· : 0.1Ã—0.8 + 1.5Ã—0.15 + 50Ã—0.05 = 2.805ms â†’ 0.385ms (86% ê°œì„ )
```

### 3.3 ì¥ì•  ê²©ë¦¬ ë° ë³µêµ¬ë ¥ í–¥ìƒ

#### 3.3.1 ë¬¸ì œ: ë‹¨ì¼ ìºì‹œì˜ ì¥ì•  ì „íŒŒ
```java
// Redis ì¥ì•  ì‹œ ì „ì²´ ì„œë¹„ìŠ¤ ì˜í–¥
@Service
public class FragileProductService {
    
    public Product getProduct(Long productId) {
        try {
            Product cached = redisTemplate.opsForValue().get("product:" + productId);
            if (cached != null) {
                return cached;
            }
        } catch (RedisConnectionException e) {
            // Redis ì¥ì•  ì‹œ ëª¨ë“  ìš”ì²­ì´ DBë¡œ ëª°ë¦¼
            log.error("Redis down, DB overload incoming", e);
            // DB ê³¼ë¶€í•˜ë¡œ ì „ì²´ ì„œë¹„ìŠ¤ ì¤‘ë‹¨ ìœ„í—˜
        }
        
        return productRepository.findById(productId).orElse(null);
    }
}
```

#### 3.3.2 í‹°ì–´ë“œ ìºì‹±ìœ¼ë¡œ ì¥ì•  ê²©ë¦¬
```java
// ê³„ì¸µë³„ ë…ë¦½ì  ì¥ì•  ì²˜ë¦¬
@Service
public class ResilientProductService {
    
    public Product getProduct(Long productId) {
        // L1: ë¡œì»¬ ìºì‹œ (Redis ì¥ì• ì™€ ë¬´ê´€)
        Product product = l1Cache.getIfPresent(productId);
        if (product != null) {
            return product; // 80% ìš”ì²­ì€ Redis ì¥ì•  ì˜í–¥ ì—†ìŒ
        }
        
        // L2: Redis ìºì‹œ (Circuit Breaker ì ìš©)
        if (redisCircuitBreaker.isCallAllowed()) {
            try {
                product = redisTemplate.opsForValue().get("product:" + productId);
                if (product != null) {
                    redisCircuitBreaker.recordSuccess();
                    l1Cache.put(productId, product);
                    return product;
                }
            } catch (Exception e) {
                redisCircuitBreaker.recordError(e);
                log.warn("Redis access failed, fallback to DB", e);
            }
        }
        
        // L3: Database (ìµœí›„ ìˆ˜ë‹¨)
        product = databaseWithRetry.findById(productId);
        if (product != null) {
            // L2 ë³µêµ¬ ì‹œë¥¼ ëŒ€ë¹„í•´ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì €ì¥ ì‹œë„
            tryAsyncCacheStore(productId, product);
            l1Cache.put(productId, product);
        }
        
        return product;
    }
    
    // ì¥ì•  ë³µêµ¬ íš¨ê³¼:
    // - Redis ì¥ì•  ì‹œì—ë„ 80% ìš”ì²­ì€ L1ì—ì„œ ì •ìƒ ì²˜ë¦¬
    // - ë‚˜ë¨¸ì§€ 20% ìš”ì²­ë§Œ DBë¡œ ì´ë™ (ë¶€í•˜ ê´€ë¦¬ ê°€ëŠ¥)
    // - Circuit Breakerë¡œ ë¹ ë¥¸ ì¥ì•  ê°ì§€ ë° ë³µêµ¬
}
```

---

## 4. í‹°ì–´ë“œ ìºì‹±ì˜ í•œê³„ì 

### 4.1 ë°ì´í„° ì¼ê´€ì„± ë¬¸ì œ

#### 4.1.1 ë‹¤ì¤‘ ê³„ì¸µ ê°„ ë™ê¸°í™” ì§€ì—°
```java
// ë¬¸ì œ ìƒí™©: ìƒí’ˆ ì •ë³´ ì—…ë°ì´íŠ¸ ì‹œ ì¼ê´€ì„± ë¬¸ì œ
@Service
public class ProductUpdateService {
    
    @Transactional
    public Product updateProduct(Long productId, ProductUpdateRequest request) {
        // 1. DB ì—…ë°ì´íŠ¸
        Product updated = productRepository.save(
            product.updatePrice(request.getPrice())
        );
        
        // 2. L2 ìºì‹œ ë¬´íš¨í™”
        redisTemplate.delete("product:" + productId);
        
        // 3. L1 ìºì‹œëŠ” ê° ì¸ìŠ¤í„´ìŠ¤ë§ˆë‹¤ ë”°ë¡œ ê´€ë¦¬ë¨
        // ë¬¸ì œ: ë‹¤ë¥¸ ì„œë²„ì˜ L1 ìºì‹œì—ëŠ” ì—¬ì „íˆ êµ¬ ë°ì´í„°ê°€ ë‚¨ì•„ìˆìŒ
        l1Cache.invalidate(productId); // í˜„ì¬ ì¸ìŠ¤í„´ìŠ¤ë§Œ ë¬´íš¨í™”
        
        return updated;
    }
}

// ë¬¸ì œì :
// - ì„œë²„ Aì—ì„œ ê°€ê²© ì—…ë°ì´íŠ¸: 1000ì› â†’ 1200ì›
// - ì„œë²„ Aì˜ L1 ìºì‹œ: ë¬´íš¨í™”ë¨
// - ì„œë²„ Bì˜ L1 ìºì‹œ: ì—¬ì „íˆ 1000ì› (5ë¶„ TTLê¹Œì§€ ìœ ì§€)
// - ê³ ê° ë¶ˆë§Œ: ê°™ì€ ìƒí’ˆì´ ì„œë²„ë§ˆë‹¤ ë‹¤ë¥¸ ê°€ê²©ìœ¼ë¡œ í‘œì‹œ
```

#### 4.1.2 Write-Through vs Write-Behind ë”œë ˆë§ˆ
```java
// Write-Through: ì¼ê´€ì„± ì¢‹ìŒ, ì„±ëŠ¥ ë‚˜ì¨
public class WriteThrough ProductService {
    
    public Product updateProduct(Product product) {
        // ëª¨ë“  ê³„ì¸µì„ ë™ê¸°ì ìœ¼ë¡œ ì—…ë°ì´íŠ¸
        Product saved = database.save(product);      // 50ms
        redisCache.put(saved.getId(), saved);        // 2ms
        localCache.put(saved.getId(), saved);        // 0.1ms
        
        return saved; // ì´ 52.1ms ì†Œìš”
    }
}

// Write-Behind: ì„±ëŠ¥ ì¢‹ìŒ, ì¼ê´€ì„± ë‚˜ì¨
public class WriteBehindProductService {
    
    public Product updateProduct(Product product) {
        // L1ë§Œ ì¦‰ì‹œ ì—…ë°ì´íŠ¸, ë‚˜ë¨¸ì§€ëŠ” ë¹„ë™ê¸°
        localCache.put(product.getId(), product);    // 0.1ms
        
        // ë°±ê·¸ë¼ìš´ë“œì—ì„œ í•˜ìœ„ ê³„ì¸µ ì—…ë°ì´íŠ¸
        asyncUpdateQueue.offer(new UpdateEvent(product));
        
        return product; // 0.1ms ì¦‰ì‹œ ë°˜í™˜
    }
    
    // ë¬¸ì œ: ì„œë²„ ì¬ì‹œì‘ ì‹œ ë¯¸ì²˜ë¦¬ëœ ì—…ë°ì´íŠ¸ ì†Œì‹¤ ìœ„í—˜
}
```

### 4.2 ë³µì¡ì„± ì¦ê°€

#### 4.2.1 ìºì‹œ ê´€ë¦¬ ë³µì¡ì„±
```java
// ë³µì¡í•œ ìºì‹œ ê´€ë¦¬ ë¡œì§
@Service
public class ComplexTieredCacheService {
    
    // ê° ê³„ì¸µë³„ ë‹¤ë¥¸ TTL, ìš©ëŸ‰, ì •ì±… ê´€ë¦¬
    private final Cache<Long, Product> l1Cache = Caffeine.newBuilder()
        .maximumSize(1000)
        .expireAfterAccess(5, TimeUnit.MINUTES)
        .build();
    
    private final RedisTemplate<String, Product> l2Cache;
    
    public Product getProduct(Long productId) {
        // ë³µì¡í•œ ìºì‹œ íˆíŠ¸/ë¯¸ìŠ¤ ë¡œì§
        Product product = l1Cache.getIfPresent(productId);
        if (product != null) {
            recordCacheHit("L1", productId);
            return product;
        }
        
        product = l2Cache.opsForValue().get("product:" + productId);
        if (product != null) {
            recordCacheHit("L2", productId);
            
            // L1 ìŠ¹ê²© ì¡°ê±´ í™•ì¸ (ë³µì¡í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
            if (shouldPromoteToL1(productId, product)) {
                l1Cache.put(productId, product);
            }
            return product;
        }
        
        recordCacheMiss(productId);
        product = loadFromDatabase(productId);
        
        if (product != null) {
            // ê³„ì¸µë³„ ì €ì¥ ì „ëµ ê²°ì •
            storeInAppropriateCache(productId, product);
        }
        
        return product;
    }
    
    // ë¬¸ì œ: ì½”ë“œ ë³µì¡ë„ ê¸‰ì¦, ë””ë²„ê¹… ì–´ë ¤ì›€, ìœ ì§€ë³´ìˆ˜ ë¹„ìš© ìƒìŠ¹
}
```

#### 4.2.2 ëª¨ë‹ˆí„°ë§ ë° ë””ë²„ê¹… ë³µì¡ì„±
```java
// ë‹¤ì¤‘ ìºì‹œ í™˜ê²½ì—ì„œì˜ ë””ë²„ê¹… ì–´ë ¤ì›€
@Component
public class CacheMonitoringService {
    
    public CacheStatistics getCacheStats() {
        return CacheStatistics.builder()
            .l1HitRate(l1Cache.stats().hitRate())
            .l1EvictionCount(l1Cache.stats().evictionCount())
            .l2HitRate(getRedisHitRate())  // Redis í†µê³„ ìˆ˜ì§‘ ë¡œì§ í•„ìš”
            .l2Memory(getRedisMemoryUsage()) // Redis ë©”ëª¨ë¦¬ ëª¨ë‹ˆí„°ë§
            .dataConsistencyErrors(getConsistencyErrorCount()) // ì¼ê´€ì„± ì˜¤ë¥˜ ì¶”ì 
            .build();
    }
    
    // ë¬¸ì œì :
    // 1. ì„±ëŠ¥ ë¬¸ì œ ë°œìƒ ì‹œ ì–´ëŠ ê³„ì¸µì—ì„œ ë°œìƒí–ˆëŠ”ì§€ íŒŒì•… ì–´ë ¤ì›€
    // 2. ìºì‹œ ë¯¸ìŠ¤ì˜ ì›ì¸ ë¶„ì„ ë³µì¡ (TTL ë§Œë£Œ? ìš©ëŸ‰ ì´ˆê³¼? ì¼ê´€ì„± ë¬¸ì œ?)
    // 3. ê° ê³„ì¸µë³„ ë³„ë„ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ í•„ìš”
    // 4. ì „ì²´ ì‹œìŠ¤í…œì˜ ê°€ì‹œì„± í™•ë³´ ì–´ë ¤ì›€
}
```

### 4.3 ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì˜ˆì¸¡ ì–´ë ¤ì›€

#### 4.3.1 ê³„ì¸µë³„ ì¤‘ë³µ ì €ì¥ìœ¼ë¡œ ì¸í•œ ë©”ëª¨ë¦¬ ë‚­ë¹„
```java
// ë™ì¼ ë°ì´í„°ì˜ ë‹¤ì¤‘ ì €ì¥
public class MemoryWasteAnalysis {
    
    public void analyzeMemoryUsage() {
        // ì¸ê¸° ìƒí’ˆ 1000ê°œê°€ ëª¨ë“  ê³„ì¸µì— ì €ì¥ë˜ëŠ” ê²½ìš°
        
        // L1 ìºì‹œ (JVM Heap)
        int l1Size = 1000 * 2048; // 2MB (ê°ì²´ í˜•íƒœ)
        
        // L2 ìºì‹œ (Redis)  
        int l2Size = 1000 * 2560; // 2.5MB (JSON ì§ë ¬í™” + ë©”íƒ€ë°ì´í„°)
        
        // L3 ë°ì´í„°ë² ì´ìŠ¤ëŠ” ì œì™¸ (ì›ë³¸ ë°ì´í„°)
        
        int totalCacheMemory = l1Size + l2Size; // 4.5MB
        int duplicatedMemory = 1000 * 2048; // 2MB (ì¤‘ë³µ ì €ì¥)
        
        double wasteRatio = (double)duplicatedMemory / totalCacheMemory; // 44% ë‚­ë¹„
        
        System.out.println("ë©”ëª¨ë¦¬ ì¤‘ë³µ ì €ì¥ìœ¼ë¡œ ì¸í•œ ë‚­ë¹„ìœ¨: " + wasteRatio);
    }
}
```

#### 4.3.2 ë™ì  ìŠ¹ê²©/ê°•ë“±ìœ¼ë¡œ ì¸í•œ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë³€ë™
```java
// ì˜ˆì¸¡í•˜ê¸° ì–´ë ¤ìš´ ë©”ëª¨ë¦¬ ì‚¬ìš© íŒ¨í„´
@Service
public class DynamicTieringService {
    
    private final AtomicLong l1MemoryUsage = new AtomicLong(0);
    
    public void promoteToL1(Long productId, Product product) {
        long productSize = calculateObjectSize(product);
        
        // L1 ìºì‹œ ìš©ëŸ‰ ì´ˆê³¼ ì‹œ LRU ì œê±°
        while (l1MemoryUsage.get() + productSize > L1_MAX_MEMORY) {
            Product evicted = l1Cache.asMap().values().iterator().next();
            l1Cache.invalidate(getKeyByValue(evicted));
            l1MemoryUsage.addAndGet(-calculateObjectSize(evicted));
        }
        
        l1Cache.put(productId, product);
        l1MemoryUsage.addAndGet(productSize);
    }
    
    // ë¬¸ì œì :
    // 1. ì‹¤ì‹œê°„ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¶”ì  ì˜¤ë²„í—¤ë“œ
    // 2. ê°ì²´ í¬ê¸° ê³„ì‚°ì˜ ë¶€ì •í™•ì„±
    // 3. ìŠ¹ê²©/ê°•ë“± ë¹ˆë„ì— ë”°ë¥¸ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ê¸‰ë³€
    // 4. OutOfMemoryError ìœ„í—˜ ì¦ê°€
}
```

---

## 5. í•œê³„ì  ê·¹ë³µ ë°©ë²•

### 5.1 ë°ì´í„° ì¼ê´€ì„± ë³´ì¥ ì „ëµ

#### 5.1.1 ì´ë²¤íŠ¸ ê¸°ë°˜ ìºì‹œ ë¬´íš¨í™”
```java
// Redis Pub/Subì„ í™œìš©í•œ ë¶„ì‚° ìºì‹œ ë¬´íš¨í™”
@Component
public class DistributedCacheInvalidation {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    // ìƒí’ˆ ì—…ë°ì´íŠ¸ ì‹œ ëª¨ë“  ì¸ìŠ¤í„´ìŠ¤ì— ë¬´íš¨í™” ì´ë²¤íŠ¸ ë°œì†¡
    public void invalidateProduct(Long productId) {
        CacheInvalidationEvent event = new CacheInvalidationEvent(
            "PRODUCT", productId.toString(), System.currentTimeMillis()
        );
        
        redisTemplate.convertAndSend("cache.invalidation", event);
    }
    
    @EventListener
    public void handleInvalidationEvent(CacheInvalidationEvent event) {
        if ("PRODUCT".equals(event.getType())) {
            Long productId = Long.parseLong(event.getKey());
            
            // ëª¨ë“  ê³„ì¸µì—ì„œ ë¬´íš¨í™”
            l1Cache.invalidate(productId);
            redisTemplate.delete("product:" + productId);
            
            log.info("ìºì‹œ ë¬´íš¨í™” ì™„ë£Œ: productId={}", productId);
        }
    }
}

// ê°œì„  íš¨ê³¼:
// âœ… ëª¨ë“  ì¸ìŠ¤í„´ìŠ¤ì˜ L1 ìºì‹œ ë™ì‹œ ë¬´íš¨í™”
// âœ… ì¼ê´€ì„± ë³´ì¥ ì‹œê°„ ë‹¨ì¶• (5ë¶„ â†’ ìˆ˜ì´ˆ)
// âœ… ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ê³¼ ë¶„ë¦¬ëœ ê¹”ë”í•œ êµ¬ì¡°
```

#### 5.1.2 ë²„ì „ ê¸°ë°˜ ì¼ê´€ì„± ê²€ì¦
```java
// ë°ì´í„° ë²„ì „ì„ í™œìš©í•œ stale data ê°ì§€
@Entity
public class Product {
    @Id
    private Long id;
    
    @Version
    private Long version; // JPA Optimistic Locking
    
    private LocalDateTime lastModified;
    
    // ìºì‹œëœ ë°ì´í„°ì˜ ì‹ ì„ ë„ ê²€ì¦
    public boolean isStale(Duration maxAge) {
        return lastModified.isBefore(LocalDateTime.now().minus(maxAge));
    }
}

@Service
public class VersionAwareCacheService {
    
    public Product getProduct(Long productId) {
        // L1 ìºì‹œì—ì„œ ì¡°íšŒ
        Product l1Product = l1Cache.getIfPresent(productId);
        if (l1Product != null && !l1Product.isStale(Duration.ofMinutes(1))) {
            return l1Product;
        }
        
        // L2 ìºì‹œì—ì„œ ì¡°íšŒ ë° ë²„ì „ ê²€ì¦
        Product l2Product = redisTemplate.opsForValue().get("product:" + productId);
        if (l2Product != null) {
            if (!l2Product.isStale(Duration.ofMinutes(5))) {
                l1Cache.put(productId, l2Product);
                return l2Product;
            } else {
                // L2 ë°ì´í„°ê°€ staleí•œ ê²½ìš° ë¬´íš¨í™”
                redisTemplate.delete("product:" + productId);
            }
        }
        
        // L3ì—ì„œ ìµœì‹  ë°ì´í„° ì¡°íšŒ
        Product freshProduct = productRepository.findById(productId).orElse(null);
        if (freshProduct != null) {
            // ì‹ ì„ í•œ ë°ì´í„°ë¥¼ ìƒìœ„ ê³„ì¸µì— ì €ì¥
            redisTemplate.opsForValue().set("product:" + productId, freshProduct, Duration.ofHours(1));
            l1Cache.put(productId, freshProduct);
        }
        
        return freshProduct;
    }
}
```

#### 5.1.3 Eventually Consistent ì „ëµ
```java
// ìµœì¢… ì¼ê´€ì„±ì„ ë°›ì•„ë“¤ì´ê³  ë¹„ì¦ˆë‹ˆìŠ¤ í—ˆìš© ë²”ìœ„ ë‚´ì—ì„œ ìš´ì˜
@Service
public class EventuallyConsistentCacheService {
    
    // ë¹„ì¦ˆë‹ˆìŠ¤ ì¤‘ìš”ë„ì— ë”°ë¥¸ ì¼ê´€ì„± ë ˆë²¨ ì°¨ë“± ì ìš©
    public Product getProduct(Long productId, ConsistencyLevel level) {
        switch (level) {
            case STRONG:
                // ê¸ˆìœµ ì •ë³´, ê°€ê²© ë“± ì¤‘ìš” ë°ì´í„°
                return getWithStrongConsistency(productId);
                
            case EVENTUAL:
                // ìƒí’ˆ ì„¤ëª…, ì´ë¯¸ì§€ ë“± ì¼ë°˜ ë°ì´í„°
                return getWithEventualConsistency(productId);
                
            case WEAK:
                // ì¡°íšŒìˆ˜, ë¦¬ë·° ê°œìˆ˜ ë“± ì°¸ê³  ë°ì´í„°
                return getWithWeakConsistency(productId);
        }
    }
    
    private Product getWithStrongConsistency(Long productId) {
        // L2, L3ë§Œ ì‚¬ìš© (L1 ê±´ë„ˆëœ€)
        Product product = redisTemplate.opsForValue().get("product:" + productId);
        if (product == null) {
            product = productRepository.findById(productId).orElse(null);
            if (product != null) {
                redisTemplate.opsForValue().set("product:" + productId, product, Duration.ofMinutes(5));
            }
        }
        return product;
    }
    
    private Product getWithEventualConsistency(Long productId) {
        // ì¼ë°˜ì ì¸ 3-Tier ìºì‹±
        return standardTieredGet(productId);
    }
    
    private Product getWithWeakConsistency(Long productId) {
        // L1ì„ ì˜¤ë˜ ìœ ì§€í•˜ê³  ë°±ê·¸ë¼ìš´ë“œì—ì„œë§Œ ê°±ì‹ 
        Product product = l1Cache.getIfPresent(productId);
        if (product != null) {
            // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ë¹„ë™ê¸° ê°±ì‹  ì²´í¬
            refreshAsyncIfNeeded(productId, product);
            return product;
        }
        
        return standardTieredGet(productId);
    }
}
```

### 5.2 ë³µì¡ì„± ê´€ë¦¬ ì „ëµ

#### 5.2.1 ìºì‹œ ì¶”ìƒí™” ë ˆì´ì–´
```java
// ë³µì¡í•œ í‹°ì–´ë“œ ë¡œì§ì„ ìˆ¨ê¸°ëŠ” ì¶”ìƒí™” ì¸í„°í˜ì´ìŠ¤
public interface TieredCacheManager<K, V> {
    
    Optional<V> get(K key);
    void put(K key, V value);
    void invalidate(K key);
    void invalidateAll();
    
    // ê³ ê¸‰ ê¸°ëŠ¥ë“¤ì„ ê°„ë‹¨í•œ ì¸í„°í˜ì´ìŠ¤ë¡œ ì œê³µ
    void putWithTier(K key, V value, CacheTier tier);
    Optional<V> getWithConsistency(K key, ConsistencyLevel level);
    CacheStatistics getStatistics();
}

@Component
public class ProductTieredCacheManager implements TieredCacheManager<Long, Product> {
    
    @Override
    public Optional<Product> get(Long productId) {
        // ë³µì¡í•œ 3-tier ë¡œì§ì„ ë‚´ë¶€ì— ìº¡ìŠí™”
        return performTieredGet(productId);
    }
    
    @Override
    public void put(Long productId, Product product) {
        // ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ì— ë”°ë¥¸ ìë™ ê³„ì¸µ ë°°ì¹˜
        CacheTier tier = determineTier(product);
        putToTier(productId, product, tier);
    }
    
    private CacheTier determineTier(Product product) {
        // ìƒí’ˆ ì¸ê¸°ë„, í¬ê¸°, ì ‘ê·¼ ë¹ˆë„ ë“±ì„ ì¢…í•©í•˜ì—¬ ìµœì  ê³„ì¸µ ê²°ì •
        if (product.getPopularityScore() > 80) {
            return CacheTier.L1;
        } else if (product.getPopularityScore() > 50) {
            return CacheTier.L2;
        } else {
            return CacheTier.L3_ONLY;
        }
    }
}

// ì„œë¹„ìŠ¤ì—ì„œëŠ” ë‹¨ìˆœí•˜ê²Œ ì‚¬ìš©
@Service
public class ProductService {
    
    @Autowired
    private TieredCacheManager<Long, Product> cacheManager;
    
    public Product getProduct(Long productId) {
        return cacheManager.get(productId)
            .orElseGet(() -> loadFromDatabase(productId));
    }
}
```

#### 5.2.2 ìºì‹œ ì •ì±… ì¤‘ì•™í™”
```java
// ì„¤ì • ê¸°ë°˜ ìºì‹œ ì •ì±… ê´€ë¦¬
@ConfigurationProperties(prefix = "cache.policy")
@Component
public class CachePolicyConfig {
    
    private Map<String, TierConfig> tiers;
    
    @Data
    public static class TierConfig {
        private int maxSize;
        private Duration ttl;
        private Duration refreshAfter;
        private EvictionPolicy evictionPolicy;
        private ConsistencyLevel consistencyLevel;
    }
    
    // application.yml
    /*
    cache:
      policy:
        tiers:
          product-l1:
            max-size: 1000
            ttl: PT5M
            refresh-after: PT3M
            eviction-policy: LRU
            consistency-level: EVENTUAL
          product-l2:
            max-size: 10000
            ttl: PT1H
            refresh-after: PT30M
            eviction-policy: LRU
            consistency-level: STRONG
    */
}

@Component
public class PolicyDrivenCacheManager {
    
    public void initializeCaches() {
        // ì„¤ì • ê¸°ë°˜ìœ¼ë¡œ ìºì‹œ ì´ˆê¸°í™”
        cacheConfig.getTiers().forEach((name, config) -> {
            Cache<Object, Object> cache = Caffeine.newBuilder()
                .maximumSize(config.getMaxSize())
                .expireAfterWrite(config.getTtl())
                .refreshAfterWrite(config.getRefreshAfter())
                .build();
                
            registerCache(name, cache);
        });
    }
    
    // ì¥ì : ì½”ë“œ ë³€ê²½ ì—†ì´ ì„¤ì •ë§Œìœ¼ë¡œ ìºì‹œ ì •ì±… ì¡°ì • ê°€ëŠ¥
}
```

#### 5.2.3 ìºì‹œ ì—°ì‚° íŒŒì´í”„ë¼ì¸í™”
```java
// ë³µì¡í•œ ìºì‹œ ì—°ì‚°ì„ íŒŒì´í”„ë¼ì¸ìœ¼ë¡œ ë‹¨ìˆœí™”
@Component
public class CachePipeline<K, V> {
    
    public V execute(K key, CacheOperation<K, V> operation) {
        return CacheOperationPipeline.<K, V>builder()
            .addStage(new L1CacheStage<>())
            .addStage(new L2CacheStage<>())
            .addStage(new L3LoadStage<>())
            .addStage(new CacheStoreStage<>())
            .build()
            .execute(key, operation);
    }
}

// ê° ë‹¨ê³„ë¥¼ ë…ë¦½ì ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ ë° ìµœì í™” ê°€ëŠ¥
public class L1CacheStage<K, V> implements CacheStage<K, V> {
    
    @Override
    public CacheResult<V> process(K key, CacheContext<K, V> context) {
        V cached = l1Cache.getIfPresent(key);
        if (cached != null) {
            return CacheResult.hit(cached, CacheTier.L1);
        }
        return CacheResult.miss();
    }
}
```

### 5.3 ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ìµœì í™”

#### 5.3.1 ì§€ëŠ¥í˜• ìŠ¹ê²©/ê°•ë“± ì•Œê³ ë¦¬ì¦˜
```java
// ì ‘ê·¼ íŒ¨í„´ ë¶„ì„ì„ í†µí•œ íš¨ìœ¨ì ì¸ ê³„ì¸µ ê´€ë¦¬
@Component
public class IntelligentTierManager {
    
    private final Map<Long, AccessPattern> accessPatterns = new ConcurrentHashMap<>();
    
    public static class AccessPattern {
        private final RingBuffer<Long> accessTimes = new RingBuffer<>(100);
        private volatile double frequency; // ì ‘ê·¼ ë¹ˆë„
        private volatile double recency;   // ìµœê·¼ì„±
        private volatile double popularity; // ì¸ê¸°ë„
        
        public void recordAccess() {
            long now = System.currentTimeMillis();
            accessTimes.add(now);
            updateMetrics();
        }
        
        private void updateMetrics() {
            long now = System.currentTimeMillis();
            long oneHour = 3600_000L;
            
            // ìµœê·¼ 1ì‹œê°„ ë‚´ ì ‘ê·¼ íšŸìˆ˜
            long recentAccesses = accessTimes.stream()
                .filter(time -> (now - time) < oneHour)
                .count();
                
            this.frequency = recentAccesses / 100.0; // ì •ê·œí™”
            this.recency = Math.exp(-(now - accessTimes.latest()) / oneHour);
            this.popularity = frequency * 0.7 + recency * 0.3;
        }
    }
    
    public boolean shouldPromoteToL1(Long key) {
        AccessPattern pattern = accessPatterns.get(key);
        if (pattern == null) return false;
        
        // ë‹¤ì¤‘ ìš”ì†Œë¥¼ ê³ ë ¤í•œ ìŠ¹ê²© ê²°ì •
        return pattern.popularity > 0.8 && 
               pattern.frequency > 0.5 && 
               pattern.recency > 0.3;
    }
    
    public boolean shouldDemoteFromL1(Long key) {
        AccessPattern pattern = accessPatterns.get(key);
        if (pattern == null) return true;
        
        // ì¸ê¸°ë„ í•˜ë½ ì‹œ ê°•ë“±
        return pattern.popularity < 0.3 || 
               pattern.frequency < 0.1;
    }
}
```

#### 5.3.2 ì••ì¶• ë° ì§ë ¬í™” ìµœì í™”
```java
// ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±ì„ ìœ„í•œ ì••ì¶• ë° ì§ë ¬í™” ì „ëµ
@Component
public class OptimizedSerialization {
    
    // L1: ì••ì¶• ì—†ì´ ê°ì²´ í˜•íƒœë¡œ ì €ì¥ (ì†ë„ ìš°ì„ )
    public void storeInL1(Long key, Product product) {
        l1Cache.put(key, product); // ì§ì ‘ ê°ì²´ ì €ì¥
    }
    
    // L2: ì••ì¶•ëœ JSON í˜•íƒœë¡œ ì €ì¥ (ìš©ëŸ‰ íš¨ìœ¨ì„±)
    public void storeInL2(Long key, Product product) {
        try {
            // JSON ì§ë ¬í™” í›„ ì••ì¶•
            String json = objectMapper.writeValueAsString(product);
            byte[] compressed = gzipCompress(json.getBytes());
            
            redisTemplate.opsForValue().set(
                "product:" + key, 
                Base64.getEncoder().encodeToString(compressed),
                Duration.ofHours(1)
            );
        } catch (Exception e) {
            log.warn("L2 ìºì‹œ ì €ì¥ ì‹¤íŒ¨: key={}", key, e);
        }
    }
    
    public Product loadFromL2(Long key) {
        try {
            String encoded = redisTemplate.opsForValue().get("product:" + key);
            if (encoded != null) {
                byte[] compressed = Base64.getDecoder().decode(encoded);
                String json = new String(gzipDecompress(compressed));
                return objectMapper.readValue(json, Product.class);
            }
        } catch (Exception e) {
            log.warn("L2 ìºì‹œ ë¡œë“œ ì‹¤íŒ¨: key={}", key, e);
        }
        return null;
    }
    
    // ì••ì¶•ë¥  ê°œì„  íš¨ê³¼:
    // - JSON í¬ê¸°: 2KB
    // - ì••ì¶• í›„: 800B (60% ì••ì¶•)
    // - Redis ë©”ëª¨ë¦¬ ì ˆì•½: 60%
}
```

#### 5.3.3 ê³„ì¸µë³„ ë°ì´í„° ìµœì í™”
```java
// ê³„ì¸µë³„ë¡œ ì„œë¡œ ë‹¤ë¥¸ ë°ì´í„° êµ¬ì¡° ì €ì¥
@Component
public class LayeredDataOptimization {
    
    // L1: í’€ ê°ì²´ ì €ì¥ (ë¹ ë¥¸ ì ‘ê·¼)
    private final Cache<Long, Product> l1FullCache;
    
    // L2: í•µì‹¬ í•„ë“œë§Œ ì €ì¥ (ë©”ëª¨ë¦¬ ì ˆì•½)
    private final RedisTemplate<String, ProductSummary> l2SummaryCache;
    
    @Data
    public static class ProductSummary {
        private Long id;
        private String name;
        private BigDecimal price;
        private Integer stock;
        // ìƒì„¸ ì„¤ëª…, ì´ë¯¸ì§€ URL ë“± ìƒëµ (70% í¬ê¸° ê°ì†Œ)
    }
    
    public Product getProduct(Long productId) {
        // L1: ì „ì²´ ê°ì²´ ì¡°íšŒ
        Product fullProduct = l1FullCache.getIfPresent(productId);
        if (fullProduct != null) {
            return fullProduct;
        }
        
        // L2: ìš”ì•½ ì •ë³´ ì¡°íšŒ
        ProductSummary summary = l2SummaryCache.opsForValue().get("summary:" + productId);
        if (summary != null) {
            // ìƒì„¸ ì •ë³´ê°€ í•„ìš”í•œ ê²½ìš°ì—ë§Œ DB ì¡°íšŒ
            if (isDetailRequired()) {
                fullProduct = loadFullProductFromDB(productId);
                l1FullCache.put(productId, fullProduct);
                return fullProduct;
            } else {
                // ìš”ì•½ ì •ë³´ë¥¼ í’€ ê°ì²´ë¡œ ë³€í™˜
                return convertToFullProduct(summary);
            }
        }
        
        // L3: DBì—ì„œ ì „ì²´ ì¡°íšŒ
        return loadFullProductFromDB(productId);
    }
    
    // ë©”ëª¨ë¦¬ ì ˆì•½ íš¨ê³¼:
    // - L1: 1000ê°œ Ã— 2KB = 2MB
    // - L2: 10000ê°œ Ã— 600B = 6MB (ê¸°ì¡´ 20MBì—ì„œ 70% ì ˆì•½)
    // - ì´ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰: 8MB (ê¸°ì¡´ 22MBì—ì„œ 64% ì ˆì•½)
}
```

---

## 6. ì‹¤ì œ êµ¬í˜„ ì‚¬ë¡€

### 6.1 Spring Boot ê¸°ë°˜ 3-Tier ìºì‹œ êµ¬í˜„

```java
// í”„ë¡œë•ì…˜ ë ˆë²¨ í‹°ì–´ë“œ ìºì‹œ êµ¬í˜„
@Configuration
@EnableCaching
public class TieredCacheConfiguration {
    
    // L1: Caffeine ë¡œì»¬ ìºì‹œ
    @Bean
    @Primary
    public CacheManager l1CacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        cacheManager.setCaffeine(Caffeine.newBuilder()
            .maximumSize(1000)
            .expireAfterAccess(Duration.ofMinutes(5))
            .recordStats()
        );
        return cacheManager;
    }
    
    // L2: Redis ë¶„ì‚° ìºì‹œ
    @Bean
    public CacheManager l2CacheManager() {
        RedisCacheManager.Builder builder = RedisCacheManager
            .RedisCacheManagerBuilder
            .fromConnectionFactory(redisConnectionFactory())
            .cacheDefaults(cacheConfiguration());
            
        return builder.build();
    }
    
    private RedisCacheConfiguration cacheConfiguration() {
        return RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofHours(1))
            .serializeKeysWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new GenericJackson2JsonRedisSerializer()));
    }
}

// í‹°ì–´ë“œ ìºì‹œ ì„œë¹„ìŠ¤ êµ¬í˜„
@Service
@Slf4j
public class TieredProductCacheService {
    
    @Autowired
    @Qualifier("l1CacheManager")
    private CacheManager l1CacheManager;
    
    @Autowired
    @Qualifier("l2CacheManager") 
    private CacheManager l2CacheManager;
    
    @Autowired
    private ProductRepository productRepository;
    
    public Product getProduct(Long productId) {
        // L1 ìºì‹œ ì‹œë„
        Cache l1Cache = l1CacheManager.getCache("products");
        Cache.ValueWrapper l1Value = l1Cache.get(productId);
        if (l1Value != null) {
            log.debug("L1 ìºì‹œ íˆíŠ¸: productId={}", productId);
            return (Product) l1Value.get();
        }
        
        // L2 ìºì‹œ ì‹œë„
        Cache l2Cache = l2CacheManager.getCache("products");
        Cache.ValueWrapper l2Value = l2Cache.get(productId);
        if (l2Value != null) {
            log.debug("L2 ìºì‹œ íˆíŠ¸: productId={}", productId);
            Product product = (Product) l2Value.get();
            
            // L1ìœ¼ë¡œ ìŠ¹ê²©
            l1Cache.put(productId, product);
            return product;
        }
        
        // L3 ë°ì´í„°ë² ì´ìŠ¤ ì¡°íšŒ
        log.debug("ìºì‹œ ë¯¸ìŠ¤, DB ì¡°íšŒ: productId={}", productId);
        Optional<Product> productOpt = productRepository.findById(productId);
        
        if (productOpt.isPresent()) {
            Product product = productOpt.get();
            
            // ìƒìœ„ ê³„ì¸µë“¤ì— ì €ì¥
            l2Cache.put(productId, product);
            if (isPopularProduct(productId)) {
                l1Cache.put(productId, product);
            }
            
            return product;
        }
        
        return null;
    }
    
    private boolean isPopularProduct(Long productId) {
        // ê°„ë‹¨í•œ ì¸ê¸°ë„ íŒë‹¨ ë¡œì§
        // ì‹¤ì œë¡œëŠ” Redis ë­í‚¹, ì ‘ê·¼ ë¹ˆë„ ë“±ì„ ì¢…í•© íŒë‹¨
        return productId % 10 == 0; // ì˜ˆì‹œ: 10% í™•ë¥ ë¡œ ì¸ê¸° ìƒí’ˆ
    }
    
    // ìºì‹œ ë¬´íš¨í™”
    public void invalidateProduct(Long productId) {
        l1CacheManager.getCache("products").evict(productId);
        l2CacheManager.getCache("products").evict(productId);
        log.info("ìƒí’ˆ ìºì‹œ ë¬´íš¨í™”: productId={}", productId);
    }
}
```

### 6.2 ë¹„ë™ê¸° ê³„ì¸µ ê°±ì‹  êµ¬í˜„

```java
// ë¹„ë™ê¸°ë¡œ í•˜ìœ„ ê³„ì¸µ ê°±ì‹ í•˜ì—¬ ì„±ëŠ¥ ìµœì í™”
@Component
public class AsyncTierSynchronizer {
    
    @Autowired
    private TaskExecutor cacheUpdateExecutor;
    
    @Autowired
    private RedisTemplate<String, Product> redisTemplate;
    
    // L1ì—ì„œ íˆíŠ¸ëœ ë°ì´í„°ì˜ L2 ê°±ì‹ ì„ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì²˜ë¦¬
    @Async("cacheUpdateExecutor")
    public void refreshL2Cache(Long productId, Product product) {
        try {
            // L2 ìºì‹œì˜ TTL ì—°ì¥
            String key = "product:" + productId;
            redisTemplate.opsForValue().set(key, product, Duration.ofHours(1));
            
            log.debug("L2 ìºì‹œ ë°±ê·¸ë¼ìš´ë“œ ê°±ì‹ : productId={}", productId);
            
        } catch (Exception e) {
            log.warn("L2 ìºì‹œ ë°±ê·¸ë¼ìš´ë“œ ê°±ì‹  ì‹¤íŒ¨: productId={}", productId, e);
        }
    }
    
    // ì£¼ê¸°ì ìœ¼ë¡œ ì¸ê¸° ìƒí’ˆì„ L1ìœ¼ë¡œ ì˜ˆì—´
    @Scheduled(fixedRate = 300000) // 5ë¶„ë§ˆë‹¤
    public void warmupL1Cache() {
        try {
            // Redisì—ì„œ ì¸ê¸° ìƒí’ˆ TOP 100 ì¡°íšŒ
            Set<String> popularProducts = redisTemplate.opsForZSet()
                .reverseRange("popular_products", 0, 99);
                
            if (popularProducts != null) {
                popularProducts.forEach(productIdStr -> {
                    Long productId = Long.parseLong(productIdStr);
                    warmupProduct(productId);
                });
                
                log.info("L1 ìºì‹œ ì›œì—… ì™„ë£Œ: {} products", popularProducts.size());
            }
            
        } catch (Exception e) {
            log.error("L1 ìºì‹œ ì›œì—… ì‹¤íŒ¨", e);
        }
    }
    
    private void warmupProduct(Long productId) {
        // L1 ìºì‹œì— ì—†ìœ¼ë©´ L2ì—ì„œ ê°€ì ¸ì™€ì„œ ì €ì¥
        Cache l1Cache = l1CacheManager.getCache("products");
        if (l1Cache.get(productId) == null) {
            Product product = redisTemplate.opsForValue().get("product:" + productId);
            if (product != null) {
                l1Cache.put(productId, product);
            }
        }
    }
}
```

### 6.3 ìºì‹œ ë©”íŠ¸ë¦­ìŠ¤ ë° ëª¨ë‹ˆí„°ë§

```java
// í¬ê´„ì ì¸ ìºì‹œ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
@Component
public class TieredCacheMetrics {
    
    private final MeterRegistry meterRegistry;
    private final Timer l1ResponseTime;
    private final Timer l2ResponseTime;
    private final Timer l3ResponseTime;
    private final Counter l1Hits;
    private final Counter l2Hits;
    private final Counter l3Hits;
    
    public TieredCacheMetrics(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        
        this.l1ResponseTime = Timer.builder("cache.response.time")
            .tag("tier", "L1").register(meterRegistry);
        this.l2ResponseTime = Timer.builder("cache.response.time")
            .tag("tier", "L2").register(meterRegistry);
        this.l3ResponseTime = Timer.builder("cache.response.time")
            .tag("tier", "L3").register(meterRegistry);
            
        this.l1Hits = Counter.builder("cache.hits")
            .tag("tier", "L1").register(meterRegistry);
        this.l2Hits = Counter.builder("cache.hits")
            .tag("tier", "L2").register(meterRegistry);
        this.l3Hits = Counter.builder("cache.hits")
            .tag("tier", "L3").register(meterRegistry);
    }
    
    public Product getProductWithMetrics(Long productId) {
        Timer.Sample sample = Timer.start(meterRegistry);
        
        try {
            // L1 ì‹œë„
            Product product = getFromL1(productId);
            if (product != null) {
                l1Hits.increment();
                sample.stop(l1ResponseTime);
                return product;
            }
            
            // L2 ì‹œë„
            product = getFromL2(productId);
            if (product != null) {
                l2Hits.increment();
                sample.stop(l2ResponseTime);
                return product;
            }
            
            // L3 ì‹œë„
            product = getFromL3(productId);
            if (product != null) {
                l3Hits.increment();
                sample.stop(l3ResponseTime);
                return product;
            }
            
            return null;
            
        } finally {
            // ì „ì²´ ì‘ë‹µ ì‹œê°„ë„ ë³„ë„ ì¸¡ì •
            sample.stop(Timer.builder("cache.total.response.time")
                .register(meterRegistry));
        }
    }
    
    // ìºì‹œ íš¨ìœ¨ì„± ë¦¬í¬íŠ¸ ìƒì„±
    @Scheduled(fixedRate = 60000) // 1ë¶„ë§ˆë‹¤
    public void generateCacheReport() {
        double l1HitRate = getHitRate("L1");
        double l2HitRate = getHitRate("L2");
        double l3HitRate = getHitRate("L3");
        
        double avgL1ResponseTime = getAverageResponseTime("L1");
        double avgL2ResponseTime = getAverageResponseTime("L2");
        double avgL3ResponseTime = getAverageResponseTime("L3");
        
        log.info("=== ìºì‹œ ì„±ëŠ¥ ë¦¬í¬íŠ¸ ===");
        log.info("L1 íˆíŠ¸ìœ¨: {:.2f}%, í‰ê·  ì‘ë‹µì‹œê°„: {:.2f}ms", l1HitRate * 100, avgL1ResponseTime);
        log.info("L2 íˆíŠ¸ìœ¨: {:.2f}%, í‰ê·  ì‘ë‹µì‹œê°„: {:.2f}ms", l2HitRate * 100, avgL2ResponseTime);
        log.info("L3 íˆíŠ¸ìœ¨: {:.2f}%, í‰ê·  ì‘ë‹µì‹œê°„: {:.2f}ms", l3HitRate * 100, avgL3ResponseTime);
        
        // ì „ì²´ ì„±ëŠ¥ ì§€í‘œ
        double totalWeightedResponseTime = 
            avgL1ResponseTime * l1HitRate +
            avgL2ResponseTime * l2HitRate * (1 - l1HitRate) +
            avgL3ResponseTime * (1 - l1HitRate - l2HitRate);
            
        log.info("ì „ì²´ ê°€ì¤‘ í‰ê·  ì‘ë‹µì‹œê°„: {:.2f}ms", totalWeightedResponseTime);
    }
}
```

---

## 7. ì„±ëŠ¥ ìµœì í™” ì „ëµ

### 7.1 ì ì‘í˜• ê³„ì¸µ ê´€ë¦¬

```java
// ì‹¤ì‹œê°„ ì„±ëŠ¥ ë¶„ì„ì„ í†µí•œ ë™ì  ê³„ì¸µ ì¡°ì •
@Component
public class AdaptiveTierManager {
    
    private final CircularBuffer<PerformanceMetric> performanceHistory = new CircularBuffer<>(1000);
    
    @Data
    public static class PerformanceMetric {
        private long timestamp;
        private String tier;
        private double responseTime;
        private boolean hit;
        private Long dataSize;
    }
    
    // ì„±ëŠ¥ ê¸°ë°˜ ìë™ ì¡°ì •
    @Scheduled(fixedRate = 30000) // 30ì´ˆë§ˆë‹¤
    public void optimizeTierConfiguration() {
        PerformanceAnalysis analysis = analyzeRecentPerformance();
        
        if (analysis.l1HitRate < 0.7 && analysis.l1AvgResponseTime > 1.0) {
            // L1 ì„±ëŠ¥ì´ ì €í•˜ëœ ê²½ìš° ìš©ëŸ‰ í™•ì¥
            expandL1Cache();
        }
        
        if (analysis.l2ResponseTime > 5.0) {
            // L2 ì‘ë‹µì‹œê°„ì´ ë„ˆë¬´ ê¸´ ê²½ìš° ì••ì¶•ë¥  ì¡°ì •
            adjustL2Compression();
        }
        
        if (analysis.memoryPressure > 0.8) {
            // ë©”ëª¨ë¦¬ ë¶€ì¡± ì‹œ ì ê·¹ì ì¸ eviction
            triggerAggressiveEviction();
        }
    }
    
    private PerformanceAnalysis analyzeRecentPerformance() {
        List<PerformanceMetric> recentMetrics = performanceHistory.getRecent(Duration.ofMinutes(5));
        
        return PerformanceAnalysis.builder()
            .l1HitRate(calculateHitRate(recentMetrics, "L1"))
            .l2HitRate(calculateHitRate(recentMetrics, "L2"))
            .l1AvgResponseTime(calculateAvgResponseTime(recentMetrics, "L1"))
            .l2ResponseTime(calculateAvgResponseTime(recentMetrics, "L2"))
            .memoryPressure(getCurrentMemoryPressure())
            .build();
    }
    
    // ë™ì  L1 ìºì‹œ í™•ì¥
    private void expandL1Cache() {
        int currentSize = l1Cache.asMap().size();
        int newSize = Math.min(currentSize * 2, 5000); // ìµœëŒ€ 5000ê°œê¹Œì§€
        
        // ìƒˆë¡œìš´ ìºì‹œ ìƒì„±
        Cache<Long, Product> expandedCache = Caffeine.newBuilder()
            .maximumSize(newSize)
            .expireAfterAccess(Duration.ofMinutes(5))
            .build();
            
        // ê¸°ì¡´ ë°ì´í„° ë§ˆì´ê·¸ë ˆì´ì…˜
        l1Cache.asMap().forEach(expandedCache::put);
        this.l1Cache = expandedCache;
        
        log.info("L1 ìºì‹œ í™•ì¥: {} â†’ {}", currentSize, newSize);
    }
}
```

### 7.2 ì§€ëŠ¥í˜• í”„ë¦¬í˜ì¹­

```java
// ì‚¬ìš©ì í–‰ë™ íŒ¨í„´ ë¶„ì„ì„ í†µí•œ ì˜ˆì¸¡ì  ìºì‹±
@Component
public class IntelligentPrefetcher {
    
    private final Map<String, UserBehaviorPattern> userPatterns = new ConcurrentHashMap<>();
    
    @Data
    public static class UserBehaviorPattern {
        private String userId;
        private List<Long> viewHistory = new ArrayList<>(); // ìµœê·¼ ì¡°íšŒ ì´ë ¥
        private Map<Long, Long> viewSequences = new HashMap<>(); // A ì¡°íšŒ í›„ B ì¡°íšŒ íŒ¨í„´
        private Set<String> preferredCategories = new HashSet<>();
    }
    
    // ì‚¬ìš©ì ì¡°íšŒ ì‹œ ë‹¤ìŒ ì¡°íšŒ ì˜ˆì¸¡ ë° í”„ë¦¬í˜ì¹˜
    public void onProductView(String userId, Long productId) {
        UserBehaviorPattern pattern = userPatterns.computeIfAbsent(userId, 
            k -> new UserBehaviorPattern());
            
        // íŒ¨í„´ ì—…ë°ì´íŠ¸
        updateUserPattern(pattern, productId);
        
        // ë‹¤ìŒ ì¡°íšŒ ìƒí’ˆ ì˜ˆì¸¡
        List<Long> predictedProducts = predictNextProducts(pattern, productId);
        
        // ë°±ê·¸ë¼ìš´ë“œì—ì„œ í”„ë¦¬í˜ì¹˜
        prefetchProducts(predictedProducts);
    }
    
    private List<Long> predictNextProducts(UserBehaviorPattern pattern, Long currentProductId) {
        List<Long> predictions = new ArrayList<>();
        
        // 1. ìˆœì°¨ ì¡°íšŒ íŒ¨í„´ (A ë‹¤ìŒì— Bë¥¼ ìì£¼ ë³¸ë‹¤)
        Long nextInSequence = pattern.getViewSequences().get(currentProductId);
        if (nextInSequence != null) {
            predictions.add(nextInSequence);
        }
        
        // 2. ì¹´í…Œê³ ë¦¬ ê¸°ë°˜ ì¶”ì²œ
        Product currentProduct = getProduct(currentProductId);
        if (currentProduct != null) {
            List<Long> similarProducts = findSimilarProducts(currentProduct, 3);
            predictions.addAll(similarProducts);
        }
        
        // 3. ê°œì¸í™” ì¶”ì²œ (ìµœê·¼ ê´€ì‹¬ ì¹´í…Œê³ ë¦¬)
        pattern.getPreferredCategories().forEach(category -> {
            List<Long> categoryProducts = getPopularProductsInCategory(category, 2);
            predictions.addAll(categoryProducts);
        });
        
        return predictions.stream().distinct().limit(5).collect(Collectors.toList());
    }
    
    @Async("prefetchExecutor")
    private void prefetchProducts(List<Long> productIds) {
        productIds.forEach(productId -> {
            try {
                // L2 ìºì‹œì— ë¯¸ë¦¬ ë¡œë“œ
                if (!isInAnyCache(productId)) {
                    Product product = productRepository.findById(productId).orElse(null);
                    if (product != null) {
                        redisTemplate.opsForValue().set("product:" + productId, product, Duration.ofMinutes(30));
                        log.debug("í”„ë¦¬í˜ì¹˜ ì™„ë£Œ: productId={}", productId);
                    }
                }
            } catch (Exception e) {
                log.warn("í”„ë¦¬í˜ì¹˜ ì‹¤íŒ¨: productId={}", productId, e);
            }
        });
    }
    
    // í”„ë¦¬í˜ì¹˜ íš¨ê³¼ ì¸¡ì •
    @EventListener
    public void onCacheHit(CacheHitEvent event) {
        if (event.getTier().equals("L2") && isPrefetchedData(event.getKey())) {
            prefetchHitCounter.increment();
            log.debug("í”„ë¦¬í˜ì¹˜ ì„±ê³µ: key={}", event.getKey());
        }
    }
}
```

### 7.3 ë¹„ìš© ê¸°ë°˜ ìµœì í™”

```java
// ë¹„ìš©-ì„±ëŠ¥ íŠ¸ë ˆì´ë“œì˜¤í”„ ë¶„ì„ì„ í†µí•œ ìµœì í™”
@Component
public class CostOptimizedTierManager {
    
    @Value("${cache.cost.redis-per-mb-per-hour:0.02}")
    private double redisCostPerMBPerHour;
    
    @Value("${cache.cost.compute-per-cpu-hour:0.1}")
    private double computeCostPerCPUHour;
    
    // ë¹„ìš© íš¨ìœ¨ì„± ë¶„ì„
    public CostAnalysis analyzeCostEfficiency() {
        long l1MemoryUsageMB = getL1MemoryUsageMB();
        long l2MemoryUsageMB = getL2MemoryUsageMB();
        
        double l1HitRate = getCacheHitRate("L1");
        double l2HitRate = getCacheHitRate("L2");
        
        // ì‹œê°„ë‹¹ ë¹„ìš© ê³„ì‚°
        double redisCostPerHour = l2MemoryUsageMB * redisCostPerMBPerHour;
        double computeCostPerHour = getComputeUsage() * computeCostPerCPUHour;
        double totalCostPerHour = redisCostPerHour + computeCostPerHour;
        
        // ì„±ëŠ¥ í–¥ìƒ ê³„ì‚°
        double avgResponseTimeWithoutCache = 100; // 100ms (DB ì§ì ‘ ì¡°íšŒ)
        double currentAvgResponseTime = calculateWeightedResponseTime();
        double performanceImprovement = avgResponseTimeWithoutCache / currentAvgResponseTime;
        
        // ë¹„ìš© ëŒ€ë¹„ ì„±ëŠ¥ ë¹„ìœ¨
        double costEfficiencyRatio = performanceImprovement / totalCostPerHour;
        
        return CostAnalysis.builder()
            .totalCostPerHour(totalCostPerHour)
            .performanceImprovement(performanceImprovement)
            .costEfficiencyRatio(costEfficiencyRatio)
            .recommendation(generateOptimizationRecommendation(costEfficiencyRatio))
            .build();
    }
    
    private OptimizationRecommendation generateOptimizationRecommendation(double ratio) {
        if (ratio < 5.0) {
            return new OptimizationRecommendation(
                "ë¹„ìš© ëŒ€ë¹„ íš¨ê³¼ê°€ ë‚®ìŒ. L2 ìºì‹œ í¬ê¸° ê°ì†Œ ê¶Œì¥",
                Arrays.asList(
                    "L2 ìºì‹œ ìš©ëŸ‰ì„ 50% ê°ì†Œ",
                    "TTLì„ 30ë¶„ìœ¼ë¡œ ë‹¨ì¶•",
                    "ì••ì¶•ë¥  ì¦ê°€"
                )
            );
        } else if (ratio > 20.0) {
            return new OptimizationRecommendation(
                "ë¹„ìš© ëŒ€ë¹„ íš¨ê³¼ê°€ ë†’ìŒ. ìºì‹œ í™•ì¥ ê³ ë ¤",
                Arrays.asList(
                    "L1 ìºì‹œ ìš©ëŸ‰ì„ 2ë°° ì¦ê°€",
                    "L2 ìºì‹œ ìš©ëŸ‰ì„ 50% ì¦ê°€", 
                    "í”„ë¦¬í˜ì¹˜ í™œì„±í™”"
                )
            );
        } else {
            return new OptimizationRecommendation(
                "í˜„ì¬ ì„¤ì •ì´ ì ì ˆí•¨. ìœ ì§€ ê¶Œì¥",
                Collections.emptyList()
            );
        }
    }
    
    // ìë™ ìµœì í™” ì‹¤í–‰
    @Scheduled(fixedRate = 3600000) // 1ì‹œê°„ë§ˆë‹¤
    public void performAutomaticOptimization() {
        CostAnalysis analysis = analyzeCostEfficiency();
        
        if (analysis.getCostEfficiencyRatio() < 5.0) {
            // ë¹„íš¨ìœ¨ì ì¸ ê²½ìš° ìºì‹œ í¬ê¸° ê°ì†Œ
            reduceL2CacheSize(0.8); // 20% ê°ì†Œ
            log.info("ë¹„ìš© ìµœì í™”: L2 ìºì‹œ í¬ê¸° 20% ê°ì†Œ");
            
        } else if (analysis.getCostEfficiencyRatio() > 20.0) {
            // ë§¤ìš° íš¨ìœ¨ì ì¸ ê²½ìš° ìºì‹œ í™•ì¥
            expandL1CacheSize(1.5); // 50% ì¦ê°€
            log.info("ì„±ëŠ¥ ìµœì í™”: L1 ìºì‹œ í¬ê¸° 50% ì¦ê°€");
        }
    }
}
```

---

## 8. ê²°ë¡ 

### 8.1 í‹°ì–´ë“œ ìºì‹± ì „ëµì˜ ê°€ì¹˜

í‹°ì–´ë“œ ìºì‹±ì€ **ë‹¨ì¼ ê³„ì¸µ ìºì‹œì˜ í•œê³„ë¥¼ ê·¹ë³µ**í•˜ê³  **ë¹„ìš©ê³¼ ì„±ëŠ¥ì˜ ìµœì  ê· í˜•**ì„ ë‹¬ì„±í•˜ëŠ” ê°•ë ¥í•œ ì „ëµì…ë‹ˆë‹¤:

#### í•µì‹¬ ê°€ì¹˜
1. **ë¹„ìš© íš¨ìœ¨ì„±**: ë°ì´í„° ì ‘ê·¼ íŒ¨í„´ì— ë§ëŠ” ê³„ì¸µë³„ ë°°ì¹˜ë¡œ 90% ë¹„ìš© ì ˆê° ê°€ëŠ¥
2. **ì„±ëŠ¥ ìµœì í™”**: ë‹¤ì¤‘ ê³„ì¸µìœ¼ë¡œ í‰ê·  ì‘ë‹µì‹œê°„ 86% ë‹¨ì¶•
3. **í™•ì¥ì„±**: ê³„ì¸µë³„ ë…ë¦½ì  í™•ì¥ìœ¼ë¡œ ìœ ì—°í•œ ìš©ëŸ‰ ê´€ë¦¬
4. **ë³µì›ë ¥**: ê³„ì¸µë³„ ì¥ì•  ê²©ë¦¬ë¡œ ì „ì²´ ì„œë¹„ìŠ¤ ì•ˆì •ì„± í–¥ìƒ

### 8.2 í•œê³„ì ê³¼ ê·¹ë³µ ì „ëµ ìš”ì•½

| í•œê³„ì  | ê·¹ë³µ ì „ëµ | êµ¬í˜„ ë³µì¡ë„ | íš¨ê³¼ |
|--------|-----------|-------------|------|
| ë°ì´í„° ì¼ê´€ì„± | ì´ë²¤íŠ¸ ê¸°ë°˜ ë¬´íš¨í™” + ë²„ì „ ê´€ë¦¬ | ì¤‘ê°„ | 90% ì¼ê´€ì„± í–¥ìƒ |
| ê´€ë¦¬ ë³µì¡ì„± | ì¶”ìƒí™” ë ˆì´ì–´ + ì •ì±… ì¤‘ì•™í™” | ë†’ìŒ | 70% ìš´ì˜ ë³µì¡ë„ ê°ì†Œ |
| ë©”ëª¨ë¦¬ ì¤‘ë³µ | ê³„ì¸µë³„ ë°ì´í„° ìµœì í™” + ì••ì¶• | ì¤‘ê°„ | 60% ë©”ëª¨ë¦¬ ì ˆì•½ |
| ë¹„ìš© ì˜ˆì¸¡ | ë¹„ìš© ê¸°ë°˜ ìë™ ìµœì í™” | ë†’ìŒ | ì‹¤ì‹œê°„ ë¹„ìš© ìµœì í™” |

### 8.3 ì‹¤ë¬´ ì ìš© ê¶Œì¥ì‚¬í•­

#### ë„ì… ë‹¨ê³„ë³„ ì ‘ê·¼
1. **1ë‹¨ê³„**: L1(Local) + L3(DB) êµ¬ì¡°ë¡œ ì‹œì‘
2. **2ë‹¨ê³„**: Redis L2 ê³„ì¸µ ì¶”ê°€í•˜ì—¬ 3-Tier ì™„ì„±
3. **3ë‹¨ê³„**: ì§€ëŠ¥í˜• ìµœì í™” ë° ìë™í™” ë„ì…

#### ì„±ê³µ ìš”ì†Œ
1. **ì ì§„ì  ë„ì…**: ì‘ì€ ë²”ìœ„ë¶€í„° ì‹œì‘í•˜ì—¬ ë‹¨ê³„ì  í™•ì¥
2. **ì² ì €í•œ ëª¨ë‹ˆí„°ë§**: ê³„ì¸µë³„ ì„±ëŠ¥ ì§€í‘œ ì‹¤ì‹œê°„ ì¶”ì 
3. **ë¹„ì¦ˆë‹ˆìŠ¤ íŠ¹ì„± ë°˜ì˜**: ë°ì´í„° ì¤‘ìš”ë„ì™€ ì ‘ê·¼ íŒ¨í„´ ê³ ë ¤
4. **ìë™í™” íˆ¬ì**: ìˆ˜ë™ ê´€ë¦¬ì˜ í•œê³„ë¥¼ ê·¹ë³µí•˜ëŠ” ìë™í™” ì‹œìŠ¤í…œ

### 8.4 ë¯¸ë˜ ë°œì „ ë°©í–¥

#### ì‹ ê¸°ìˆ  í†µí•©
1. **Machine Learning**: ì‚¬ìš©ì í–‰ë™ ì˜ˆì¸¡ ê¸°ë°˜ ì§€ëŠ¥í˜• ìºì‹±
2. **Edge Computing**: ì§€ì—­ë³„ ë¶„ì‚° ìºì‹œ ê³„ì¸µ í™•ì¥
3. **Cloud Native**: Kubernetes ê¸°ë°˜ ë™ì  ìºì‹œ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜

#### ì„±ëŠ¥ í˜ì‹ 
1. **NVMe ìŠ¤í† ë¦¬ì§€**: L2.5 ê³„ì¸µìœ¼ë¡œ ë©”ëª¨ë¦¬-ë””ìŠ¤í¬ ê°­ í•´ì†Œ
2. **RDMA ë„¤íŠ¸ì›Œí‚¹**: L2 ê³„ì¸µ ë„¤íŠ¸ì›Œí¬ ì§€ì—° ìµœì†Œí™”
3. **ì••ì¶• ì•Œê³ ë¦¬ì¦˜**: ì‹¤ì‹œê°„ ì••ì¶•ìœ¼ë¡œ ë©”ëª¨ë¦¬ íš¨ìœ¨ì„± ê·¹ëŒ€í™”

í‹°ì–´ë“œ ìºì‹±ì€ í˜„ëŒ€ ëŒ€ê·œëª¨ ì‹œìŠ¤í…œì—ì„œ **í•„ìˆ˜ì ì¸ ì•„í‚¤í…ì²˜ íŒ¨í„´**ì´ë©°, ì˜¬ë°”ë¥¸ ì„¤ê³„ì™€ êµ¬í˜„ì„ í†µí•´ ì‹œìŠ¤í…œì˜ ì„±ëŠ¥, ë¹„ìš©, ì•ˆì •ì„±ì„ ë™ì‹œì— ìµœì í™”í•  ìˆ˜ ìˆëŠ” ê°•ë ¥í•œ ë„êµ¬ì…ë‹ˆë‹¤.

---

**ì°¸ê³  ìë£Œ**
- "Designing Data-Intensive Applications" - Martin Kleppmann
- "High Performance Web Sites" - Steve Souders  
- Redis Documentation - Memory Optimization
- Caffeine Cache Documentation
- AWS ElastiCache Best Practices Guide