

## 개요
클린 아키텍처는 로버트 C. 마틴이 제안한 소프트웨어 설계 방식으로, 애플리케이션의 핵심 비즈니스 로직(Entities)을 중심으로 외부 시스템(예: UI, DB)과 분리하여 유지보수성과 테스트 가능성을 높입니다. 의존성 방향이 **밖에서 안으로**라는 개념은 외부 계층이 내부 계층에 의존하도록 설계된 점이 특징입니다.

### 레이어드 아키텍처와의 비유
레이어드 아키텍처는 일반적으로 요청이 위에서 아래로(예: Presentation → Business → Persistence → DB) 흐르고, 응답이 아래에서 위로 올라오는 계층 구조를 가집니다. 클린 아키텍처는 이와 달리, **내부 핵심 로직(Entities)이 모든 외부 계층을 제어**하며, 외부 계층(Frameworks & Drivers)이 내부를 향해 의존성을 가지는 구조로 볼 수 있습니다. 이는 마치 건물의 기초(Entities)가 튼튼해야 상층부(UI, DB)가 안정적으로 작동하는 것과 비슷합니다.

## 계층별 세부 내용

### 1. Entities (엔티티)
- **역할**: 애플리케이션의 핵심 비즈니스 규칙과 데이터 구조를 정의. 외부 시스템에 독립적.
- **비유**: 레이어드 아키텍처의 "Business Layer"와 유사하지만, 여기서는 모든 외부 계층이 의존하는 **중심 기둥** 역할.
- **특징**:
  - 비즈니스 로직을 캡슐화.
  - 기술(예: DB, UI)과 무관한 순수 객체.
- **예시**: `Order` 클래스에 주문 상태와 계산 로직 포함.

### 2. Use Cases (유스 케이스)
- **역할**: 애플리케이션의 동작(비즈니스 규칙 적용)을 정의. Entities를 활용해 구체적인 작업 수행.
- **비유**: 레이어드 아키텍처의 "Business Layer"에 해당하며, 이는 Persistence Layer가 아닌 Entities에 의존. 마치 건물의 설계도(Use Cases)가 기초(Entities)를 기반으로 설계되는 것.
- **특징**:
  - Input Port와 Output Port를 통해 외부와 통신.
  - Interactor가 Use Case를 실행.
- **예시**: `PlaceOrderUseCase`는 주문 생성 로직을 처리.

### 3. Interface Adapters (인터페이스 어댑터)
- **역할**: 외부 시스템(예: UI, DB)과 Use Cases 간의 변환을 담당. 데이터를 형식에 맞게 조정.
- **비유**: 레이어드 아키텍처의 "Presentation Layer"와 "Persistence Layer"를 연결하는 중간 층. 하지만 여기서는 Use Cases에 의존하며, 외부 기술(Controllers, Presenters)이 내부 로직을 따르는 구조.
- **특징**:
  - Controller: 외부 요청을 Use Case Input Port로 전달.
  - Presenter: Use Case Output Port의 결과를 UI 형식으로 변환.
- **예시**: `WebController`는 HTTP 요청을 `PlaceOrderInputPort`로 변환.

### 4. Frameworks & Drivers (프레임워크 및 드라이버)
- **역할**: 외부 기술(예: Web, DB, Devices)과 상호작용. 애플리케이션의 실행 환경 제공.
- **비유**: 레이어드 아키텍처의 "Presentation Layer"와 "Database Layer"에 해당. 하지만 의존성은 내부(Entities, Use Cases)로 향하며, 외부 기술이 내부 로직에 종속됨.
- **특징**:
  - DB, Web 서버, 외부 API 등 구현.
  - Interface Adapters를 통해 Use Cases와 연결.
- **예시**: Spring Framework, MySQL DB.

## 의존성 방향 (밖에서 안으로)
- **핵심 원칙**: 의존성은 외부(Frameworks & Drivers)에서 내부(Entities)로 향합니다. 이는 외부 기술이 변경되더라도 내부 로직이 영향을 받지 않도록 보호합니다.
- **비유**: 레이어드 아키텍처에서 각 계층이 아래로 의존한다면(예: Presentation → Business), 클린 아키텍처는 **내부 핵심 로직이 모든 계층을 지배**하는 구조. 마치 건물 설계자가 상층부(외부 기술)를 기초(Entities)에 맞춰 설계하듯, 외부는 내부에 맞춰야 함.
- **구현 예시**:
  - `WebController`는 `UseCaseInputPort`에 의존.
  - `JDBCGateway`는 `UseCaseOutputPort`에 의존.
  - Entities와 Use Cases는 외부 기술을 알 필요 없음.

## 데이터 흐름
- **요청**: Devices → Controllers → Use Case Input Port → Use Case Interactor → Entities.
- **응답**: Entities → Use Case Interactor → Use Case Output Port → Presenter → UI.
- **제어 흐름**: 외부(Controllers, Presenters)에서 내부(Use Cases, Entities)로 흐르며, 내부가 외부를 제어.

## 장점
- **독립성**: Entities와 Use Cases가 외부 기술로부터 분리되어 테스트 용이.
- **유연성**: Web에서 모바일로, 또는 SQL에서 NoSQL로 전환 가능.
- **재사용성**: 비즈니스 로직을 다른 애플리케이션에 재활용.

## 실제 프로젝트 구조 예시 (Java)
```
src/
├── main/
│   ├── java/
│   │   ├── com.example.order/
│   │   │   ├── entity/              # Entities
│   │   │   │   ├── Order.java
│   │   │   ├── usecase/             # Use Cases
│   │   │   │   ├── PlaceOrderUseCase.java
│   │   │   │   ├── ports/           # Ports
│   │   │   │   │   ├── input/PlaceOrderInputPort.java
│   │   │   │   │   ├── output/PlaceOrderOutputPort.java
│   │   │   ├── adapter/             # Interface Adapters
│   │   │   │   ├── web/             # Controllers
│   │   │   │   │   ├── WebController.java
│   │   │   │   ├── presenter/       # Presenters
│   │   │   │   │   ├── OrderPresenter.java
│   │   │   ├── infrastructure/      # Frameworks & Drivers
│   │   │   │   ├── db/              # DB Gateways
│   │   │   │   │   ├── JDBCGateway.java
│   │   │   │   ├── web/             # Web Framework
│   │   │   └── config/              # 설정
│   └── resources/
```

## 결론
클린 아키텍처의 의존성 방향(밖에서 안으로)은 내부 비즈니스 로직이 외부 기술을 지배하도록 설계된 점이 핵심입니다. 레이어드 아키텍처의 계층 의존과 달리, 내부(Entities)가 모든 외부(Frameworks)를 제어하는 구조를 상상하면 이해가 쉬워집니다. 이를 프로젝트에 적용해 독립성과 유연성을 높이세요.