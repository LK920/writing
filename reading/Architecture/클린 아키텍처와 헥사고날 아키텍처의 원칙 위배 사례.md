
클린 아키텍처와 헥사고날 아키텍처는 도메인 로직을 외부 프레임워크나 기술 세부사항으로부터 독립시켜 유지보수성과 테스트 용이성을 높이는 것을 목표로 합니다. 하지만 실제 개발에서 "외부에서 내부로 향한다"는 원칙이 깨지는 경우가 자주 발생합니다. 이 문서에서는 스프링 프레임워크를 중심으로 원칙이 위배되는 주요 사례, 문제점, 해결 방안을 정리합니다.

## 1. 스프링 @Transactional 어노테이션 사용

### 문제 상황
- 스프링의 `@Transactional` 어노테이션을 도메인 계층이나 서비스 계층에 직접 적용.
### 문제점
- **프레임워크 종속성**: `@Transactional`은 스프링 프레임워크에 강하게 결합된 어노테이션으로, 도메인 계층이 특정 기술에 의존하게 됨.
- **테스트 어려움**: 스프링 컨텍스트 없이 테스트가 어려워 단위 테스트가 복잡해짐.
- **디버깅 복잡성**: AOP 기반 동작으로 인해 디버깅이 어려울 수 있음.
### 해결 방안
- 트랜잭션 관리를 어댑터 계층(예: 컨트롤러 또는 어댑터)으로 이동.
- 도메인 계층에서는 트랜잭션 경계를 명시적으로 정의하지 않고, 포트 인터페이스로 추상화.
- 예시:
    ```java
    // 어댑터 계층
    @Transactional
    public void executeUseCase(Request request) {
        useCase.execute(request);
    }
    ```
    

## 2. 스프링 의존성 주입 (@Autowired, @Component)

### 문제 상황
- 도메인 계층에서 `@Autowired`나 `@Component` 같은 스프링 어노테이션 사용.
### 문제점
- **프레임워크 종속성**: 도메인 계층이 스프링 컨테이너에 의존.
- **테스트 복잡성**: 스프링 컨텍스트를 띄우지 않으면 객체 생성 및 주입이 어려움.
- **유연성 저하**: 다른 DI 프레임워크로 전환 시 도메인 로직 수정 필요.
### 해결 방안
- 의존성 주입을 어댑터 계층에서 처리.
- 도메인 계층에서는 인터페이스(포트)를 통해 의존성을 정의하고, 생성자 주입 활용.
- 예시:
    ```java
    // 도메인 계층
    public class MyService {
        private final RepositoryPort repository;
        public MyService(RepositoryPort repository) {
            this.repository = repository;
        }
    }
    ```

## 3. JPA 엔티티와 도메인 객체의 혼합

### 문제 상황
- 도메인 객체에 JPA의 `@Entity` 어노테이션 적용.
### 문제점
- **프레임워크 종속성**: 도메인 객체가 JPA와 데이터베이스 스키마에 결합.
- **변경 어려움**: 데이터베이스 또는 ORM 변경 시 도메인 객체 수정 필요.
- **복잡성 증가**: 프록시 객체, 지연 로딩 등으로 인해 로직 및 테스트가 복잡해짐.
### 해결 방안
- 도메인 객체와 JPA 엔티티를 분리, 도메인 객체는 순수 POJO로 유지.
- DTO 또는 매퍼(MapStruct 등)를 사용해 도메인 객체와 엔티티 간 매핑.
- 예시:
    ```java
    // 도메인 객체
    public class User {
        private String id;
        private String name;
    }
    // JPA 엔티티 (어댑터 계층)
    @Entity
    public class UserEntity {
        @Id private String id;
        private String name;
    }
    ```

## 4. 스프링 이벤트 (@EventListener, ApplicationEventPublisher)

### 문제 상황

- 도메인 계층에서 스프링의 이벤트 시스템 사용.

### 문제점

- **프레임워크 종속성**: 도메인 로직이 스프링 이벤트 시스템에 묶임.
- **유연성 저하**: 다른 이벤트 시스템(예: Kafka)으로 전환 시 도메인 로직 수정 필요.
- **테스트 어려움**: 스프링 컨텍스트가 필요해 단위 테스트가 복잡해짐.

### 해결 방안

- 도메인 이벤트를 POJO로 정의하고, 발행 로직을 포트 인터페이스로 추상화.
- 스프링의 `ApplicationEventPublisher`는 어댑터 계층에서 구현.
- 예시:
    
    ```java
    // 도메인 이벤트
    public class UserCreatedEvent {
        private String userId;
    }
    // 포트
    public interface EventPort {
        void publish(UserCreatedEvent event);
    }
    ```
    

## 5. 외부 라이브러리 또는 API 직접 호출

### 문제 상황
- 도메인 계층에서 AWS SDK, Apache Commons 등 외부 라이브러리 API 호출.
### 문제점
- **라이브러리 종속성**: 라이브러리 변경 시 도메인 로직 수정 필요.
- **테스트 복잡성**: 외부 라이브러리를 모킹하거나 스텁으로 대체해야 함.
- **유연성 저하**: 새로운 외부 시스템으로 전환 시 도메인 로직 수정.
### 해결 방안
- 외부 시스템 호출을 어댑터 계층으로 이동, 포트를 통해 추상화.
- 예시:
    ```java
    // 포트
    public interface FileStoragePort {
        void saveFile(String fileName, byte[] content);
    }
    // 어댑터 (AWS S3 구현)
    public class S3FileStorageAdapter implements FileStoragePort {
        private final S3Client s3Client;
        // 구현
    }
    ```

## 6. 프레임워크 예외 처리

### 문제 상황
- 도메인 계층에서 `DataAccessException` 같은 스프링 예외 직접 처리.
### 문제점
- **프레임워크 종속성**: 도메인 로직이 특정 예외에 의존.
- **유연성 저하**: 다른 기술 스택으로 전환 시 예외 처리 로직 수정 필요.
- **테스트 어려움**: 프레임워크 예외를 모킹해야 함.
### 해결 방안
- 도메인 전용 예외 정의 및 사용.
- 어댑터 계층에서 프레임워크 예외를 도메인 예외로 변환.
- 예시:
    ```java
    // 도메인 예외
    public class UserNotFoundException extends RuntimeException {}
    // 어댑터
    public class JpaRepositoryAdapter {
        public User findUser(String id) {
            try {
                return userRepository.findById(id);
            } catch (DataAccessException e) {
                throw new UserNotFoundException();
            }
        }
    }
    ```

## 7. 스프링 시큐리티와 도메인 로직 결합
### 문제 상황
- 도메인 계층에서 `SecurityContextHolder` 또는 `@PreAuthorize` 사용.
### 문제점
- **프레임워크 종속성**: 도메인 로직이 스프링 시큐리티에 결합.
- **유연성 저하**: 다른 인증 프레임워크(예: Shiro)로 전환 시 수정 필요.
- **테스트 복잡성**: 인증 컨텍스트를 모킹해야 함.
### 해결 방안
- 인증/인가 로직을 어댑터 계층에서 처리.
- 도메인 계층에서는 `UserContext` 같은 POJO로 사용자 정보 처리.
  - SecurityContextHolder는 어댑터 계층에서 호출하여 사용자 정보를 추출하고, 이를 도메인 계층으로 전달합니다.
  - 인가 로직은 포트 인터페이스로 추상화하여 도메인 계층이 특정 인증 프레임워크에 의존하지 않도록 합니다.
- 예시:
    ```java
    // 도메인 계층
    public class MyService {
        public void execute(UserContext context) {
            // 로직
        }
    }
    // 어댑터
    public class SecurityAdapter {
        public UserContext getCurrentUser() {
            Authentication auth = SecurityContextHolder.getContext().getAuthentication();
            return new UserContext(auth.getName());
        }
    }
    ```

## 8. REST API 스펙과의 강한 결합

### 문제 상황
- 도메인 계층에서 `ResponseEntity` 또는 `HttpStatus` 같은 REST API 객체 직접 처리.
### 문제점
- **외부 인터페이스 종속성**: 도메인 로직이 REST API에 결합.
- **유연성 저하**: gRPC, GraphQL 등 다른 프로토콜로 전환 시 수정 필요.
- **복잡성 증가**: API 스펙 변경이 도메인 로직에 영향을 미침.
### 해결 방안
- 도메인 계층은 DTO 또는 도메인 객체 사용.
- REST API 로직은 컨트롤러 또는 어댑터 계층에서 처리.
  - API 스펙 변경 시, 어댑터 계층에서 매핑 로직만 수정하면 도메인 계층은 영향을 받지 않습니다.
- 예시:
    ```java
    // 컨트롤러
    @RestController
    public class MyController {
        @GetMapping("/users/{id}")
        public ResponseEntity<UserDto> getUser(@PathVariable String id) {
            User user = userService.findUser(id);
            return ResponseEntity.ok(new UserDto(user));
        }
    }
    ```

## 종합적인 문제점 요약
- **프레임워크 종속성**
	- 도메인 계층이 스프링, JPA, 또는 다른 외부 라이브러리에 의존하면, 기술 스택 변경 시 도메인 로직도 수정해야 합니다.
- **테스트 어려움**
	- 프레임워크에 의존적인 코드는 단위 테스트 시 프레임워크 컨텍스트를 띄우거나 모킹이 필요해 테스트가 복잡해집니다.
- **유연성 저하**
	- 외부 시스템의 세부사항에 결합된 도메인 로직은 새로운 요구사항(예: 다른 DB, 다른 API 프로토콜) 대응에 유연하지 못합니다.
- **유지보수성 저하**
	- 도메인 로직과 프레임워크 코드가 섞이면 코드가 복잡해지고, 디버깅 및 리팩토링이 어려워집니다.

## 권장 사항
1. **도메인 계층 순수성 유지**: POJO로 작성, 프레임워크 의존성 제거.
2. **포트와 어댑터 패턴 활용**: 외부 시스템과의 인터페이스를 포트로 추상화.
3. **명시적 의존성 주입**: 생성자 주입을 통해 의존성 명확화.
4. **테스트 용이성 확보**: 모킹을 통해 단위 테스트 간소화.
5. **예외 및 이벤트 추상화**: 도메인 전용 예외와 이벤트를 정의.

이러한 원칙을 준수하면 클린 아키텍처의 원칙을 지키면서도 스프링 프레임워크를 효과적으로 사용할 수 있으며, 시스템의 유연성과 유지보수성을 크게 향상시킬 수 있습니다.