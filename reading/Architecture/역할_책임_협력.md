

객체지향 프로그래밍에서 **역할/책임/협력**을 왜 계속 이야기할까?



우리가 ERD 에 속성을 결정해버리고 개발하면 어떤 문제가 발생할까?

해당 객체가 어떻게 사용될 **문맥(context)**을 고려하지 않은 채 데이터를 설계하게 된다. 그래서 억지로 껴맞추는 코딩을 하게된다. 예를 들어 join sql 문으로 2중 3중의 SQL 문을 만들고 있다면 그런 냄새가 이미 풍기고 있다고 생각한다.



객체가 똑똑하게 만들기 위해서는 객체가 사용될 문맥이 필요한데, 여기서 **책임**이라는 단어가 등장.
그러면 여기서 말하는 문맥이란 무엇일까? 문맥을 이해하기 위해 조금만 더 절차지향에 대해서 문제점을 이야기해보자.

다시 절차지향으로 돌아가서 문제점이 무엇인지 다시 이야기해보자.

 클래스 내부 속성이 결정되어버렸기 때문에, 내부 데이터에 강하게 결합된 코딩을 하게 된다. @Service 라고 붙은 객체에 비지니스 로직이 몰리고, 객체는 Getter / Setter 만 남게 된다. 우리가 코딩한 PointService 의 충전/사용을 상상해보자. UserPoint 에 넣을 수 있는 비지니스 로직을 서비스 레이어에 넣었다.

 @Service 에 있는 비지니스 로직을 도메인 객체로 옮기면 어떻게 될까? 비지니스 로직을 도메인 객체로 옮기면 **객체는 행동을 가지게 된다.** 그 행동은 외부에 어떤 데이터를 제공할지에 대해서 결정하게 된다.(외부에서 userPoint.charge(..) 호출하게 될 것) 

여기서 우리는 객체의 행동은 (외부, 누군지 모르지만) 협력안에서 결정하게 된다는 것을 알 수 있다. 

이때 userPoint.charge 라는 행동을 먼저 결정하고, 행동에 필요한 데이터는 나중에 결정되어져야 한다. 만약 먼저 결정해버리면 역시 앞에서 설명한 것과 같이 내부데이터에 의존적인(getter/setter) 코드를 작성하게 된다.



방금 우리는 행동을 통해 **협력**이라는 단어를 이해했고, 협력안에서 내부데이터가 결정된다는 사실을 이해했다.



그럼 책임은 뭘까? 

책임은 객체의 행동으로부터 만들어지게 된다. 크게 책임은 **행동** 관점에서 2가지로 나누어 생각해볼 수 있다.

- 하는 것(Doing)
  - 객체를 생성하거나 계산을 하는 등의 스스로 하는 것
  - 다른 객체(협력자)의 행동을 시작시키는 것
  - 다른 객체(협력자)의 활동을 제어하고 조절하는 것

- 아는 것(Knowing)
  - private 로 캡슐화된 상태(데이터)에 관해 아는 것
  - 관련된 객체(협력자)에 관련하여 아는 것
  - 자신이 유도하거나 계산할 수 있는 것(상태와 협력자)에 관하여 아는 것



**책임**은 객체의 행동으로부터 만들어진다고 했는데, 책임이 왜 중요할까? 

앞서 언급한 협력과 연관이 있다. 

 협력은 외부에서 사용될 행동을 제공하는데, 이 때 많은 행동이 하나의 객체에서 모두 이뤄진다면 어떠할까? 외부에서 바라볼때 어떤 객체가 주던 상관 없지만, 책임 관점에서는 적절하게 객체간 책임이 할당되어 있어야 할 것이다. 만약 결제라면, 결제에 관련된 행동이 모여있어야 하고, 주문이라면 주문에 관련된 행동이 모여있어야 한다. 

이처럼 책임은 자기 스스로 독립적이면서 self-description(자기 스스로 설명) 할 수 있는 존재가 될 수 있도록 도와준다. 협력은 외부의 관점에서 바라보는 거라면 책임은 내부에서 객체가 자신의 일을 잘하고 있는지 판단하는 근거가 될 수 있다.



그럼 **역할**은 무엇일까?

협력과 책임을 가진 도메인 모델링을 그리게 될 것이다. 지금까지 내용을 이해한다면 이런 질문을 던져볼 수 있다. 

그럼 모두다 객체로 존재하면 인터페이스는 왜 있는거지? 책임/협력에 따르면 인터페이스는 필요없을 것 같은데?

예시를 한번 들어보자.

이커머스에서 우리가 물건을 구매한다. 이 때 할인 정책을 활용해 우리는 할인을 받을 수 있다. 예를 들어 1000원 정액 할인을 받았다고 가정하면, 할인을 받는 물건 관점에서는 '물건은 할인을 받았다.' 라고 이야기할 수 있다.

어느날 또 물건을 구매하는데 10% 정률할인을 받았다. 역시나 우리는 '물건은 할인을 받았다.' 라고 말할 수 있다. 이때, 정률제 할인정책과 정액제 할인정책은 서로 다른 도메인일까? 위에서 언급한 협력관점에서 고민해보자. 

물건 관점에서는 어떤 정책이든 나는 할인을 받은거지, 그 안에 그게 정률이냐/정액이냐에 따라 물건이 달라지지는 않는다. 우리는 정액할인, 정률할인을 분류해서 이야기할 필요없이. 할인이라고 말할 수 있다. 여기서 역할은 바로 **할인**이라는 놈이 된다.

그리고 그 할인이 인터페이스가 되고, 구현체가 정액/정률할인으로 나타낼 수 있다.



--

GPT 버전

혹시 데이터 구조(예: ERD)를 먼저 확정하고 개발을 시작했을 때 어려움을 겪은 적 없으신가요? 이런 접근 방식은 종종 **객체가 실제로 어떻게 사용될지(문맥, Context)**를 충분히 고려하지 않은 채 데이터 설계를 하게 만듭니다. 그 결과, 데이터를 로직에 억지로 끼워 맞추는 코드를 작성하게 될 수 있습니다. 예를 들어, 복잡한 비즈니스 로직을 구현하기 위해 서비스 레이어에서 여러 테이블을 2중, 3중으로 JOIN 하는 SQL을 작성하고 있다면, 이미 설계가 잘못된 방향으로 가고 있다는 신호일 수 있습니다.

**데이터 중심 설계의 문제점: 지능 없는 객체와 비대한 서비스**

데이터 구조가 먼저 고정되면, 객체는 단순히 데이터를 담는 컨테이너(Getter/Setter만 가진)로 전락하기 쉽습니다. 핵심 비즈니스 로직은 객체 외부의 특정 서비스 클래스(@Service 등)에 집중됩니다. 예를 들어 `PointService`에서 사용자의 포인트를 충전하고 사용하는 로직을 상상해 보세요. `UserPoint` 객체 스스로 처리할 수 있는 충전/사용 로직이 객체 외부의 `PointService`에 구현되어, `UserPoint`는 단순히 데이터 전달 역할만 하게 됩니다. 이는 데이터와 그 데이터를 사용하는 로직이 분리되어 응집도가 낮아지고, 서비스 클래스는 비대해져 변경에 취약한 구조를 만듭니다.

**해결책: 객체에 생명을 불어넣는 '행동'과 '책임'**

이 문제를 해결하려면 어떻게 해야 할까요? **객체에게 스스로 일을 처리할 수 있는 '행동(Behavior)'을 부여하는 것**에서 시작해야 합니다. `@Service`에 있던 비즈니스 로직을 관련 데이터와 가장 밀접한 도메인 객체로 옮기는 것입니다. `PointService`의 충전/사용 로직을 `UserPoint` 객체 안으로 옮기면, `UserPoint`는 더 이상 수동적인 데이터 덩어리가 아니라 스스로 충전하고 사용하는 **'행동'** 을 가진 능동적인 존재가 됩니다.

이 **'행동'** 이 바로 객체가 맡아야 할 **'책임(Responsibility)'** 의 핵심입니다. 책임은 크게 두 가지로 나뉩니다.

1. 하는 것 (Doing):

   객체가 스스로 수행하는 작업

   - 객체 생성, 계산 수행 등.
   - 다른 객체(협력자)의 행동을 시작시키거나 제어/조정하는 것. (예: `UserPoint`의 `charge` 메소드)

2. 아는 것 (Knowing):

   객체가 알아야 하는 정보

   - 캡슐화된 자신의 상태(데이터).
   - 협력하는 다른 관련 객체.
   - 스스로 계산하거나 유도해낼 수 있는 정보.

객체에게 적절한 책임을 부여하는 것이 왜 중요할까요? 책임은 객체가 **스스로를 설명하고(Self-description), 자신의 상태와 행동을 함께 관리하며(높은 응집도), 외부로부터 내부 구현을 숨길 수 있게(캡슐화)** 도와줍니다. 객체가 자신의 책임을 잘 수행하고 있는지 판단하는 기준이 되며, 시스템 전체의 복잡도를 관리하는 데 핵심적인 역할을 합니다.

**'협력': 함께 목표를 달성하는 객체들의 상호작용**

객체는 대부분 혼자 일하지 않습니다. 하나의 기능을 완성하기 위해 여러 객체가 **상호작용**하며 도움을 주고받는데, 이를 **'협력(Collaboration)'** 이라고 합니다. 객체의 '행동'은 바로 이 '협력'의 맥락 속에서 의미를 가집니다. 즉, `UserPoint` 객체의 `charge` 라는 행동(책임)은 외부의 어떤 객체(예: `PaymentService`)가 포인트를 충전해야 하는 '협력' 과정에서 필요하기 때문에 존재하는 것입니다.

여기서 중요한 점은 **"행동(협력에서 필요한)을 먼저 정의하고, 그 행동을 수행하는 데 필요한 데이터는 나중에 결정한다"** 는 것입니다. 만약 데이터를 먼저 고정하면, 다시 데이터에 의존적인 Getter/Setter 위주의 코드로 돌아가기 쉽습니다. 협력의 관점에서 필요한 행동을 먼저 식별하면, 객체는 그 행동을 수행하는 데 꼭 필요한 데이터만 내부적으로 가지거나 외부(다른 협력자)로부터 얻어오도록 설계될 수 있습니다. 협력은 객체가 **외부 세계와 소통하는 방식**을 정의합니다.

**'역할': 유연한 협력을 가능하게 하는 추상화**

지금까지의 설명으로 객체가 책임과 협력을 통해 동작한다는 것을 이해했다면, 이런 질문이 생길 수 있습니다. "모든 것이 구체적인 객체의 책임과 협력으로 이루어진다면, 인터페이스는 왜 필요할까?"

여기서 **'역할(Role)'** 이라는 개념이 등장합니다. 역할은 **협력 속에서 여러 객체들이 상호 교체 가능하게** 만들어주는 **추상적인 책임의 집합**입니다.

예를 들어, 이커머스에서 상품을 구매할 때 할인을 받는다고 생각해 봅시다. '1000원 정액 할인'을 받든, '10% 정률 할인'을 받든, 상품(`Item`) 객체의 입장에서는 **'할인을 적용받는다'** 는 동일한 협력 과정에 참여하는 것입니다. 상품은 구체적인 할인 방식(정액/정률)에 의존할 필요 없이, **'할인(Discount)'** 이라는 **역할**을 수행하는 객체와 협력하면 됩니다.

이때 '할인'이라는 역할은 **인터페이스(`DiscountPolicy`)** 로 정의될 수 있습니다. 그리고 '정액 할인 정책(`FixedAmountDiscountPolicy`)'과 '정률 할인 정책(`PercentageDiscountPolicy`)'은 이 인터페이스를 구현하는 구체적인 객체(Concrete Object)가 됩니다. 상품 객체는 `DiscountPolicy` 인터페이스에만 의존하므로, 어떤 종류의 할인 정책이 오더라도 동일한 방식으로 협력할 수 있습니다. 즉, 역할은 **다형성(Polymorphism)** 을 통해 협력을 더욱 유연하고 확장 가능하게 만들어줍니다.





