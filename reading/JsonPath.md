---
tags:
  - study
  - lang/java
---
### 3. `JsonPath` (JSON 탐색기)

*   **정체**: JSON 구조 안에서 특정 데이터에 쉽게 접근할 수 있도록 도와주는 **경로 표현식(Path Expression)**입니다. XPath가 XML의 데이터를 찾아가는 것처럼, JsonPath는 JSON의 데이터를 찾아갑니다.
*   **역할**: 이 테스트에서는 **컨트롤러가 응답으로 보낸 JSON 데이터의 내용이 올바른지 검증하는 역할**을 합니다.
    *   `getPoint` 테스트의 `.andExpect(jsonPath("$.id").value(userId))` 코드를 보세요.
    *   `MockMvc`가 받은 응답은 `{"id":1, "point":1000, "updateMillis":167...}`와 같은 JSON 문자열입니다.
    *   여기서 `$`는 JSON 문서의 최상위(root)를 의미합니다.
    *   `$.id`는 "최상위 객체의 `id`라는 필드"를 가리키는 주소(경로)입니다. `jsonPath()`는 이 경로에 해당하는 값(이 경우 `1`)을 쏙 뽑아냅니다.
    *   `jsonPath("$[0].type")`은 "최상위 배열(`[]`)의 첫 번째(`0`) 요소에 있는 `type` 필드"를 의미합니다.
*   **왜 쓰는가?**: 응답으로 받은 복잡한 JSON 문자열 전체를 비교하는 대신, 내가 관심 있는 특정 필드의 값만 정확하고 간결하게 검증할 수 있습니다. 덕분에 테스트의 의도가 명확해지고, JSON 필드 순서가 바뀌는 등의 변화에도 깨지지 않는 견고한 테스트를 만들 수 있습니다.


---
JavaScript는 JSON(JavaScript Object Notation)이 이름에서부터 알 수 있듯 **태생적으로 한 식구**이기 때문에 별도의 라이브러리 없이도 `JSON.parse()`와 `JSON.stringify()`만으로 아주 자연스럽게 객체와 JSON 문자열을 다룰 수 있습니다.

반면에 **Java는 정적 타입 언어**이고, 객체 모델이 JavaScript와는 근본적으로 다릅니다. 그래서 Java 객체를 JSON 문자열로 바꾸거나, 그 반대로 바꾸려면 중간에서 '번역' 작업을 해주는 라이브러리가 꼭 필요합니다.

그 '번역가' 역할을 하는 가장 대표적인 라이브러리가 바로 **Jackson**이고, 그 핵심 클래스가 `ObjectMapper`인 것이죠.

조금 번거로워 보일 수 있지만, Java에서는 이런 '번역' 과정 덕분에 다음과 같은 장점을 얻을 수 있습니다.

1.  **타입 안정성**: JSON 문자열을 미리 정의된 Java 객체(DTO)로 변환하면서 데이터의 타입이 올바른지, 필수 필드가 누락되지 않았는지 등을 컴파일 시점과 런타임 초기에 검증할 수 있습니다.
2.  **명확한 데이터 구조**: `@JsonProperty` 어노테이션 등을 사용해 Java 필드 이름과 JSON 키 이름을 다르게 매핑하는 등, 객체 모델과 데이터 전송 모델을 유연하게 관리할 수 있습니다.

결국 언어의 특성과 철학의 차이에서 오는 자연스러운 차이라고 이해하시면 좋습니다. Spring 프레임워크는 이런 번거로운 과정을 내부적으로 자동화(예: 컨트롤러가 알아서 JSON을 객체로 변환)해서 개발자가 최대한 비즈니스 로직에만 집중할 수 있도록 많이 도와주고 있습니다.

---
네, 그 `$.xxx` 형식은 **JsonPath**라는 문법입니다.

한마디로, **JSON 데이터 구조 안에서 원하는 데이터를 쉽게 찾아가기 위한 '주소'나 '경로'를 지정하는 규칙**이라고 생각하시면 됩니다. 웹 페이지의 특정 요소를 찾아갈 때 쓰는 CSS 선택자나, XML 문서에서 데이터를 찾을 때 쓰는 XPath와 아주 비슷한 개념입니다.

### JsonPath 기본 문법

아래와 같은 JSON 응답이 있다고 상상해 보세요.

```json
{
  "store": {
    "book": [
      {
        "category": "reference",
        "author": "Nigel Rees",
        "title": "Sayings of the Century",
        "price": 8.95
      },
      {
        "category": "fiction",
        "author": "Evelyn Waugh",
        "title": "Sword of Honour",
        "price": 12.99
      }
    ],
    "bicycle": {
      "color": "red",
      "price": 19.95
    }
  },
  "expensive": 10
}
```

이 데이터를 JsonPath로 탐색하는 방법은 다음과 같습니다.

*   `$`
    *   **의미**: JSON 문서의 **최상위(Root) 객체**를 의미합니다. 모든 JsonPath 표현식은 항상 `$`로 시작합니다.

*   `.` (Dot notation)
    *   **의미**: 객체의 하위 필드로 이동할 때 사용합니다.
    *   **예시**: `$.store.bicycle.color`
    *   **결과**: `"red"` (store 객체 안의 bicycle 객체 안의 color 필드의 값)

*   `[]` (Bracket notation)
    *   **의미 1**: 배열의 특정 인덱스에 접근할 때 사용합니다. (인덱스는 0부터 시작)
    *   **예시**: `$.store.book[0].title`
    *   **결과**: `"Sayings of the Century"` (book 배열의 첫 번째 요소 객체 안의 title 필드의 값)
    *   **의미 2**: 필드 이름에 특수문자( `-`, ` ` 등)가 포함될 때 사용합니다.
    *   **예시**: 만약 필드 이름이 `first-name` 이라면 `$.['first-name']` 처럼 사용합니다.

*   `*` (Wildcard)
    *   **의미**: 모든 요소(객체의 모든 필드 또는 배열의 모든 아이템)를 의미합니다.
    *   **예시**: `$.store.book[*].author`
    *   **결과**: `["Nigel Rees", "Evelyn Waugh"]` (book 배열에 있는 모든 책의 저자 목록)

*   `..` (Deep scan)
    *   **의미**: 현재 위치와 상관없이 문서 전체에서 특정 필드를 재귀적으로 모두 찾습니다.
    *   **예시**: `$..author`
    *   **결과**: `["Nigel Rees", "Evelyn Waugh"]` (JSON 문서 어디에 있든 `author`라는 이름의 필드를 모두 찾아냄)

### 코드에서의 역할

이전 테스트 코드의 이 부분을 다시 보시죠.

```java
.andExpect(jsonPath("$.id").value(userId))
```

이 코드는 다음과 같이 해석할 수 있습니다.

1.  `jsonPath("$.id")`: "응답으로 받은 JSON 데이터의 최상위(`$`)에 있는 `id`라는 이름의 필드를 찾아라."
2.  `.value(userId)`: "그렇게 찾은 값이 `userId` 변수의 값과 일치하는지 확인해라."

결론적으로 JsonPath는 복잡할 수 있는 JSON 응답 구조에서 내가 검증하고 싶은 데이터만 **정확하고 간결하게 '콕' 집어낼 수 있게 해주는 강력한 도구**입니다. 덕분에 테스트 코드가 훨씬 깔끔해지고, 응답 데이터의 사소한 변경(예: 필드 순서 변경)에도 깨지지 않는 견고한 테스트를 만들 수 있습니다.