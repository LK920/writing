---
tags:
  - study
  - test
  - TDD
---


### 아키텍처 계층별 역할과 테스트 전략

---
### 📍 **계층별 핵심 책임과 테스트 관심사**

| 계층 | 핵심 책임 | 테스트 관심사 |
| :--- | :--- | :--- |
| **Controller** | 외부 세계와의 통역 | "요청/응답 형식이 올바른가? 올바른 담당자에게 전달했는가?" |
| **Service** | 비즈니스 총괄 | "비즈니스 규칙을 모두 지켰는가? 작업 흐름이 올바른가?" |
| **Repository** | 데이터 창고 관리 | "데이터를 정확하고 안전하게 넣고 꺼내는가?" |
| **Domain** | 비즈니스의 주인공 | "객체 자신의 상태와 행동이 올바른가?" |

#### **1. 컨트롤러 계층 (Controller Layer)**

-   **역할 (Role)**
    -   HTTP 요청을 수신하고 응답을 반환하는 API 엔드포인트 역할.
    -   요청 파라미터, `RequestBody` 등에 대한 유효성 검사 (Validation).
    -   서비스 계층으로 비즈니스 로직 처리를 위임하고, 결과를 받아 HTTP 응답으로 변환.

-   **테스트 전략 (Test Strategy)**
    -   **API 명세 준수 여부**를 검증합니다. (e.g., `MockMvc`를 사용한 테스트)
    -   요청/응답 형식 (JSON 직렬화/역직렬화)을 테스트합니다.
    -   유효성 검사(Validation) 로직이 올바르게 동작하는지 확인합니다.
    -   서비스 계층과의 상호작용을 `Mock` 객체를 통해 검증합니다. (e.g., 특정 요청 시 서비스의 특정 메소드가 호출되는가?)

-   **핵심 테스트 관심사**:
    -   요청/응답 데이터의 형식(JSON)이 올바른가?
    -   유효성 검사(@Valid)가 제대로 동작하는가? (e.g., 필수 값이 누락되면 400 에러)
    -   상황에 맞는 HTTP 상태 코드를 반환하는가? (e.g., 성공 시 200/201, 실패 시 400/404)
    -   올바른 서비스 메서드를 호출하는가?

#### 💀 **흔히 저지르는 실수 (Anti-patterns)**

1.  **컨트롤러에서 비즈니스 로직을 테스트하는 것**:
    -   **잘못된 예**: "포인트 충전 요청 시, 유저의 실제 포인트가 증가했는지 검증한다."
    -   **왜 문제인가?**: 포인트 증가는 서비스 계층의 책임입니다. 컨트롤러 테스트는 서비스가 "성공"이라는 결과를 반환했을 때, 컨트롤러가 "200 OK" 응답을 잘 만드는지만 확인해야 합니다.
    -   **올바른 접근**: `PointService`를 가짜(Mock)로 대체하고, "서비스가 '성공'을 반환하면, 컨트롤러는 '200 OK'를 반환하는가?"를 테스트합니다.

2.  **서비스를 Mocking하지 않고 실제 DB까지 호출하는 것**:
    -   **잘못된 예**: 컨트롤러 테스트 하나를 실행했는데 DB 연결부터 모든 계층이 동작하여 테스트가 느려지고, 실패 원인을 파악하기 어렵게 만듭니다.
    -   **왜 문제인가?**: 컨트롤러 테스트의 실패는 '컨트롤러의 잘못'이어야지, '서비스나 DB의 잘못'이어서는 안 됩니다.
    -   **올바른 접근**: 컨트롤러 테스트는 서비스 계층을 경계로 삼아, 외부와의 통신이라는 자신의 책임에만 집중해야 합니다.

---

#### **2. 서비스 계층 (Service Layer)**

-   **역할 (Role)**
    -   **비즈니스 정책** 및 **흐름 제어**를 담당합니다.
    -   서비스는 '왜/무엇을' 해야 하는지를 결정합니다. (e.g., 포인트 충전, 상품 주문)
    -   하나 이상의 리포지토리를 사용하여 비즈니스 로직을 구현하고, 트랜잭션을 관리합니다.

-   **테스트 전략 (Test Strategy)**
    -   **비즈니스 시나리오**와 **정책**을 검증하는 데 집중합니다. (e.g., 단위 테스트)
    -   리포지토리 계층과의 상호작용은 `Mock` 객체를 사용하여 검증합니다.
    -   **예시**:
        -   한 사용자의 중복된 요청 중 1건만 성공적으로 처리되는가?
        -   포인트가 부족할 경우, 상품 주문이 실패하는가?

-   **핵심 테스트 관심사**:
    -   핵심 비즈니스 규칙이 정확히 구현되었는가? (e.g., 보유 포인트보다 많이 사용할 수 없다.)
    -   규칙 위반 시, 정의된 비즈니스 예외(`ErrorCode`)를 던지는가?
    -   작업의 흐름이 올바른가? (e.g., 유저 조회 -> 포인트 차감 -> 이력 저장 순서)

#### 💀 **흔히 저지르는 실수 (Anti-patterns)**

1.  **리포지토리의 내부 구현을 테스트하는 것**:
    -   **잘못된 예**: "포인트 사용 시, `userPointRepository.saveOrUpdate()` 메서드가 정확히 1번 호출되었는지 검증한다."
    -   **왜 문제인가?**: `saveOrUpdate`가 아니라 내부적으로 `update()`와 `insert()`를 따로 호출하도록 리팩토링하면 서비스 로직은 그대로여도 테스트는 실패합니다. 서비스는 "포인트가 변경된다"는 *결과*에만 관심 있어야지, *어떻게* 저장되는지는 리포지토리의 책임입니다.
    -   **올바른 접근**: "포인트 사용 후, 유저의 포인트를 다시 조회했을 때, 기대한 값으로 변경되었는가?"를 검증합니다.

2.  **데이터 자체의 유효성을 검증하는 것**:
    -   **잘못된 예**: 리포지토리에서 가져온 `UserPoint` 객체의 `id`나 `point` 필드가 `null`이 아닌지 검증하는 테스트 코드.
    -   **왜 문제인가?**: 리포지토리는 항상 완전한 형태의 객체를 반환한다고 신뢰해야 합니다. 데이터의 무결성은 리포지토리 테스트에서 이미 검증되었어야 합니다.
    -   **올바른 접근**: 서비스는 리포지토리가 넘겨준 데이터를 믿고 비즈니스 로직 처리에만 집중합니다. (e.g., `userPoint.getPoint() < amountToUse`)

---

#### **3. 리포지토리 계층 (Repository Layer)**

-   **역할 (Role)**
    -   **데이터 영속성**과 **기술적 정확성**을 담당합니다.
    -   서비스의 요구사항을 '어떻게' 데이터베이스(또는 다른 데이터 소스)에 저장하고 조회할지를 책임집니다.
    -   데이터베이스와의 통신 로직을 캡슐화합니다.

-   **테스트 전략 (Test Strategy)**
    -   **CRUD 기능**과 **데이터 안정성**을 검증합니다.
    -   실제 데이터베이스 또는 인메모리 DB (e.g., H2)를 사용하여 테스트합니다.
    -   **예시**:
        -   데이터가 정확하게 생성(Create), 조회(Read), 수정(Update), 삭제(Delete) 되는가?
        -   동시에 여러 요청이 발생했을 때, 데이터 정합성이 깨지지 않는가? (동시성 테스트)

-   **핵심 테스트 관심사**:
    -   CRUD(Create, Read, Update, Delete)가 정확히 동작하는가?
    -   조회 결과가 없을 때, 약속된 형태(e.g., `null`, `Optional.empty()`, 빈 리스트)로 반환하는가?
    -   동시에 여러 요청이 들어와도 데이터의 정합성이 깨지지 않는가? (동시성)

#### 💀 **흔히 저지르는 실수 (Anti-patterns)**

1.  **리포지토리에서 비즈니스 규칙을 검증하는 것**:
    -   **잘못된 예**: `save()` 메서드 내부에 `if (amount <= 0)` 체크를 넣어 `INVALID_AMOUNT` 예외를 던지는 로직을 구현하고, 이를 테스트하는 것.
    -   **왜 문제인가?**: "금액은 0보다 커야 한다"는 비즈니스 정책입니다. 이 정책이 "0도 허용"으로 바뀌면 서비스뿐만 아니라 리포지토리 코드까지 수정해야 합니다. 리포지토리는 어떤 데이터든 충실히 저장소에 전달하는 책임만 져야 합니다.
    -   **올바른 접근**: `amount`가 음수여도 **정확하게 저장되는지**를 검증하는 것이 올바른 리포지토리의 엣지 케이스 테스트입니다. 비즈니스 유효성 검증은 서비스의 몫입니다.

2.  **네이티브 쿼리를 검증하지 않는 것**:
    -   **잘못된 예**: ORM(JPA 등)이 만들어주는 간단한 `findById`, `save` 등만 테스트하고, 복잡한 JPQL이나 네이티브 쿼리로 작성된 메서드는 테스트하지 않는 것.
    -   **왜 문제인가?**: 복잡한 쿼리일수록 오타나 로직 오류가 발생하기 쉽습니다. 리포지토리 테스트의 가장 중요한 목적 중 하나는 SQL 레벨의 오류를 잡아내는 것입니다.
    -   **올바른 접근**: 복잡한 조회 쿼리가 있다면, 다양한 조건으로 데이터를 저장해두고 해당 쿼리가 정확한 결과를 반환하는지 반드시 테스트해야 합니다.
---

#### **4. 도메인/모델 계층 (Domain/Model Layer)**

-   **역할 (Role)**
    -   애플리케이션의 핵심 비즈니스 개념과 데이터를 표현하는 객체입니다. (e.g., `User`, `UserPoint`, `PointHistory`)
    -   객체 자체의 상태와 행위를 가질 수 있습니다.

-   **테스트 전략 (Test Strategy)**
    -   도메인 객체 내에 비즈니스 로직이 포함된 경우, 해당 로직을 직접 테스트합니다.
    -   일반적으로는 다른 계층(주로 서비스)의 테스트를 통해 간접적으로 검증됩니다.
    -   **예시**:
        -   `UserPoint` 객체의 `addPoint(amount)` 메소드가 포인트를 올바르게 증가시키는가? 

-   **핵심 테스트 관심사**:
    -   객체 스스로 상태를 변경하는 내부 로직이 올바르게 동작하는가?
    -   생성자나 팩토리 메서드를 통해 유효한 상태의 객체만 생성되는가?

#### 💀 **흔히 저지르는 실수 (Anti-patterns)**

1.  **도메인 로직을 서비스 계층에 구현하는 것 (Anemic Domain Model)**:
    -   **잘못된 예**: `UserPoint` 객체는 `id`와 `point` 필드만 가지고 있고, 포인트 계산 로직이 모두 `PointService`에 있는 경우.
        ```java
        // In PointService...
        public void someMethod(UserPoint userPoint) {
            long newPoint = userPoint.getPoint() - 100; // 계산 로직이 외부에 있음
            // ...
        }
        ```
    -   **왜 문제인가?**: 객체지향의 장점을 잃게 됩니다. `UserPoint`와 관련된 로직이 여러 서비스에 흩어져 중복 코드를 유발하고, `UserPoint`의 상태를 외부에서 마음대로 변경할 수 있어 객체의 일관성이 깨지기 쉽습니다.
    -   **올바른 접근**: `UserPoint` 객체 내부에 `use(amount)` 라는 메서드를 두어 포인트 계산과 관련된 책임을 스스로 지게 합니다.
        ```java
        // In UserPoint...
        public UserPoint use(long amount) {
            if (this.point < amount) throw new BusinessException(...);
            return new UserPoint(this.id, this.point - amount); // 스스로 계산
        }
        ```
        이 경우, `UserPointTest`에서 `use()` 메서드의 정확성을 직접 테스트할 수 있습니다. 
---
