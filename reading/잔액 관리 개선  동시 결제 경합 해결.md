---
aliases: []
---


## 1. 동시 결제 시 경합 문제
### 1.1. 현재 `balance` 테이블
현재 `balance` 테이블은 사용자별 잔액을 단일 레코드로 관리합니다:
```sql
CREATE TABLE balance (
    user_id BIGINT PRIMARY KEY,
    current_balance DECIMAL(19,2) NOT NULL DEFAULT 0.00,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```
- **구조**: 각 사용자(`user_id`)마다 하나의 레코드가 존재하며, `current_balance`에 현재 잔액을 저장.
- **사용 예**:
  - 사용자 A(`user_id = 1`)의 잔액이 10,000원.
  - 결제 3,000원 시도 → `UPDATE balance SET current_balance = current_balance - 3000 WHERE user_id = 1`.

### 1.2. 문제점: 단일 레코드로 인한 경합
- **동시 결제 시나리오**:
  - 사용자 A가 동시에 두 결제(3,000원, 5,000원)를 시도.
  - 트랜잭션 1: `UPDATE balance SET current_balance = current_balance - 3000 WHERE user_id = 1`.
  - 트랜잭션 2: `UPDATE balance SET current_balance = current_balance - 5000 WHERE user_id = 1`.
- **문제**:
  - **로우 락(Row Lock)**: 데이터베이스는 `user_id = 1` 레코드를 락. 트랜잭션 1이 락을 잡으면 트랜잭션 2는 대기 → **성능 저하**.
  - **데이터 무결성 위험**: 동시 업데이트 시 잔액이 잘못 계산될 수 있음.
    - 예: `current_balance = 10000`에서 두 트랜잭션이 동시에 실행 → 최종 잔액이 7,000원 또는 5,000원으로 잘못 저장 가능.
  - **이력 부족**: 잔액 변경 원인(결제, 환불, 충전 등)을 추적하기 어려움.
  - **데드락 위험**: 복잡한 트랜잭션에서 락 대기 시간이 길어지면 데드락 발생 가능.

## 2. 개선안: `balance_transactions` 테이블 추가
리뷰어가 제안한 개선안은 잔액 변동 이력을 `balance_transactions` 테이블로 관리하는 것입니다:
```sql
CREATE TABLE balance_transactions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT,
    transaction_type VARCHAR(20), -- CHARGE, PAYMENT, REFUND
    amount DECIMAL(19,2),
    balance_after DECIMAL(19,2),
    reference_id VARCHAR(100), -- order_id, payment_id 등
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```
- **목적**:
  - 잔액 변동(충전, 결제, 환불 등)을 별도 테이블에 기록.
  - 잔액 조회는 `balance_transactions`의 `amount`를 합산하거나, `balance` 테이블을 주기적으로 업데이트.
- **구현 방식**:
  - 잔액 변경 시 `balance` 테이블을 업데이트하지 않고, `balance_transactions`에 삽입(Insert).
  - 필요 시 `balance` 테이블의 `current_balance`를 주기적으로 갱신(예: 배치 작업).

## 3. 개선안의 이점
`balance_transactions` 테이블을 추가하면 다음과 같은 이점이 있습니다:

### 3.1. 경합 감소
- **현재 문제**: `balance` 테이블의 단일 레코드(`user_id`)를 여러 트랜잭션이 동시에 업데이트 → 로우 락으로 대기 시간 증가.
- **개선 효과**:
  - `balance_transactions`는 **쓰기 전용(Insert Only)** 테이블. 삽입 연산은 락이 필요 없거나 최소화됨.
  - 예: 결제 3,000원 → `INSERT INTO balance_transactions (user_id, transaction_type, amount, balance_after, reference_id) VALUES (1, 'PAYMENT', -3000, 7000, 'order_123')`.
  - 동시 삽입은 레코드 간 충돌 없음 → 경합 최소화.
- **결과**: 동시 결제 요청이 많아도 성능 병목 감소.

### 3.2. 데이터 무결성 향상
- **현재 문제**: 동시 업데이트로 `current_balance`가 잘못 계산될 위험.
- **개선 효과**:
  - `balance_transactions`에 각 변동을 독립적으로 기록 → 최종 잔액은 `SUM(amount)`로 계산.
    ```sql
    SELECT SUM(amount) AS current_balance
    FROM balance_transactions
    WHERE user_id = 1;
    ```
  - 트랜잭션 충돌로 인한 데이터 손실 위험 감소.
- **낙관적 락 대안**: `balance` 테이블을 유지할 경우, 낙관적 락(`version` 컬럼) 추가 가능:
  ```sql
  ALTER TABLE balance ADD version BIGINT NOT NULL DEFAULT 0;
  ```

### 3.3. 감사 로그(Audit Log) 제공
- **현재 문제**: `balance` 테이블은 변경 이력을 기록하지 않아, 잔액 변동 원인(결제, 환불 등) 추적 어려움.
- **개선 효과**:
  - `balance_transactions`는 `transaction_type`(예: `CHARGE`, `PAYMENT`, `REFUND`)과 `reference_id`(예: `order_id`, `payment_id`)로 상세 이력 제공.
  - 예: 잔액이 10,000원에서 7,000원으로 줄었을 때, `balance_transactions` 조회로 원인 확인:
    ```sql
    SELECT * FROM balance_transactions WHERE user_id = 1;
    -- 결과: PAYMENT, -3000, balance_after=7000, reference_id='order_123'
    ```
  - 디버깅, 고객 문의 대응, 감사(Audit)에 유용.

### 3.4. 유연한 잔액 계산
- **현재 문제**: `current_balance`는 단일 값으로, 변동 내역을 반영하려면 직접 업데이트 필요.
- **개선 효과**:
  - `balance_transactions`의 `amount` 합산으로 잔액 계산 가능.
  - `balance` 테이블을 유지하더라도, 주기적 배치 작업으로 `current_balance` 갱신:
    ```sql
    UPDATE balance b
    SET current_balance = (
        SELECT SUM(amount)
        FROM balance_transactions bt
        WHERE bt.user_id = b.user_id
    );
    ```
  - 필요 시 `balance_after` 컬럼으로 최신 잔액 빠르게 조회.

## 4. 구현 예시
### 4.1. 현재 코드 (문제 발생)
```java
@Service
public class BalanceService {
    @Autowired
    private BalanceRepository balanceRepository;

    @Transactional
    public void processPayment(Long userId, BigDecimal amount, String orderId) {
        Balance balance = balanceRepository.findByUserId(userId)
            .orElseThrow(() -> new RuntimeException("Balance not found"));
        // 전체 레코드 락
        if (balance.getCurrentBalance().compareTo(amount) < 0) {
            throw new InsufficientBalanceException("잔액 부족");
        }
        balance.setCurrentBalance(balance.getCurrentBalance().subtract(amount));
        balanceRepository.save(balance);
        // 이력 기록 없음
    }
}
```
- **문제**:
  - 동시 결제 시 `balance(user_id=1)` 레코드에 로우 락 → 경합 발생.
  - 이력 기록 없어 잔액 변동 원인 추적 불가.

### 4.2. 개선 코드
```java
@Service
public class BalanceService {
    @Autowired
    private BalanceTransactionRepository balanceTransactionRepository;

    @Transactional
    public void processPayment(Long userId, BigDecimal amount, String orderId) {
        // 잔액 확인 (SUM으로 계산 또는 balance 테이블 사용)
        BigDecimal currentBalance = balanceTransactionRepository.sumBalanceByUserId(userId);
        if (currentBalance.compareTo(amount) < 0) {
            throw new InsufficientBalanceException("잔액 부족");
        }

        // balance_transactions에 삽입
        BalanceTransaction transaction = new BalanceTransaction();
        transaction.setUserId(userId);
        transaction.setTransactionType("PAYMENT");
        transaction.setAmount(amount.negate()); // 결제는 음수
        transaction.setBalanceAfter(currentBalance.subtract(amount));
        transaction.setReferenceId(orderId);
        balanceTransactionRepository.save(transaction);
    }
}

@Repository
public interface BalanceTransactionRepository extends JpaRepository<BalanceTransaction, Long> {
    @Query("SELECT COALESCE(SUM(bt.amount), 0) FROM BalanceTransaction bt WHERE bt.userId = :userId")
    BigDecimal sumBalanceByUserId(@Param("userId") Long userId);
}
```
- **설명**:
  - `balance_transactions`에 결제 기록 삽입 → 락 필요 없음.
  - 잔액은 `SUM(amount)`로 계산 또는 `balance_after`로 빠르게 조회.
  - `balance` 테이블 유지 시, 배치 작업으로 갱신:
    ```java
    @Scheduled(cron = "0 0 * * * *") // 매시 정각
    public void updateBalanceTable() {
        balanceRepository.updateAllBalancesFromTransactions();
    }
    ```

## 5. 데이터 마이그레이션
기존 `balance` 테이블 데이터를 `balance_transactions`로 이동:
```sql
INSERT INTO balance_transactions (user_id, transaction_type, amount, balance_after, reference_id, created_at)
SELECT user_id, 'INITIAL', current_balance, current_balance, 'initial_balance', updated_at
FROM balance;
```
- **참고**: `balance` 테이블을 유지할지 제거할지는 스펙에 따라 결정. 유지 시 배치로 갱신.

## 6. 주의사항
- **성능 최적화**:
  - `SUM(amount)` 조회가 느릴 경우, `balance` 테이블 유지 또는 `balance_after` 활용.
  - 인덱스 추가: `CREATE INDEX idx_user_id ON balance_transactions(user_id);`.
- **이력 일관성**: 모든 잔액 변경(충전, 결제, 환불)을 `balance_transactions`에 기록.
- **배치 작업**: `balance` 테이블 갱신 시 트랜잭션 충돌 주의.
- **데이터 정합성**: `balance_after`와 `SUM(amount)`가 일치하는지 주기적 검증.

## 7. 결론
`balance` 테이블의 단일 레코드 업데이트는 동시 결제 시 로우 락으로 경합을 유발합니다. `balance_transactions` 테이블을 추가하면 쓰기 전용 삽입으로 경합을 줄이고, 잔액 변동 이력을 기록해 추적성과 디버깅을 개선합니다. 잔액은 `SUM(amount)`로 계산하거나, 주기적 배치로 `balance` 테이블을 갱신하면 됩니다. 이 개선안은 동시성 성능을 높이고, 데이터 무결성과 투명성을 강화합니다.