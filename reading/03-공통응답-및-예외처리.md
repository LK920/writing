# 공통 응답 처리 및 예외 처리 가이드

## 📋 목차
1. CommonResponse 설계 진화
2. 응답 처리 아키텍처
3. 전역 예외 처리
4. HTTP 상태 코드 전략
5. 실제 구현 예시

---

## CommonResponse 설계 진화

### 🔄 설계 변천사

#### 1단계: 이중 래핑 구조 (초기)
```java
// ❌ 문제가 있던 초기 구조
public ResponseEntity<CommonResponse<T>> someMethod() {
    return ResponseEntity.ok(CommonResponse.success(data));
}

// 결과: ResponseEntity(CommonResponse(data)) - 이중 래핑
```

#### 2단계: CommonResponse 통합 구조
```java
// ❌ 여전히 복잡한 구조
@RestControllerAdvice
public class CommonResponse<T> implements ResponseBodyAdvice<Object> {
    // 응답 래핑 + 예외 처리를 모두 담당
}
```

#### 3단계: 역할 분리 구조 (최종) ✅
```java
// ✅ 각각의 책임을 명확히 분리
1. CommonResponse.java        - 응답 데이터 구조
2. SuccessResponseAdvice.java - 성공 응답 래핑
3. GlobalExceptionHandler.java - 예외 처리
```

### 📊 최종 CommonResponse 구조
```java
/**
 * API 응답의 표준화된 래퍼 클래스
 * 
 * 응답 형태:
 * {
 *   "success": true/false,
 *   "message": "성공/실패 메시지",
 *   "data": 실제 응답 데이터 (성공 시에만),
 *   "timestamp": "2024-01-01T12:00:00"
 * }
 */
public class CommonResponse<T> {
    private boolean success;      // 요청 성공 여부
    private String message;       // 응답 메시지
    private T data;              // 실제 응답 데이터
    private LocalDateTime timestamp; // 응답 생성 시간

    // 정적 팩토리 메서드
    public static <T> CommonResponse<T> success(T data) { ... }
    public static CommonResponse<Void> success() { ... }
    public static <T> CommonResponse<T> failure(String message) { ... }
}
```

---

## 응답 처리 아키텍처

### 🏗️ 3계층 분리 아키텍처

#### 1. CommonResponse (데이터 구조)
- **역할**: 응답 데이터 구조 정의
- **책임**: 성공/실패 응답 모델 제공
- **위치**: 순수한 데이터 클래스

#### 2. SuccessResponseAdvice (성공 응답 처리)
```java
/**
 * 성공 응답 자동 래핑 클래스
 * 
 * 동작 과정:
 * 1. 컨트롤러에서 UserDto 반환
 * 2. SuccessResponseAdvice가 개입
 * 3. CommonResponse.success(UserDto)로 래핑
 * 4. 클라이언트는 표준화된 응답 받음
 */
@RestControllerAdvice(basePackages = "kr.hhplus.be.server.api.controller")
public class SuccessResponseAdvice implements ResponseBodyAdvice<Object> {

    @Override
    public boolean supports(MethodParameter returnType, Class converterType) {
        // ResponseEntity를 반환하는 예외 처리 핸들러는 제외
        return !returnType.getParameterType().equals(ResponseEntity.class);
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, ...) {
        if (returnType.getParameterType() == void.class) {
            return CommonResponse.success(); // void 메서드용
        }
        return CommonResponse.success(body); // 데이터 있는 경우
    }
}
```

#### 3. GlobalExceptionHandler (예외 처리)
```java
/**
 * 전역 예외 처리 클래스
 * 
 * 처리 과정:
 * 1. 컨트롤러에서 예외 발생
 * 2. GlobalExceptionHandler가 캐치
 * 3. 예외 타입에 따른 HTTP 상태 코드 결정
 * 4. CommonResponse.failure()로 표준화된 오류 응답 생성
 */
@RestControllerAdvice(basePackages = "kr.hhplus.be.server.api.controller")
public class GlobalExceptionHandler {
    // 예외별 처리 로직
}
```

### 🔄 전체 플로우
```
Controller 메서드 실행
         ↓
    성공 시: SuccessResponseAdvice → CommonResponse.success()
         ↓
    예외 시: GlobalExceptionHandler → CommonResponse.failure()
         ↓
    클라이언트에게 표준화된 응답 전달
```

---

## 전역 예외 처리

### 🎯 예외 처리 전략

#### 1. 비즈니스 예외 처리
```java
@ExceptionHandler({
    BalanceException.class, 
    CouponException.class, 
    OrderException.class, 
    PaymentException.class, 
    ProductException.class
})
public ResponseEntity<CommonResponse<Object>> handleBusinessException(RuntimeException ex) {
    HttpStatus status = getStatusFromException(ex);
    return ResponseEntity.status(status).body(CommonResponse.failure(ex.getMessage()));
}
```

#### 2. 입력값 검증 실패 처리
```java
@ExceptionHandler(MethodArgumentNotValidException.class)
public ResponseEntity<CommonResponse<Object>> handleValidationExceptions(
    MethodArgumentNotValidException ex) {
    
    String errorMessage = ex.getBindingResult()
        .getAllErrors()
        .get(0)
        .getDefaultMessage();
    
    return ResponseEntity
        .status(HttpStatus.BAD_REQUEST)
        .body(CommonResponse.failure(errorMessage));
}
```

#### 3. 예상치 못한 예외 처리 (최후의 보루)
```java
@ExceptionHandler(Exception.class)
public ResponseEntity<CommonResponse<Object>> handleAllUncaughtException(Exception ex) {
    return ResponseEntity
        .status(HttpStatus.INTERNAL_SERVER_ERROR)
        .body(CommonResponse.failure("알 수 없는 오류가 발생했습니다."));
}
```

### 🏷️ 도메인별 예외 클래스 설계
```java
public class BalanceException extends RuntimeException {
    public static class Insufficient extends BalanceException {
        public Insufficient() { super("잔액이 부족합니다."); }
    }
    
    public static class ConcurrencyConflict extends BalanceException {
        public ConcurrencyConflict() { super("잔액 처리 중 충돌이 발생했습니다."); }
    }
}

public class ProductException extends RuntimeException {
    public static class NotFound extends ProductException {
        public NotFound() { super("상품을 찾을 수 없습니다."); }
    }
    
    public static class OutOfStock extends ProductException {
        public OutOfStock() { super("상품 재고가 부족합니다."); }
    }
}
```

---

## HTTP 상태 코드 전략

### 📊 상태 코드 매핑 전략
```java
private HttpStatus getStatusFromException(RuntimeException ex) {
    // 잔액 부족 관련 → 402 Payment Required
    if (ex instanceof BalanceException.Insufficient || 
        ex instanceof PaymentException.InsufficientBalance) 
        return HttpStatus.PAYMENT_REQUIRED;
    
    // 쿠폰 만료/소진 → 410 Gone (더 이상 사용할 수 없음)
    if (ex instanceof CouponException.Expired || 
        ex instanceof CouponException.OutOfStock) 
        return HttpStatus.GONE;
    
    // 권한 없음 → 403 Forbidden
    if (ex instanceof OrderException.Unauthorized) 
        return HttpStatus.FORBIDDEN;
    
    // 리소스 없음 → 404 Not Found
    if (ex instanceof ProductException.NotFound || 
        ex instanceof OrderException.NotFound) 
        return HttpStatus.NOT_FOUND;
    
    // 동시성 충돌, 재고 부족 → 409 Conflict
    if (ex instanceof BalanceException.ConcurrencyConflict || 
        ex instanceof ProductException.OutOfStock) 
        return HttpStatus.CONFLICT;
    
    // 기타 모든 경우 → 400 Bad Request
    return HttpStatus.BAD_REQUEST;
}
```

### 📋 상태 코드 의미
| 상태 코드 | 의미 | 사용 예시 |
|-----------|------|-----------|
| 200 OK | 성공 | 일반적인 성공 응답 |
| 201 Created | 생성 성공 | 주문 생성, 쿠폰 발급 |
| 400 Bad Request | 잘못된 요청 | 기본 예외 |
| 402 Payment Required | 결제 필요 | 잔액 부족 |
| 403 Forbidden | 권한 없음 | 주문 권한 없음 |
| 404 Not Found | 리소스 없음 | 상품/주문 없음 |
| 409 Conflict | 리소스 충돌 | 동시성 충돌, 재고 부족 |
| 410 Gone | 더 이상 없음 | 쿠폰 만료/소진 |
| 500 Internal Server Error | 서버 오류 | 예상치 못한 오류 |

---

## 실제 구현 예시

### 📝 성공 응답 예시
```json
# GET /api/balance/1 (성공)
{
  "success": true,
  "message": "요청이 성공했습니다",
  "data": {
    "userId": 1,
    "amount": 50000,
    "updatedAt": "2024-01-01T12:00:00"
  },
  "timestamp": "2024-01-01T12:00:00"
}

# POST /api/balance/charge (성공, void)
{
  "success": true,
  "message": "요청이 성공했습니다",
  "data": null,
  "timestamp": "2024-01-01T12:00:00"
}
```

### 📝 실패 응답 예시
```json
# 잔액 부족 (402 Payment Required)
{
  "success": false,
  "message": "잔액이 부족합니다",
  "data": null,
  "timestamp": "2024-01-01T12:00:00"
}

# 상품 없음 (404 Not Found)
{
  "success": false,
  "message": "상품을 찾을 수 없습니다",
  "data": null,
  "timestamp": "2024-01-01T12:00:00"
}

# 입력값 검증 실패 (400 Bad Request)
{
  "success": false,
  "message": "사용자 ID는 필수입니다",
  "data": null,
  "timestamp": "2024-01-01T12:00:00"
}
```

---

## 📚 핵심 학습 포인트

### 1. 아키텍처 장점
- **관심사 분리**: 각 클래스가 하나의 책임만 담당
- **재사용성**: CommonResponse를 여러 곳에서 활용
- **일관성**: 모든 API가 동일한 응답 형식
- **유지보수성**: 응답 형식 변경 시 한 곳만 수정

### 2. 설계 원칙
- **단일 책임 원칙**: 각 클래스는 하나의 역할만
- **개방-폐쇄 원칙**: 새로운 예외 추가 시 기존 코드 변경 없이 확장
- **의존성 역전**: 인터페이스(ResponseBodyAdvice)에 의존

### 3. 실무 적용 팁
- **예외 메시지**: 사용자 친화적인 한국어 메시지
- **로깅**: 실제 예외 정보는 서버 로그에만 기록
- **상태 코드**: 비즈니스 의미에 맞는 HTTP 상태 코드 사용
- **응답 시간**: timestamp로 디버깅 및 모니터링 지원 