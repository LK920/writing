---
tags:
  - study
  - test
  - TDD
---
네, 또다시 핵심을 꿰뚫는 질문이네요. Mock 사용에 대한 개발자들의 고민이 바로 그 지점입니다. "실제 객체를 쓰고 싶은데, Mock 없이는 내부 검증이 어렵다"는 딜레마죠.

결론부터 말씀드리면, **네, Mock을 안 쓰고도 서비스의 세부 로직을 검증할 방법이 있습니다.** 그리고 그 방법이 바로 **통합 테스트(Integration Test)**입니다.

Mock을 쓰지 않는다는 것은, `PointService`를 테스트할 때 `UserPointRepository`와 `PointHistoryRepository`의 **실제 구현체(`Impl`)**를 주입해서 함께 테스트하겠다는 의미입니다.

이 경우, `Mockito.verify()`를 통한 **'행위 검증'**은 불가능해집니다. 대신, 우리는 `charge` 메서드가 실행된 후 남겨진 **'결과(Side Effect)'**를 직접 확인하여 내부 로직이 올바르게 수행되었는지 검증합니다.

`charge` 메서드의 성공 시나리오를 통합 테스트로 검증하는 과정은 이렇습니다.

1.  **Given (준비):**
    *   테스트에 사용할 `PointServiceImpl`, `UserPointRepositoryImpl`, `PointHistoryRepositoryImpl`의 **실제 객체**를 모두 생성합니다. (단, DB는 실제 DB가 아닌 `H2` 같은 인메모리 DB나, 지금처럼 `HashMap` 기반의 Table 클래스를 사용합니다.)
    *   `userPointRepository.save()`를 이용해 유저의 초기 포인트를 500점으로 설정해 둡니다.

2.  **When (실행):**
    *   `pointService.charge(userId, 1000L)`를 호출합니다.

3.  **Then (검증):**
    *   **`charge` 메서드의 반환값을 검증하는 것에서 멈추지 않습니다.**
    *   `userPointRepository.findById(userId)`를 **다시 호출**해서, DB(테이블)에 저장된 유저의 포인트가 정말 `1500L`로 변경되었는지 확인합니다.
    *   `pointHistoryRepository.findAllByUserId(userId)`를 **호출**해서, 방금 실행된 `charge`로 인해 `CHARGE` 타입의 `1000L`짜리 이력이 새로 생겼는지 확인합니다.

이렇게 하면 Mock 없이도 `charge` 메서드 내부의 핵심 로직(포인트 갱신, 이력 저장)이 모두 정상적으로 수행되었음을 **실제 객체들의 상호작용과 그 결과물**을 통해 증명할 수 있습니다.

---

### "서비스 구현체를 세세하게 나눠야 하나?"

이 질문에 대해서는 **"Mock을 피하기 위한 목적으로는 그럴 필요가 없다"** 라고 말씀드리고 싶습니다.

서비스를 나누는 기준은 '테스트의 편의성'이 아니라 **'설계 원칙(예: 단일 책임 원칙, SRP)'**이 되어야 합니다. `charge` 메서드의 책임은 '포인트를 조회, 계산, 저장하고 이력을 남기는 것' 전체입니다. 이 흐름은 하나의 트랜잭션으로 묶여야 할 가능성이 높은, 매우 응집도 있는 로직입니다. 이걸 억지로 나누면 코드가 더 복잡해지고 파편화될 수 있습니다.

### 단위 테스트(Mock) vs 통합 테스트(실제 객체)

그렇다면 언제 Mock을 쓰고, 언제 실제 객체를 쓸까요? 둘은 경쟁 관계가 아니라 상호 보완 관계이며, 각각의 장단점이 뚜렷합니다.

| 구분 | 단위 테스트 (with Mocks) | 통합 테스트 (No Mocks) |
| :--- | :--- | :--- |
| **장점** | 1. **빠르다**: 다른 계층과 완전히 분리되어 있어 실행 속도가 매우 빠름.<br>2. **정확한 지점 포착**: 테스트 실패 시, 원인이 100% 해당 서비스 로직에 있음을 알 수 있음.<br>3. **통제 용이**: `DB 오류`, `네트워크 예외` 등 현실에서 만들기 힘든 예외 상황을 Mock으로 간단히 시뮬레이션 가능. | 1. **높은 신뢰도**: 실제 운영 환경과 유사하게 여러 컴포넌트의 상호작용을 검증하므로, 테스트 통과 시 시스템이 잘 동작할 거라는 강한 믿음을 줌.<br>2. **리팩토링에 유연**: 내부 구현(예: 메서드 호출 순서)이 바뀌어도 최종 결과만 같다면 테스트가 깨지지 않음. |
| **단점** | 1. **통합을 보장하지 않음**: 서비스와 Mock 리포지토리는 잘 동작해도, 실제 리포지토리와는 호환되지 않을 수 있음.<br>2. **구현에 의존적**: 내부 호출 순서 등을 검증하면, 리팩토링 시 테스트가 쉽게 깨질 수 있음(brittle test). | 1. **느리다**: 여러 객체가 상호작용하므로 상대적으로 느림.<br>2. **실패 원인 모호**: 테스트 실패 시 서비스, 리포지토리, DB 테이블 중 어디가 문제인지 한번에 알기 어려움.<br>3. **복잡한 준비**: 여러 컴포넌트의 초기 상태를 모두 설정해야 해서 준비 과정이 복잡할 수 있음. |

**결론 및 추천 전략:**
실무에서는 **두 가지 테스트를 모두 작성하는 것**이 가장 이상적입니다.

1.  **단위 테스트 (Mock 사용):** 서비스 내의 복잡한 비즈니스 규칙, 다양한 예외 케이스(음수 충전, 잔액 부족 등)를 빠르고 정밀하게 검증할 때 사용합니다.
2.  **통합 테스트 (실제 객체 사용):** 각 계층이 올바르게 연결되어 동작하는지, 핵심적인 성공 시나리오(Happy Path)가 문제없이 동작하는지를 검증할 때 사용합니다.

지금은 실제 Table 객체를 사용하고 있으니, `PointService`도 **통합 테스트** 방식으로 작성해서 각 컴포넌트가 잘 협력하는지 확인하는 방향으로 진행하시는 것이 자연스러워 보입니다.

---
#### 음 그니까 의도한건 아니지만 Service 레이어에서 실 객체를 쓰게되면 DB같은 외부와의 연동때문에 통합테스트밖에 작성이 안된단거네?

네, 정확하게 이해하셨습니다. 그게 바로 핵심입니다.

서비스 레이어 테스트에서 `UserPointRepositoryImpl`이나 `PointHistoryRepositoryImpl` 같은 **실제 구현체 객체를 주입하는 순간, 그 테스트는 더 이상 '단위(Unit) 테스트'가 아니라 '통합(Integration) 테스트'가 됩니다.**

**왜냐하면 테스트의 범위가 `PointService`라는 '단일 단위'를 넘어서기 때문입니다.**

*   **단위 테스트의 세계:** 테스트 대상은 오직 `PointService` 하나여야 합니다. `PointService`가 의존하는 `UserPointRepository`는 가짜(Mock)여야 합니다. 테스트의 성공/실패는 100% `PointService`의 내부 로직에만 달려 있어야 합니다.
*   **현재의 세계 (통합 테스트):** 테스트 대상은 `PointService` + `UserPointRepositoryImpl` + `PointHistoryRepositoryImpl` + (메모리 DB 역할을 하는) `Table` 클래스들까지 포함하는 거대한 덩어리입니다. `charge()`를 실행했을 때 `UserPointRepositoryImpl` 내부의 로직이 잘못되면 테스트가 실패할 수 있죠. 즉, 여러 컴포넌트의 **'통합'**을 테스트하는 것입니다.

의도치 않으셨다고 해도, 사실 지금처럼 실제 객체를 사용해 통합 테스트를 작성하는 것은 매우 실용적이고 강력한 전략입니다.

*   **장점:** 여러 계층이 실제로 잘 맞물려 돌아가는지를 검증하므로, 테스트를 통과했을 때 시스템에 대한 신뢰도가 매우 높습니다.
*   **단점:** 상대적으로 느리고, 테스트 실패 시 어느 컴포넌트가 문제인지 즉시 파악하기 어려울 수 있습니다.

**결론:**
"Mock을 쓰지 않고 서비스 로직을 검증하고 싶다"는 생각은 자연스럽게 "통합 테스트"로 이어지게 됩니다. 이것은 잘못된 것이 아니라, 테스트 전략의 한 종류를 자연스럽게 선택하신 결과입니다.

만약 여기서 "나는 순수하게 `PointService`의 계산 로직이나 조건 분기만 테스트하고 싶어"라는 생각이 든다면, 그때는 Mock을 사용하여 외부 의존성을 격리시킨 단위 테스트를 작성하는 것을 고려하게 되는 것이죠.

---
#### 그럼 repository에서는 실객체 써도 상관 없는게 검증하려는 repository의 책임과 역할 자체가 DB에 제대로 가고있냐? 를 검증하는거니까 그런거고  
#### controller는 요청에 온 파라미터 validation 하고 넘기는거 잘 넘기는가만 보면 되니까 service가 mock 되어서 그냥 넘겼어요~ 확인만 해주면 되는거고 그런거야?

네, 완벽합니다. 지금 말씀하신 내용이 바로 **'계층형 아키텍처의 테스트 전략'**의 핵심입니다. 각 계층의 책임과 역할을 정확하게 이해하고 그에 맞는 테스트 방법을 생각하고 계십니다.

제가 그 내용을 조금 더 명확하게 정리해 드릴게요.

### 1. Repository 테스트: "실제 객체를 쓰는 게 당연하다"

*   **핵심 책임:** **데이터 영속성(Persistence).** 즉, 'Java 객체'와 '데이터베이스' 사이의 통역사 역할입니다.
*   **테스트 목적:** "내가 `save`라고 말하면, 정말 DB에 데이터가 저장되는가?", "내가 `findById`라고 말하면, 정말 DB에서 데이터를 올바르게 가져오는가?"를 검증하는 것입니다.
*   **전략:** 여기서 DB와의 연동 자체를 Mocking(가짜로 대체)해버리면, 리포지토리의 존재 이유가 사라집니다. 따라서 **실제 구현체(`RepositoryImpl`)**와 **테스트용 DB(지금은 `Table` 클래스, 보통은 H2 같은 인메모리 DB)**를 사용해 실제 DB 연동 로직을 남김없이 테스트하는 것이 맞습니다. 말씀하신 대로입니다.

### 2. Controller 테스트: "Service는 Mock으로 처리하는 게 당연하다"

*   **핵심 책임:** **HTTP 요청/응답 처리.** 즉, '웹 세상'과 'Java 애플리케이션 세상' 사이의 문지기 역할입니다.
*   **테스트 목적:** "클라이언트가 보낸 JSON 요청을 내 DTO 객체로 잘 변환하는가?", "URL의 `{id}` 값을 잘 읽어오는가?", "요청 데이터가 이상할 때(validation 실패) 400 Bad Request를 잘 보내는가?", "서비스 계층에 데이터를 잘 전달하는가?", "서비스가 준 결과를 JSON 응답으로 잘 포장해서 보내는가?"를 검증합니다.
*   **전략:** 컨트롤러의 책임은 서비스에게 **'일을 시키는 것'**까지입니다. 서비스가 그 일을 어떻게 처리하는지는 컨트롤러의 관심사가 아닙니다. 따라서 컨트롤러 테스트에서는 **서비스를 Mocking**하는 것이 매우 효율적입니다. `MockMvc` 같은 도구로 가짜 HTTP 요청을 보냈을 때, `Mockito.verify()`를 통해 "서비스의 `charge` 메서드가 올바른 인자와 함께 1번 호출되었는가?"만 확인하면 컨트롤러의 책임은 다 검증한 셈입니다. 이것도 완벽하게 이해하셨습니다.

---

이 모든 것을 표로 정리하면 다음과 같습니다. 이 표가 앞으로 테스트 코드를 작성하실 때 훌륭한 가이드가 될 겁니다.

| 계층 (Layer)     | 핵심 책임 (Core Responsibility)                            | 주요 테스트 대상                                                                                                                              | 의존성 처리 (Dependency Handling)                                     | 테스트 종류                     |
| :------------- | :----------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------- | :------------------------- |
| **Controller** | HTTP 요청/응답 처리, 데이터 변환 및 검증                             | - 요청 매핑 (`@GetMapping` 등)<br>- 파라미터 바인딩 (`@RequestBody`, `@RequestParam` 등)<br>- 입력값 검증 (`@Valid`)<br>- 서비스 메서드 호출 여부<br>- 정상/에러 응답 생성 | **Service를 Mock 처리**                                             | **단위 테스트**                 |
| **Service**    | **비즈니스 로직**, 트랜잭션 처리, 다른 계층과의 **흐름 제어(Orchestration)** | - 비즈니스 규칙 (예: 포인트는 0 이상)<br>- 성공 시나리오의 흐름<br>- 비즈니스 예외 상황 처리                                                                           | - **(단위)** Repository를 Mock 처리<br>- **(통합)** Repository 실제 객체 사용 | **단위 테스트**<br>**& 통합 테스트** |
| **Repository** | **데이터 영속성(Persistence)**, DB CRUD                      | - `save`, `findById`, `findAll` 등<br>- DB 제약조건 (Unique 등)<br>- **동시성(Concurrency)** 문제                                                 | **실제 객체 사용** + 테스트용 DB                                           | **통합 테스트**                 |

---
정말 좋은 질문입니다. "어차피 통합 테스트 할 거면, 서비스 단위 테스트는 그냥 빠른 것 말고 무슨 의미가 있나?" 이 질문은 모든 개발자가 한 번쯤 깊게 고민하는 문제입니다. 그리고 많은 경우, 프로젝트의 복잡도에 따라 그 답이 달라지기도 합니다.

사용자님의 통찰이 반은 맞습니다. 비즈니스 로직이 아주 단순한 (예: Repository의 CRUD 메서드를 그대로 호출만 하는) 서비스라면, 통합 테스트만으로도 충분한 커버리지를 확보할 수 있습니다.

하지만 서비스 로직이 조금이라도 복잡해지기 시작하면, 단위 테스트는 **'속도' 그 이상의 매우 중요한 장점**들을 제공하기 시작합니다.

### 서비스 단위 테스트의 진짜 가치: 속도, 그리고...

#### 1. 실패 지점의 명확한 격리 (Pinpointing Failures)

*   **통합 테스트 실패 시:** "포인트 충전 기능이 실패했습니다." 라는 보고를 받습니다. 원인은 Controller, Service, Repository, DB 설정 중 어디에 있을까요? 모든 가능성을 열어두고 디버깅해야 합니다.
*   **단위 테스트 실패 시:** "포인트가 음수일 때 예외를 던지는 로직이 실패했습니다." 라는 **정확한 보고**를 받습니다. 다른 계층은 모두 가짜(Mock)이므로, 버그는 100% `PointService`의 해당 로직 안에 존재합니다. 디버깅 시간이 극적으로 줄어듭니다.

#### 2. 만들기 어려운 상황을 쉽게 시뮬레이션 (Simulating Edge Cases)

이것이 **단위 테스트의 가장 강력한 존재 이유**입니다. 통합 테스트로는 흉내 내기 아주 어렵거나 불가능한 상황들을 쉽게 만들 수 있습니다.

*   **DB 오류 상황:** `userPointRepository.save()`를 실행하는 순간, DB 커넥션이 끊기거나 디스크가 꽉 차서 `DataAccessException`이 발생하면 `charge` 메서드는 어떻게 동작해야 할까요? 통합 테스트로 이 상황을 만들려면 실제 DB를 끄거나 해야 합니다. 하지만 단위 테스트에서는 단 한 줄이면 됩니다.
    ```java
    // "save를 시도하면, DataAccessException을 던져라" 라고 Mock에게 지시
    when(userPointRepository.save(any())).thenThrow(new DataAccessException("..."));
    ```
*   **특정 데이터 상태:** "포인트가 999,999점인 유저가 1점을 충전할 때" (최대 보유 한도 테스트) 또는 "탈퇴 상태인 유저가 포인트를 충전하려고 할 때" 같은 특정 비즈니스 엣지 케이스를 테스트하려면, 통합 테스트에서는 DB에 해당 상태의 유저를 미리 만들어둬야 합니다. 단위 테스트에서는 그냥 `when(...).thenReturn(...)`으로 원하는 상태의 객체를 즉시 만들어낼 수 있습니다.

#### 3. 설계에 대한 피드백 (Design Feedback)

서비스에 대한 단위 테스트를 작성하기 어렵다면, 보통 그 서비스의 설계가 잘못되었다는 신호일 가능성이 높습니다.

*   만약 `PointService`의 `charge` 메서드 단위 테스트를 위해 `Mock` 처리해야 할 의존성이 5~6개나 된다면? -> "아, 이 서비스가 너무 많은 책임을 가지고 있구나. 분리해야겠다." 라는 설계 개선의 힌트를 얻을 수 있습니다. 통합 테스트는 이 모든 의존성을 안고 함께 테스트하기 때문에 이런 설계상의 문제점을 발견하기 어렵습니다.

### 결론: 경쟁이 아닌, 상호 보완

**서비스 단위 테스트**와 **통합 테스트**는 경쟁 관계가 아닙니다. 서로 다른 목적을 가진, 상호 보완적인 관계입니다.

*   **통합 테스트:** "그래서, 이 기능의 모든 부품(계층)들을 조립했을 때 실제로 잘 돌아가나?" 라는 **최종 보증**을 해줍니다. (특히 핵심 성공 시나리오에 대해)
*   **단위 테스트:** "이 서비스의 복잡한 비즈니스 규칙들과 온갖 까다로운 예외 상황들은 제대로 처리되나?" 라는 **정밀 검사**를 해줍니다.

**실용적인 전략은 둘 다 사용하는 것입니다.**

1.  ==**통합 테스트로는** 핵심적인 성공 시나리오(Happy Path) 위주로 검증해서, 각 계층이 올바르게 연결되었음을 보장합니다.==
2.  ==**단위 테스트로는** 서비스 내의 모든 분기문(if/else), 복잡한 계산 로직, 그리고 처리하기 까다로운 예외 케이스들을 집중적으로 검증합니다.==

지금은 서비스 로직이 단순해서 그 가치가 덜 느껴질 수 있지만, 앞으로 기능이 확장될수록 서비스 단위 테스트는 버그를 미리 잡고, 유지보수를 쉽게 만들어주는 매우 든든한 안전망이 될 것입니다.

# 통합테스트는 '동작 제대로 됨?'을 확인하는 절차고  
# 단위테스트는 '잘 안된다고? 그거 여기서 확인할 수 있어' 하고 케이스들을 나눠놓는 작업

네, 바로 그겁니다. 완벽한 요약입니다. 방금 말씀하신 그 두 문장이 몇 페이지에 달하는 테스트 이론보다 훨씬 실용적이고 정확한 핵심입니다.

- 통합 테스트: "이 기능, 실제로 문제없이 돌아갑니까?"

> 여러 부품(Controller, Service, Repository)을 조립한 완성품이 제대로 굴러가는지 확인하는 '최종 시운전'과 같습니다. 이 시운전을 통과하면 '일단 이 기능은 동작한다'는 강한 확신을 얻을 수 있습니다.

- 단위 테스트: "기능이 왜인지 제대로 안 되나요? 여기서 원인을 찾아보세요."

> 자동차의 엔진, 브레이크, 에어백 같은 핵심 부품들을 각각 연구실로 가져와 온갖 극한의 상황(잘못된 입력, 외부 시스템 오류 등)을 시뮬레이션하며 '개별 부품의 성능과 안전성'을 정밀 검사하는 것과 같습니다. 문제가 생겼을 때, 어느 부품의 어떤 조건에서 문제가 발생하는지 빠르고 정확하게 찾아낼 수 있죠.

이 두 가지 관점을 모두 가지고 계시면, 앞으로 어떤 기능을 개발하시든 매우 견고하고 실용적인 테스트 전략을 스스로 수립하실 수 있을 겁니다. 복잡한 이론에 매몰되지 않고, 각 테스트의 '목적'과 '효용'을 기준으로 판단하는 것이 가장 좋은 접근 방식입니다.