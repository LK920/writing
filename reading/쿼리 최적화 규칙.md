# 데이터베이스 쿼리 최적화 규칙 가이드

이 문서는 데이터베이스 쿼리 최적화를 위한 주요 방법과 규칙을 중요도 순으로 정리한 가이드입니다. 쿼리 성능을 향상시키는 핵심 원칙을 다루며, 특히 `WHERE` 절에서 `NOT` 연산자 사용을 피하는 등의 구체적인 가이드라인을 포함합니다. 예시는 `User`와 `Balance` 테이블을 기반으로 하며, MySQL을 기준으로 작성되었으나 대부분의 RDBMS에 적용 가능한 원칙을 중심으로 설명합니다.

---

## 1. 쿼리 최적화의 중요성

쿼리 최적화는 데이터베이스 성능을 향상시켜 응답 시간을 단축하고, 시스템 자원을 효율적으로 사용하며, 서비스 안정성을 높이는 데 기여합니다. 주요 이점은 다음과 같습니다:
- **빠른 응답 시간**: 사용자 경험 개선.
- **자원 효율성**: CPU, 메모리, 디스크 I/O 사용량 감소.
- **확장성**: 대량 데이터와 고부하 환경에서 안정적인 성능 유지.

---

## 2. 쿼리 최적화 규칙 (중요도 순)

아래는 쿼리 최적화를 위한 규칙을 중요도(성능 영향 및 적용 빈도) 순으로 정리한 내용입니다. 각 규칙은 설명, 예시, 주의사항으로 구성됩니다.

### 2.1. 적절한 인덱스 생성 및 활용 (중요도: ★★★★★)
- **설명**:
  - 자주 사용되는 `WHERE`, `JOIN`, `ORDER BY`, `GROUP BY` 조건에 인덱스를 생성하여 쿼리 실행 속도를 향상.
  - 고유성(카디널리티)이 높은 컬럼(예: `user_id`)에 우선 인덱스 적용.
- **예시**:
  ```sql
  -- User 테이블에서 이름으로 조회
  SELECT * FROM user WHERE name = '김철수';
  -- 인덱스 생성
  CREATE INDEX idx_user_name ON user(name);

  -- Balance 테이블에서 user_id로 조인
  SELECT u.name, b.amount
  FROM user u
  JOIN balance b ON u.user_id = b.user_id
  WHERE b.amount > 1000;
  -- 인덱스 생성
  CREATE INDEX idx_balance_user_id ON balance(user_id);
  ```
- **주의사항**:
  - 인덱스 크기가 클수록 쓰기 성능(`INSERT`, `UPDATE`, `DELETE`) 저하 가능.
  - 쿼리 실행 계획(`EXPLAIN`)으로 인덱스 사용 여부 확인.
  - 예:
    ```sql
    EXPLAIN SELECT * FROM user WHERE name = '김철수';
    ```
    - `type: ref` 또는 `index`는 인덱스 사용, `ALL`은 풀 테이블 스캔(비효율적).
- **왜 중요한가?**:
  - 인덱스는 쿼리 성능에 가장 큰 영향을 미치며, 대부분의 병목을 해결하는 첫 번째 단계.

### 2.2. `WHERE` 절에서 함수, 연산, `NOT` 사용 최소화 (중요도: ★★★★★)
- **설명**:
  - `WHERE` 절에서 함수(예: `UPPER`, `SUBSTRING`), 연산(예: `column + 1`), `NOT` 연산자는 인덱스를 사용하지 못하게 하여 풀 테이블 스캔을 유발.
  - 컬럼의 원본 값을 조건으로 사용하면 인덱스 활용 가능.
- **예시**:
  ```sql
  -- 인덱스 사용 불가
  SELECT * FROM user WHERE UPPER(name) = 'KIM';
  -- 인덱스 사용 가능
  SELECT * FROM user WHERE name = 'Kim';

  -- NOT 사용 (인덱스 사용 어려움)
  SELECT * FROM user WHERE name NOT LIKE 'Kim%';
  -- 대체: 긍정 조건으로 변환
  SELECT * FROM user WHERE name LIKE 'Lee%';
  ```
- **주의사항**:
  - 함수 사용이 불가피한 경우, 함수형 인덱스 생성(MySQL 8.0 이상).
    ```sql
    CREATE INDEX idx_upper_name ON user(UPPER(name));
    ```
  - `NOT`은 데이터 분포에 따라 비효율적일 수 있으므로, 긍정 조건으로 변환하거나 인덱스 설계 재검토.
- **왜 중요한가?**:
  - 인덱스 사용 여부는 쿼리 성능에 직접적인 영향을 미치며, 잘못된 조건은 풀 스캔을 초래.

### 2.3. 불필요한 데이터 조회 최소화 (중요도: ★★★★☆)
- **설명**:
  - 필요한 컬럼만 `SELECT`하여 데이터 전송량과 I/O를 줄임.
  - `SELECT *`는 불필요한 컬럼까지 조회하여 성능 저하.
- **예시**:
  ```sql
  -- 비효율적
  SELECT * FROM user WHERE user_id = 1;
  -- 효율적
  SELECT name, age FROM user WHERE user_id = 1;
  ```
- **주의사항**:
  - 커버링 인덱스 활용: 필요한 컬럼만 포함된 인덱스로 쿼리 처리.
    ```sql
    CREATE INDEX idx_user_name_age ON user(name, age);
    ```
- **왜 중요한가?**:
  - 불필요한 데이터 조회는 메모리와 네트워크 비용을 증가시키며, 특히 대규모 테이블에서 영향 큼.

### 2.4. 효율적인 조인 설계 (중요도: ★★★★☆)
- **설명**:
  - `JOIN` 연산은 성능에 큰 영향을 미치므로, 조인 대상 테이블과 조건에 인덱스를 적용.
  - 가능한 작은 테이블부터 조인하고, 고유성이 높은 키로 조인.
- **예시**:
  ```sql
  -- user_id로 조인, 인덱스 활용
  SELECT u.name, b.amount
  FROM user u
  JOIN balance b ON u.user_id = b.user_id
  WHERE u.name = '김철수';
  -- 인덱스
  CREATE INDEX idx_balance_user_id ON balance(user_id);
  ```
- **주의사항**:
  - 불필요한 조인은 피하고, `INNER JOIN`을 우선 사용(`LEFT JOIN`은 추가 비용 발생 가능).
  - 조인 순서 최적화를 위해 실행 계획 확인.
- **왜 중요한가?**:
  - 조인은 CPU와 메모리 사용량을 크게 증가시킬 수 있음.

### 2.5. 페이징과 데이터 제한 적용 (중요도: ★★★☆☆)
- **설명**:
  - 대량 데이터 조회 시 `LIMIT`과 `OFFSET`을 사용해 결과 집합을 제한.
  - Spring Data JPA에서는 `Pageable`로 페이징 구현.
- **예시**:
  ```sql
  -- 비효율적: 전체 조회
  SELECT * FROM user;
  -- 효율적: 페이징
  SELECT * FROM user WHERE age > 20 LIMIT 10 OFFSET 0;
  ```
  ```java
  @Repository
  public interface UserRepository extends JpaRepository<User, Long> {
      Page<User> findByAgeGreaterThan(int age, Pageable pageable);
  }

  Pageable pageable = PageRequest.of(0, 10, Sort.by("age").descending());
  Page<User> users = userRepository.findByAgeGreaterThan(20, pageable);
  ```
- **주의사항**:
  - 높은 `OFFSET` 값은 성능 저하 유발(예: `OFFSET 10000`).
  - 키 기반 페이징(예: `WHERE id > last_id`)으로 대체 가능.
- **왜 중요한가?**:
  - 대량 데이터 처리 시 메모리와 응답 시간 절약.

### 2.6. `ORDER BY`와 `GROUP BY` 최적화 (중요도: ★★★☆☆)
- **설명**:
  - 정렬(`ORDER BY`)과 집계(`GROUP BY`)는 인덱스를 활용하면 성능 향상.
  - 인덱스 컬럼 순서와 정렬 방향 일치 필요.
- **예시**:
  ```sql
  SELECT * FROM user ORDER BY age DESC;
  -- 인덱스
  CREATE INDEX idx_user_age ON user(age);
  ```
- **주의사항**:
  - 복합 인덱스 사용 시 정렬 컬럼을 뒤에 배치.
  - `GROUP BY`는 임시 테이블 생성 가능성 있으므로 인덱스 필수.
- **왜 중요한가?**:
  - 정렬과 집계는 추가 연산 비용 발생, 인덱스로 줄일 수 있음.

### 2.7. 서브쿼리 대신 조인 사용 (중요도: ★★☆☆☆)
- **설명**:
  - 서브쿼리는 실행 계획이 비효율적일 수 있으므로, 가능하면 `JOIN`으로 대체.
- **예시**:
  ```sql
  -- 비효율적: 서브쿼리
  SELECT * FROM user WHERE user_id IN (SELECT user_id FROM balance WHERE amount > 1000);
  -- 효율적: 조인
  SELECT u.*
  FROM user u
  JOIN balance b ON u.user_id = b.user_id
  WHERE b.amount > 1000;
  ```
- **주의사항**:
  - 서브쿼리가 불가피한 경우, `EXISTS` 또는 `IN` 최적화 확인.
  - 실행 계획으로 비교.

### 2.8. 캐싱 활용 (중요도: ★★☆☆☆)
- **설명**:
  - 자주 조회되는 데이터는 Redis, Memcached 등으로 캐싱하여 DB 부하 감소.
  - JPA 2차 캐시 또는 쿼리 결과 캐싱 사용 가능.
- **예시**:
  ```java
  @Cacheable("usersByName")
  public List<User> findByName(String name) {
      return userRepository.findByName(name);
  }
  ```
- **주의사항**:
  - 캐시 만료 정책과 동기화 전략 필요.
  - 캐싱은 읽기 전용 데이터에 적합.

### 2.9. 쿼리 실행 계획 분석 및 통계 업데이트 (중요도: ★☆☆☆☆)
- **설명**:
  - 쿼리 실행 계획(`EXPLAIN`)으로 비효율적인 쿼리 식별.
  - 오래된 통계는 잘못된 실행 계획 유발, 주기적으로 업데이트.
- **예시**:
  ```sql
  EXPLAIN SELECT * FROM user WHERE name = '김철수';
  ANALYZE TABLE user;
  ```
- **주의사항**:
  - 대규모 테이블의 통계 업데이트는 실행 시간 고려.
  - MySQL: `SET GLOBAL optimizer_switch`로 최적화 설정 조정 가능.

### 2.10. 배치 처리로 대량 작업 최적화 (중요도: ★☆☆☆☆)
- **설명**:
  - 대량 `INSERT`, `UPDATE`, `DELETE`는 배치 처리로 트랜잭션 비용 감소.
  - JPA에서는 `saveAll` 또는 벌크 쿼리 사용.
- **예시**:
  ```java
  @Modifying(clearAutomatically = true)
  @Query("UPDATE User u SET u.age = u.age + 1 WHERE u.age < :age")
  int incrementAgeForYoungUsers(@Param("age") int age);
  ```
- **주의사항**:
  - 영속성 컨텍스트 관리 주의.
  - 트랜잭션 크기 조절로 록 경합 방지.

---

## 3. 쿼리 최적화 예시 (User와 Balance 테이블)

### 3.1. 테이블 정의
```sql
CREATE TABLE user (
    user_id BIGINT PRIMARY KEY,
    name VARCHAR(255),
    age INT,
    email VARCHAR(255),
    status ENUM('ACTIVE', 'INACTIVE')
);

CREATE TABLE balance (
    balance_id BIGINT PRIMARY KEY,
    user_id BIGINT,
    amount DECIMAL(10,2),
    FOREIGN KEY (user_id) REFERENCES user(user_id)
);
```

### 3.2. 최적화된 쿼리와 인덱스
- **쿼리**:
  ```sql
  SELECT u.name, u.age
  FROM user u
  JOIN balance b ON u.user_id = b.user_id
  WHERE u.name = '김철수' AND b.amount > 1000
  ORDER BY u.age DESC
  LIMIT 10;
  ```
- **인덱스**:
  ```sql
  CREATE INDEX idx_user_name_age ON user(name, age);
  CREATE INDEX idx_balance_user_id_amount ON balance(user_id, amount);
  ```
- **설명**:
  - `name`, `age` 복합 인덱스로 `WHERE`와 `ORDER BY` 최적화.
  - `user_id`, `amount` 복합 인덱스로 조인과 조건 처리.

### 3.3. 비효율적인 쿼리와 개선
- **비효율적**:
  ```sql
  SELECT * FROM user WHERE UPPER(name) = 'KIM' AND age != 30;
  ```
  - `UPPER`와 `NOT`으로 인덱스 사용 불가.
- **개선**:
  ```sql
  SELECT name, age FROM user WHERE name = 'Kim' AND age > 30 OR age < 30;
  -- 인덱스
  CREATE INDEX idx_user_name ON user(name);
  ```

---

## 4. 주의사항 및 팁

### 4.1. 쿼리 실행 계획 분석
- `EXPLAIN`으로 쿼리 병목 식별.
  ```sql
  EXPLAIN SELECT * FROM user WHERE name = '김철수';
  ```
- `type: ALL`은 풀 스캔, `ref` 또는 `index`는 인덱스 사용.

### 4.2. 데이터베이스별 차이
- MySQL: B-Tree 인덱스 중심, `FORCE INDEX`로 강제 가능.
- PostgreSQL: 고급 인덱스(GiST, GIN) 지원.
- 쿼리 최적화는 DB 엔진 특성 고려.

### 4.3. 테스트와 모니터링
- 테스트 컨테이너로 쿼리 성능 테스트.
- 슬로우 쿼리 로그로 병목 식별.
  ```sql
  SET GLOBAL slow_query_log = 'ON';
  ```

### 4.4. JPA와의 연계
- JPA에서 `JOIN FETCH`, `@EntityGraph`로 N+1 문제 해결.
- 벌크 쿼리는 `@Modifying`과 `clearAutomatically` 사용.
- 예:
  ```java
  @Query("SELECT u FROM User u JOIN FETCH u.balance WHERE u.name = :name")
  List<User> findUsersWithBalance(@Param("name") String name);
  ```

---

## 5. 결론
- **최우선 규칙**: 인덱스 활용과 `WHERE` 절의 함수/`NOT` 사용 최소화.
- **핵심 전략**: 필요한 컬럼만 조회, 효율적인 조인, 페이징 적용.
- **고급 최적화**: 캐싱, 서브쿼리 대체, 실행 계획 분석.
- **모니터링**: 슬로우 쿼리 로그와 `EXPLAIN`으로 지속적 개선.
- 쿼리 최적화는 인덱스 설계, 쿼리 구조, 실행 계획 분석을 통해 성능을 극대화하며, 서비스 요구사항에 맞게 균형을 조정해야 합니다.