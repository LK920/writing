
## 1. 개념: 쓰기, 조회, 수정 테이블 분리
데이터베이스에서 **쓰기 테이블**, **조회 테이블**, **수정 테이블**을 나누는 것은 동시성 문제(특히 **UPDATE 경합**)를 줄이고, 데이터 무결성을 보장하며, 시스템의 확장성과 유지보수성을 높이기 위한 설계 패턴입니다. 이는 **관심사 분리(Separation of Concerns)** 원칙을 데이터베이스에 적용한 것으로, 각 테이블이 특정 작업(쓰기, 조회, 수정)에 특화되도록 설계합니다.

- **쓰기 테이블**:
  - 주로 **삽입(Insert)** 연산에 사용.
  - 데이터 변경 이벤트를 기록(예: 이력, 로그).
  - 동시성 충돌 최소화(삽입은 레코드 간 락 필요 없음).
  - 예: `stock_histories`, `balance_transactions`.
- **조회 테이블**:
  - 읽기(Read) 전용 또는 조회 성능 최적화.
  - 집계 데이터(`SUM`, `COUNT`)나 캐시된 상태 제공.
  - 예: `balance` 테이블에서 `current_balance` 조회.
- **수정 테이블**:
  - **업데이트(Update)** 연산에 사용.
  - 동시 업데이트 시 경합 가능성이 있으므로, 락 관리(낙관적/비관적 락) 필요.
  - 예: `product_stocks`, `balance`.

### 1.1. 왜 테이블을 분리하나?
- **UPDATE 경합 문제**:
  - 여러 트랜잭션이 동시에 같은 레코드를 수정하려고 하면, 데이터베이스는 로우 락(Row Lock)을 걸어 대기 시간 발생 → **성능 병목**.
  - 예: 다수 사용자가 동시에 상품 재고(`stock`) 또는 사용자 잔액(`current_balance`)을 업데이트.
- **분리 이점**:
  - **경합 감소**: 쓰기(삽입)와 수정(업데이트)을 분리해 락 범위 최소화.
  - **이력 관리**: 쓰기 테이블로 변경 이력 기록, 감사 로그(Audit Log) 제공.
  - **성능 최적화**: 조회 테이블로 빠른 읽기 제공, 수정 테이블에 낙관적 락 적용.
  - **확장성**: 각 테이블의 역할 명확화로 유지보수와 확장 용이.

## 2. 케이스 분석: `Product`와 `Balance` 테이블

### 2.1. `Product` 테이블 개선
#### **현재 문제**
```sql
CREATE TABLE product (
    id BIGINT PRIMARY KEY,
    name VARCHAR(100),
    price DECIMAL(10, 2),
    stock INT NOT NULL DEFAULT 0,
    reserved_stock INT NOT NULL DEFAULT 0,
    created_at TIMESTAMP
);
```
- **문제점**:
  - `stock`, `reserved_stock` 업데이트 시 전체 레코드 락 → 경합 발생.
  - 예: 사용자 A, B가 동시에 `product(id=1)`의 `stock` 감소 → 로우 락으로 대기.
  - 변경 이력 없음 → 변동 원인 추적 어려움.

#### **개선안**
```sql
CREATE TABLE product_stocks (
    product_id BIGINT PRIMARY KEY,
    available_stock INT NOT NULL DEFAULT 0,
    reserved_stock INT NOT NULL DEFAULT 0,
    version BIGINT NOT NULL DEFAULT 0, -- 낙관적 락
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE stock_histories (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    product_id BIGINT,
    change_type VARCHAR(20), -- RESERVE, CONFIRM, CANCEL, RESTOCK
    quantity INT,
    before_stock INT,
    after_stock INT,
    order_id BIGINT,
    created_at TIMESTAMP
);
```
- **역할 분리**:
  - **수정 테이블 (`product_stocks`)**:
    - 재고 상태(`available_stock`, `reserved_stock`) 관리.
    - `version`으로 낙관적 락 적용 → 동시 업데이트 충돌 감지.
    - 락 범위 축소: `product`의 `name`, `price`는 락 제외.
  - **쓰기 테이블 (`stock_histories`)**:
    - 재고 변경 이벤트 기록(삽입 전용).
    - 예: `INSERT INTO stock_histories (product_id, change_type, quantity, before_stock, after_stock, order_id) VALUES (1, 'RESERVE', 2, 100, 98, 123)`.
    - 삽입 연산은 락 최소화 → 경합 없음.
- **이점**:
  - **경합 감소**: `product_stocks`만 락, 낙관적 락으로 동시성 향상.
  - **이력 관리**: `stock_histories`로 변동 원인 추적(예: 주문, 취소).
  - **성능**: 락 범위 축소로 동시 요청 처리 효율 증가.

#### **구현 예시**
```java
@Service
public class ProductService {
    @Autowired
    private ProductStockRepository productStockRepository;
    @Autowired
    private StockHistoryRepository stockHistoryRepository;

    @Transactional
    public void reserveStock(Long productId, int quantity, Long orderId) {
        ProductStock stock = productStockRepository.findByProductId(productId)
            .orElseThrow(() -> new RuntimeException("Stock not found"));
        
        if (stock.getAvailableStock() < quantity) {
            throw new InsufficientStockException("재고 부족");
        }

        // 낙관적 락으로 업데이트
        int updated = productStockRepository.updateStock(
            productId,
            stock.getAvailableStock() - quantity,
            stock.getReservedStock() + quantity,
            stock.getVersion()
        );
        if (updated == 0) {
            throw new OptimisticLockException("동시 업데이트 충돌");
        }

        // 이력 기록
        StockHistory history = new StockHistory();
        history.setProductId(productId);
        history.setChangeType("RESERVE");
        history.setQuantity(quantity);
        history.setBeforeStock(stock.getAvailableStock());
        history.setAfterStock(stock.getAvailableStock() - quantity);
        history.setOrderId(orderId);
        stockHistoryRepository.save(history);
    }
}
```

### 2.2. `Balance` 테이블 개선
#### **현재 문제**
```sql
CREATE TABLE balance (
    user_id BIGINT PRIMARY KEY,
    current_balance DECIMAL(19,2) NOT NULL DEFAULT 0.00,
    updated_at TIMESTAMP
);
```
- **문제점**:
  - 동시 결제 시 `current_balance` 업데이트 → 로우 락으로 경합.
  - 예: 사용자 A가 3,000원, 5,000원 결제 동시 시도 → `user_id=1` 레코드 락, 대기 발생.
  - 잔액 변동 이력 없음 → 원인 추적 어려움.

#### **개선안**
```sql
CREATE TABLE balance_transactions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT,
    transaction_type VARCHAR(20), -- CHARGE, PAYMENT, REFUND
    amount DECIMAL(19,2),
    balance_after DECIMAL(19,2),
    reference_id VARCHAR(100), -- order_id, payment_id 등
    created_at TIMESTAMP
);
```
- **역할 분리**:
  - **쓰기 테이블 (`balance_transactions`)**:
    - 잔액 변동(충전, 결제, 환불) 기록, 삽입 전용.
    - 예: `INSERT INTO balance_transactions (user_id, transaction_type, amount, balance_after, reference_id) VALUES (1, 'PAYMENT', -3000, 7000, 'order_123')`.
    - 삽입 연산 → 락 최소화.
  - **조회 테이블 (선택적 `balance`)**:
    - 잔액 조회 시 `SUM(amount)`로 계산:
      ```sql
      SELECT COALESCE(SUM(amount), 0) AS current_balance
      FROM balance_transactions
      WHERE user_id = 1;
      ```
    - 또는 `balance` 테이블 유지, 배치로 갱신.
- **이점**:
  - **경합 감소**: `balance_transactions`는 삽입 전용 → 락 충돌 없음.
  - **이력 관리**: `transaction_type`, `reference_id`로 변동 원인 추적.
  - **유연성**: `SUM` 또는 `balance_after`로 잔액 계산.

#### **구현 예시**
```java
@Service
public class BalanceService {
    @Autowired
    private BalanceTransactionRepository balanceTransactionRepository;

    @Transactional
    public void processPayment(Long userId, BigDecimal amount, String orderId) {
        BigDecimal currentBalance = balanceTransactionRepository.sumBalanceByUserId(userId);
        if (currentBalance.compareTo(amount) < 0) {
            throw new InsufficientBalanceException("잔액 부족");
        }

        BalanceTransaction transaction = new BalanceTransaction();
        transaction.setUserId(userId);
        transaction.setTransactionType("PAYMENT");
        transaction.setAmount(amount.negate());
        transaction.setBalanceAfter(currentBalance.subtract(amount));
        transaction.setReferenceId(orderId);
        balanceTransactionRepository.save(transaction);
    }
}
```

## 3. 테이블 분리 패턴의 핵심 원칙
- **쓰기 테이블 (이력/로그 테이블)**:
  - 삽입 전용, 락 최소화.
  - 변경 이벤트 기록(예: `stock_histories`, `balance_transactions`).
  - 감사 로그, 디버깅, 분석 용이.
- **수정 테이블**:
  - 현재 상태 관리(예: `product_stocks`, `balance`).
  - 낙관적 락(`version`) 또는 비관적 락으로 동시성 관리.
  - 락 범위 최소화 위해 다른 데이터(예: `name`, `price`) 분리.
- **조회 테이블**:
  - 읽기 성능 최적화.
  - 집계(`SUM`) 또는 캐시된 데이터 제공.
  - 예: `balance` 테이블 또는 `balance_transactions`의 `balance_after`.

## 4. 관련 개념
- **[[CQRS는 또 뭐야|CQRS]] (Command Query Responsibility Segregation)**:
  - 명령(쓰기/수정)과 조회를 분리.
  - 예: `balance_transactions` (명령), `balance` (조회).
  - 이점: 읽기/쓰기 워크로드 분리, 성능 최적화.
- **이벤트 소싱 (Event Sourcing)**:
  - 상태를 직접 저장하지 않고, 이벤트(`balance_transactions`, `stock_histories`)로 기록.
  - 상태는 이벤트 재생(`SUM(amount)`)으로 계산.
  - 이점: 이력 추적, 유연한 상태 재구성.
- **낙관적 락 vs 비관적 락**:
  - **낙관적 락**: `version` 컬럼으로 충돌 감지, 재시도 로직 필요.
  - **비관적 락**: 로우 락으로 동시 접근 차단, 대기 시간 증가.
  - 개선안은 낙관적 락 선호 (`product_stocks.version`).

## 5. 주의사항
- **성능**:
  - `SUM` 연산이 느릴 경우, 인덱스 추가(예: `CREATE INDEX idx_user_id ON balance_transactions(user_id)`).
  - `balance` 테이블 유지 시, 배치 작업으로 갱신.
- **데이터 정합성**:
  - `balance_after`와 `SUM(amount)` 일치 검증.
  - `stock_histories`, `balance_transactions`에 모든 변경 기록 필수.
- **마이그레이션**:
  - `product`: `stock`, `reserved_stock` → `product_stocks`.
    ```sql
    INSERT INTO product_stocks (product_id, available_stock, reserved_stock, version)
    SELECT id, stock, reserved_stock, 0 FROM product;
    ```
  - `balance`: 초기 잔액 → `balance_transactions`.
    ```sql
    INSERT INTO balance_transactions (user_id, transaction_type, amount, balance_after, reference_id)
    SELECT user_id, 'INITIAL', current_balance, current_balance, 'initial_balance'
    FROM balance;
    ```
- **배치 작업**: `balance` 갱신 시 트랜잭션 충돌 주의.

## 6. 결론
쓰기(`stock_histories`, `balance_transactions`), 수정(`product_stocks`, `balance`), 조회 테이블을 분리하면 UPDATE 경합을 줄이고, 동시성 성능을 높이며, 이력 관리로 추적성을 강화합니다. `Product` 케이스는 재고를 `product_stocks`로 분리해 락 범위를 최소화하고, `stock_histories`로 이력을 기록. `Balance` 케이스는 `balance_transactions`로 삽입 중심 설계하여 경합을 없애고, 잔액을 `SUM` 또는 배치로 계산. 이 패턴은 CQRS, 이벤트 소싱과 연계되어 확장성과 유지보수성을 높입니다.