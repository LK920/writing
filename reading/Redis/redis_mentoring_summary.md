# Redis 멘토링 정리 - 2025.08.19

## 1. Redis 사용 용도와 도입 시점에 대한 질문 (현성님)

### 현성님의 질문 내용
실시간 쿠폰에서 Redis 사용처를 크게 두 가지로 정리:
1. DB 쿼리 전에 필터 혹은 트래픽 방지 용도
2. 비즈니스 처리 용도

### 코치의 답변: "다 써야 된다"

**코치의 핵심 철학**: 트래픽이 많아지면 다 쓰지 않으면 DB가 버틸 수 없다.

#### 실제 사례를 통한 설명
- **이커머스의 인기 상품**: 실시간으로 바뀌거나 매일 바뀌는 변동성이 큰 데이터
- 이런 데이터들은 굳이 DB에서 관리할 필요가 없음
- **실제 트래픽 수치**: 콘서트 예약이나 커머스에서 최대 트래픽 10만~40만 TPS
- 이 트래픽을 DB로 그대로 받으면 서버가 죽을 수 있음

#### Redis 도입의 필연성
> "이거를 도입하지 않으면 안 되는 시점에 자연스럽게 Redis를 쓰게 될 거예요"

**도입 과정**:
1. 부하 테스트 실시 (예: 초당 1만 명 접속)
2. DB에 문제 발생 확인
3. 자연스럽게 선택지가 하나뿐: **Redis 도입**
4. DB 쿼리 개선도 있지만, 잘 했다는 가정 하에 많은 트래픽을 버티려면 결국 Redis 필요

## 2. Redis에서의 데이터 저장 방식 최적화

### 현성님의 쿠폰 발급 여부 관리 방법
- **기존 계획**: Set을 사용하여 중복 발급 방지
- **문제점**: Set은 저장 공간을 꽤 많이 차지하는 자료구조

### 코치의 최적화 제안

#### 상황 설정을 통한 교육
> "현성님이 트래픽이 엄청나게 많은 서비스를 개발하고 있어요. 최대 트래픽 10만~40만인데, 메모리가 헐떡헐떡하는데 어떻게든 구현을 우겨넣어야 해요. 메모리 증설 못한다, 돈 없다."

#### 핵심 질문과 답변 유도
- **코치**: "일단 현성님이 알아야 되는 거는 유무잖아요?"
- **코치**: "그러면 어떤 자료구조가 떠오르세요? 여러 명을 관리해야 되잖아요."
- **현성님**: "배열?"
- **코치**: "Bitmap을 쓰면 되겠죠!"

#### Bitmap의 효율성
- **대한민국 인구 5천만 명 기준**: Bitmap으로 저장하면 **단 6MB**
- 5천만 명의 발급 여부를 엄청나게 효율적으로 저장 가능
- Redis에서 지원하는 다른 효율적 자료구조들도 많음 (HyperLogLog 등)

## 3. 대기열 관리에 대한 질문

### 현성님의 질문
"대기열로 유저 아이디와 타임스탬프를 Sorted Set으로 관리한다는게 정확히 어떤 의미인지 모르겠어요"

### 코치의 답변
- **현성님의 의도**: 유저 아이디를 키로 하고 타임스탬프를 값으로 하려는 것
- **코치**: "괜찮은 것 같아요. 좋은 것 같아요."

## 4. Redis 직렬화/역직렬화 심화 학습

### 현성님의 학습 상황
- 코드는 봤지만 장단점은 어느 정도 이해
- **구현 방식이 어려움**
- **실무 궁금증**: 회사에서 직접 커스텀해서 쓰는지, 아니면 라이브러리를 쓰는지

### 코치의 상세 설명

#### Redis 직렬화의 필요성
> "Redis는 그냥 메모리에 떠 있는 자료구조이기 때문에 Redis 입장에서 모든 데이터는 바이트입니다. 바이트 문자열은 우리 인간이 보는 거고, 컴퓨터는 바이트밖에 모르잖아요."

**객체 → 바이트 변환 과정**:
- 우리가 클래스를 만들면 객체를 Redis에 저장할 때 바이트 배열로 변환 필요
- Spring Framework는 이를 위한 인터페이스 제공
- 여러 구현체 존재: JSON, 여러 가지 방법들

#### Spring이 제공하는 3가지 Serializer

##### 1. JDK Serialization Redis Serializer (사용 비추천)
**특징**:
- Java 1.1부터 제공되는 "엄청난 고대의 유물"
- `Serializable` 인터페이스 구현 필수
- `serialVersionUID` 명시 필요

**문제점들**:
1. **클래스 정보 포함**: 패키지명, 클래스명 등 부가 정보가 엄청나게 많이 포함
2. **저장 공간 비효율**: JSON은 필드와 데이터로 끝나지만, JDK 직렬화는 클래스 메타데이터까지 포함
3. **리팩토링 취약성**: 패키지를 다른 곳으로 옮기면 역직렬화 시 "이런 패키지에 이런 클래스는 없는데" 오류 발생
4. **Spring 기본값**: **별도 설정하지 않으면 Redis Template이나 @Cacheable에서 기본으로 사용**

##### 2. Generic Jackson2 Json Redis Serializer
**특징**:
- 내부적으로 ObjectMapper 사용
- JSON으로 직렬화하지만 문제 존재

**문제점**:
- 파라미터 없는 생성자 사용 시 내부적으로 ObjectMapper 생성
- `defaultTyping` 설정으로 추가 옵션 적용
- **결국 클래스 정보가 포함됨** → JDK 직렬화와 비슷한 구조
- 패키지 변경 시 문제 발생 가능

##### 3. Jackson2 Json Redis Serializer (권장)
**특징**:
- 항상 타입을 명시적으로 지정해야 함
- 번거로움이 있지만 안전

**사용법**:
```java
// 직렬화할 때 타입 정보를 명시적으로 지정
serializer.serialize(object, TypeReference.of(MyClass.class));
```

### 실무에서의 선택 기준

#### 성능과 메모리 고려사항
> "Redis는 엄청나게 많은 트래픽을 받잖아요. Redis를 서버를 구성할 때 보통 클러스터링 구조로 만들어요. 하나의 Redis 서버가 5만~15만 TPS 정도 받을 수 있어요."

**핵심 포인트**:
- Redis는 **CPU 사용량보다 메모리 사용량이 문제**가 되는 경우가 많음
- 메모리 부족 시 **데이터 압축**이 효율적
- 나중에 압축 기능이 들어간 **커스텀 Serializer** 필요할 수 있음

#### 최종 권장사항
> "정리하면 Spring은 크게 세 가지 직렬화기를 제공하고 있고, 그중에서 JDK는 버리고 크게 두 개 중 하나를 선택하면 된다. 트래픽이 많아지고 저장 공간이 부족해지면 압축 기능이 부가적으로 들어간 커스텀한 Serializer를 만들어줄 필요가 있을 수 있다."

## 5. Redis 동작 원리: 논블로킹 + 싱글 스레드

### 현성님의 이해도 확인
**코치**: "현성님 블로킹과 논블로킹의 차이 잘 아세요?"
**현성님**: "잘 모르겠습니다."

### 코치의 쉬운 설명

#### 블로킹 vs 논블로킹 실제 예시
**블로킹**:
- 코치: "현성님 이거 블로킹 알아요?" → 기다림
- 실시간으로 기다리는 것

**논블로킹**:
- 코치: "Redis 비트맵 자료구조 비슷한 거 뭐죠?" → 다음 진행
- 멘토링 멈추지 않고 계속 진행
- 준건님이 답변을 적어주시면 → "하이퍼로그로그 맞아요!" 하고 다시 돌아옴
- **클라이언트가 기다리지 않고 다른 걸 처리하다가 끝나면 이어서 작업**

#### 멀티플렉싱 개념
> "5만 TPS까지 잘 버틴다고 했잖아요. 5만 개가 왔을 때도 하나의 싱글 스레드로 처리하는 기법이 멀티플렉싱입니다."

**Spring Framework와의 비교**:
- Spring도 동시성 처리가 뛰어남 (1000 TPS 가능)
- Spring 방식: 요청이 오면 "처리 중"으로 남겨두고 계속 다른 요청 받음
- 백그라운드에서 실제 처리
- 처리 완료되면 클라이언트가 신호를 줌 ("나 끝났다, 내 거 봐줘")
- 그러면 이어서 처리

**Redis의 핵심**:
- **싱글 스레드** + **멀티플렉싱** + **이벤트 루프** 기반 동작
- 하나의 코치(싱글 스레드)가 여러 명의 요청을 동시에 처리
- 완료되면 이벤트로 신호를 받아 이어서 처리

### 추가 학습 자료 추천
코치가 직접 추천한 강의:
- **널널한 개발자 아저씨**의 동시성 처리 강의
- "멀티플렉싱" 관련 내용
- 성능 극대화 방법에 대한 내용

## 6. 트랜잭션 관리 Best Practice

### 질문 배경
"인프라에서 짧게 트랜잭션을 가져간다는 것이 무엇인지"

### 코치의 상세 설명

#### 기존 방식의 문제점
**일반적인 방식**: Service에 `@Transactional` 적용
**문제 상황**: 
```java
@Service
@Transactional  // 문제가 되는 위치
public class SomeService {
    public void someMethod() {
        // DB 저장
        repository.save(entity);
        // 외부 API 호출 (네트워크 호출)
        externalApiClient.call();
    }
}
```

#### 왜 문제가 될까?

##### 1. 외부 API 호출의 롤백 불가능성
- **DB 실패**: 롤백 가능
- **외부 API 호출 실패**: 타 팀에서 삭제 API를 제공하지 않으면 롤백 거의 불가능

##### 2. 커넥션 점유 시간 문제
- 트랜잭션이 Service 계층에 있으면 **네트워크 호출 시간만큼 DB 커넥션을 점유**
- MSA 시대에는 네트워크 호출이 필수적
- 커넥션을 너무 오랫동안 점유하는 문제 발생

##### 3. 순서 제어의 중요성
**실패율 비교**:
- DB 호출 실패율: 거의 제로에 가까움
- API 호출 실패율: 네트워크 에러, 일시적 인프라 문제 등으로 상대적으로 높음

**권장 순서**: 
1. 네트워크 호출 먼저
2. DB 작업 나중에

### 해결 방안

#### 1. 트랜잭션 범위를 Infrastructure 계층으로 이동
- Repository 레벨에 짧게 적용
- Service에서는 Transaction Template으로 필요한 부분만 묶기

#### 2. 제어 순서 최적화
**코치의 실제 경험**:
> "저 같은 경우에는 네트워크 호출을 먼저 올려버리고 이런 세밀한 순서 조정들이 필요할 때가 있었더라고요."

### MSA 환경에서의 필연성
> "오늘날에는 MSA 시대가 되었고, 일을 하는데 네트워크 호출이 없을 수가 없을 거예요. 자연스럽게 트랜잭션의 범위를 인프라 계층으로 내리게 되더라고요."

**추가 질문 (현성님)**: "DB만 여러 개 쓴다면?"
**코치 답변**: "그때는 붙여도 될 것 같아요."

## 7. Spring Data JPA vs 포트-어댑터 패턴 딜레마

### 우영님의 상황과 고민

#### 기존 구조
- **포트**: Repository 인터페이스
- **어댑터**: JPA Repository 구현체
- **문제점**: EntityManager 사용 중

#### Spring Data JPA 도입 시 고민
1. **Spring Data JPA의 특성**: 인터페이스만 만들면 Spring이 알아서 구현체 생성
2. **딜레마**: 포트에 인터페이스를 또 붙이는 이상한 상황 발생
3. **시도한 방법**: 포트가 Spring Data JPA를 상속하도록 하여 구현체 제거

#### 설계 관점에서의 고민
> "포트-어댑터로 결합을 분리시켜놓은 건데, Spring Data JPA를 쓰겠다고 이걸 다시 붙여놓는 상황이 된 것 같아서"

**찾아본 해결방법**: 어댑터를 껍데기처럼 만들어서 JPA Repository 상속받는 형태
**결과**: 관리할 파일이 3개로 증가 → "쓸데없이 복잡해지는 게 아닌가" 고민

### 코치의 현실적인 답변

#### 포트-어댑터 패턴의 원래 목적
**코치**: "포트와 어댑터는 왜 써야 되나요?"
**우영님**: "어댑터가 교체되거나 하는 걸 가정할 때 사용하는 거죠."

#### 실제 구현체 변경 케이스 분석
**코치**: "Spring Data JPA를 쓴다고 했을 때 구현체가 바뀌는 케이스는 언제 있을까요?"
**우영님**: "데이터베이스가 통째로 달라지는 경우"

**코치의 핵심 인사이트**:
- **MySQL → Oracle, PostgreSQL**: 깨지지 않음 (같은 RDB이고 Spring의 PSA로 추상화됨)
- **RDB → MongoDB, Elasticsearch**: 90% 확률로 깨짐 (아무리 인터페이스로 추상화해도)

#### 코치의 개인적 견해
> "Spring Data JPA가 이미 한 번 추상화를 해줬기 때문에, 제 개인적으로는 한 번 또 포트-어댑터로 감싸는 거는 되게 비효율적이라고 생각하는 편이에요."

#### 실용적인 접근 방법

##### 코치의 권장 방식
1. **초기**: Spring Data JPA를 그냥 바로 사용
2. **네이밍 팁**: 미리 포트 스타일로 명명
   ```java
   // 좋은 예
   public interface MemberPort extends JpaRepository<Member, Long> {}
   
   // 나쁜 예  
   public interface MemberRepository extends JpaRepository<Member, Long> {}
   ```
3. **필요 시점**: 조짐이 보일 때 그때 추상화
4. **진화 과정**: 
   - `MemberPort` → `MemberPortImpl` (구현체 추가)
   - 호출하는 곳에서는 이미 포트 네이밍 사용 중이므로 변경 최소화

### 개인 취향 vs 팀 컨벤션

#### 코치의 철학
> "개인 취향보다는 회사의 컨벤션이 훨씬 중요하다고 생각하거든요. 저도 그냥 회사 컨벤션 따라요."

**이유**: 
- **인지 부하가 더 중요**: 개인의 코딩 스타일보다 팀 일관성
- "내 코드를 누가 봐도 우리 팀 코드 결과 비슷하다"는 느낌이 중요
- 임의로 하고 싶은 게 있어도 가급적 회사 정책 따르는 것을 선호

## 8. Service vs UseCase 계층 구조 질문

### 우영님의 추가 질문
**상황**: 현재 만드는 계층에서 Service와 UseCase가 동일
**질문**: Service에서 UseCase를 감싸는 형태가 맞는지, 아니면 반대인지

### 코치의 답변
> "제가 만드는 계층에서는 서비스와 유스케이스가 동일하거든요. 이거는 이 계층을 설계한 게 우영님이기 때문에 우영님이 더 잘 알지 않을까요?"

**우영님의 결론**: 
- 앞서 설명들을 종합하면 Repository 쪽으로 가까워지는 방향이 좋다는 의미로 이해
- 현재 UseCase를 Service에서 감싸는 형태로 구현했으므로 그대로 진행

### 트랜잭션 배치에 대한 재확인
**코치의 보충 설명**:
> "제가 트랜잭션을 인프라에 붙이면 좋다기보다는, 서비스에 붙이면 문제가 생기기 때문에 내려가야 된다. 정답이라기보다는 그렇게 하는 게 훨씬 유지보수나 장애 대응에 좋다고 봐주시면 좋을 것 같아요."

## 9. Redis Key 관리 전략

### 우영님의 질문
계층화된 패턴으로 `{env}:{domain}:{entity}:{id}` 형태 사용
- ENV는 왜 필요한지?
- 3개 정도 키를 쓰다 보니 겹칠 수도 있겠다는 생각

### 코치의 답변

#### 프리픽스의 필요성
**실제 상황**: 
- 큰 서비스에서는 저장소가 애초에 분리되어 있음
- 하지만 초기에는 같은 인프라를 사용하는 경우가 많음

**코치의 원칙**:
> "굳이 처음부터 분리할 이유가 없다면 그냥 같이 쓰는 거를 훨씬 현명한 방법이라고 생각하거든요."

**결론**: 같은 인프라 사용 시 프리픽스로 구분하는 것이 좋은 접근

#### 우영님 접근에 대한 평가
> "너무 잘 생각해주신 것 같아요. 못 챙겼을 수도 있을 것 같은데 잘 챙겨주셨다는 생각이 들었어요."

## 10. 인기 상품 구현과 캐시 정합성 (지수님)

### 지수님의 구현 방식

#### 인기 상품 랭킹 저장
- **Sorted Set**: 프로덕트 ID와 상품 주문 수를 등록
- **Hash**: 프로덕트 정보 저장
- **목적**: DB 접근 없이 인기 상품 조회 구현

#### 지수님의 고민
> "Redis와 DB 간의 정합성 문제. DB 데이터가 바뀌면 Redis에 담긴 데이터도 반영해야 되는데..."

### 코치의 구조 개선 제안

#### 코치가 설계한다면
```
// 인기 상품 랭킹
Key: "hot_products"
Value: Sorted Set {product_id:score, product_id:score, ...}

// 개별 상품 정보 캐시
Key: "product:{product_id}"  
Value: Product Object
```

**장점**: 
- 2차원으로 캐시 분리
- 프로덕트 캐시를 다른 서비스에서도 재사용 가능

### 캐시 정합성 관리의 현실

#### 코치의 실제 경험
> "토스에 가장 먼저 와서 가장 먼저 했던 게 쓸데없는 캐시를 다 걷어내는 거였거든요."

**캐시의 문제점**:
- **관리 포인트가 엄청 많아짐**
- **흔한 실수**: 캐시 무효화 누락
- **자주 듣는 말**: "데이터 바꿨는데 왜 이렇게 나와요?" → 캐시 안 날린 케이스

#### 캐시 도입 기준
**코치의 철학**:
> "Redis를 도입한다면 'Redis가 아니면 DB가 못 버티겠는데' 혹은 '서비스 장애 생기겠는데' 약간 이런 수준에서 도입해야 된다고 생각해요."

**trade-off 관점**:
- 정합성 문제 < 서비스 안정성/성능
- 이미 안정성이나 성능이 제일 중요한 시점에 도입

#### 코드 개선 우선순위
**코치의 원칙**:
> "내 코드상으로 개선할 수 있는 부분이 있다면 무조건 그거를 개선하고, Redis는 약간 비장의 카드로 남겨두는 게 훨씬 바람직한 설계라고 생각합니다."

**실제 사례**: 
- **당근마켓**: 트래픽이 미친 듯이 증가할 때까지 DB와 서버 두 가지 컴포넌트로만 버텨냄
- "생각보다 Redis가 있어야 된다는 서비스가 많지 않아요. 진짜로"

### SOT(Source of Truth) 관리

#### 기본 원칙
- **일반적**: SOT는 DB
- **예외 케이스**: PO가 "일주일 뒤에 날아가도 돼요"라고 하면 Redis가 SOT 될 수도 있음

## 11. 실시간 쿠폰 발급 비동기 구현 (지수님)

### 지수님의 구현 방식
1. **쿠폰 수량**: 공유 상태로 비동기 처리
2. **응답 속도**: 늦을 수 있어도 정합성 보장하는 데 좋다고 생각

### 코치의 비동기 처리 경고

#### 비동기 처리의 부적합성
**문제 상황**: 
- 쿠폰 발급받는데 쿠폰이 없으면 사용자에게 보여줘야 함
- 비동기로 처리하면 사용자는 "발급된 것처럼" 느끼지만 실제로는 실패할 수 있음
- **결론**: 실시간 응답이 필요한 경우에는 비동기 부적합

#### @Async 사용 시 주의사항

##### Spring의 기본 구현체 문제
**기본 사용**: `SimpleAsyncTaskExecutor`
**문제점**:
- 매번 새로운 스레드를 생성
- **하나의 스레드**: 1~10MB 메모리 소모
- 5천 개 Bitmap(6MB)보다 무거울 수 있음
- 매번 생성-소멸로 인한 리소스 낭비

##### 필수 설정
> "@Async를 사용할 때는 어떤 스레드풀을 반드시 설정해줘야 돼요"

**코치의 회사 체크리스트**:
1. **@Async 설정이 없는 회사**: "역시 빨리 이직해야겠다"
2. **MDC 설정도 없다면**: "그냥 이직하세요"

#### 비동기 처리 고도화 포인트
- **Thread Pool 설정** 필수
- **MDC(Mapped Diagnostic Context)** 설정
- 이런 설정들이 없으면 "리소스 처리 비용이 엄청나게 많이 들어서 처리량에 한계"

## 12. 압축 기능 최적화 팁

### 지수님의 마지막 질문
Gzip 압축 관련 질문

### 코치의 중요한 주의사항
> "Gzip은 용량이 적은 상태에서 압축을 하면 오히려 압축 전보다 데이터가 10배는 늘어나요."

**핵심 원칙**:
- **일정 크기 이상**일 때만 압축 적용
- 그렇지 않으면 오히려 메모리를 더 사용하게 됨
- **압축 효과를 보려면** 데이터 크기 임계값 설정 필요

## 13. 멘토링 마무리 및 다음 주 계획

### 이번 주 과제 분량
> "이번 주는 분량이 되게 적죠. 생각보다 Redis 쪽만 하면 되니까. 앞으로 더 적어요. 더 진짜 훨씬 더 적거든요."

### 다음 주 학습 방향
**캐시 적용 방법 두 가지**:
1. **@Cacheable**: Spring의 선언적 캐시
2. **Redis Template**: 프로그래밍 방식 캐시

**학습 목표**: 
- 두 방식 모두 알아보기
- 현재 방식에서 어떤 게 적합한지 판단
- 적합도에 맞춰서 도구 선택

### 과제 제출 방식
- **PR 두 개** 동일하게 제출
- 코치가 피드백 검토 후 제공

---

## 주요 키워드 설명

### Redis 관련
- **TPS (Transactions Per Second)**: 초당 처리 가능한 트랜잭션 수, Redis는 단일 서버당 5만~15만 TPS 처리 가능
- **Bitmap**: 비트 단위로 데이터를 저장하는 자료구조, 메모리 효율적 (5천만 명 → 6MB)
- **HyperLogLog**: 대용량 데이터의 카디널리티(고유값 개수) 추정하는 확률적 자료구조
- **Sorted Set**: Redis의 정렬된 집합 자료구조, 스코어 기반으로 자동 정렬
- **SOT (Source of Truth)**: 데이터의 신뢰할 수 있는 단일 출처, 일반적으로 DB

### 동시성 처리
- **논블로킹 (Non-blocking)**: 클라이언트가 응답을 기다리지 않고 다른 작업 수행
- **블로킹 (Blocking)**: 클라이언트가 응답을 실시간으로 기다리는 방식
- **멀티플렉싱 (Multiplexing)**: 하나의 자원으로 여러 작업을 동시에 처리하는 기술
- **이벤트 루프 (Event Loop)**: 이벤트 기반 비동기 처리 방식
- **싱글 스레드**: 하나의 스레드로 모든 요청을 처리하는 방식 (Redis의 특징)

### Spring Framework
- **@Transactional**: Spring의 선언적 트랜잭션 관리 어노테이션
- **@Async**: Spring의 비동기 처리 어노테이션
- **@Cacheable**: Spring의 선언적 캐시 어노테이션
- **AOP (Aspect-Oriented Programming)**: 관점 지향 프로그래밍, Spring의 핵심 기능
- **PSA (Portable Service Abstraction)**: Spring의 서비스 추상화 철학
- **MDC (Mapped Diagnostic Context)**: 로깅 시 컨텍스트 정보를 유지하는 기술

### 아키텍처 패턴
- **포트-어댑터 패턴**: 비즈니스 로직과 외부 의존성을 분리하는 헥사고날 아키텍처
- **MSA (Microservices Architecture)**: 서비스를 작은 단위로 분해하여 독립적으로 배포/운영

### 성능 최적화
- **ThreadPool**: 스레드를 미리 생성하여 재사용하는 패턴
- **SimpleAsyncTaskExecutor**: Spring의 기본 비동기 실행기 (매번 새 스레드 생성하여 비효율적)
- **Connection Pool**: 데이터베이스 연결을 미리 생성하여 재사용
- **Gzip**: 데이터 압축 알고리즘, 작은 데이터에는 오히려 역효과

### 직렬화
- **JDK Serialization**: Java의 기본 직렬화 방식, 비효율적이어서 사용 비추천
- **JSON Serialization**: JSON 형태로 직렬화하는 방식
- **ObjectMapper**: Jackson 라이브러리의 JSON 변환 클래스