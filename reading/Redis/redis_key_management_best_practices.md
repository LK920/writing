# Redis 키 설계 & 관리 가이드

> **대상:** Redis를 실무에서 사용하는 개발자(초급\~중급)

이 문서는 Redis의 **키 제약조건**, **키 네이밍 규칙**, **TTL 전략**, **운영·모니터링**, **클러스터 환경에서의 키 설계** 등 **키 관리에 필요한 모든 실무 지식**을 최대한 상세하게 정리한 문서입니다. 대충대충 요약된 내용이 아니라, 설계 템플릿·예제·운영 스크립트까지 포함되어 있어 바로 적용할 수 있습니다.

---

## 목차

1. 개요 — 왜 키 관리가 중요한가
2. Redis 키의 기본 제약조건(사실관계)
3. 키 네이밍 규칙(권장 표준)
4. TTL(만료) 전략 — 캐시/세션/임시데이터별 설계
5. 대규모 삭제·조회(운영) 기법: `KEYS` 금기, `SCAN` 사용법, UNLINK
6. Redis Cluster 관련 키 설계(해시 슬롯, 해시태그)
7. 메모리·성능 관점에서의 키 설계 팁
8. 원자성·경합 처리: Lua, SET NX EX, 트랜잭션
9. 마이그레이션·백업 전략(데이터 정리, 키 이름 변경 등)
10. 모니터링·알림 지표, 검사 스크립트
11. 실무용 체크리스트
12. FAQ 및 주의사항
13. 부록 — 유틸 스크립트 & 예제 코드

---

## 1) 개요 — 왜 키 관리가 중요한가

- Redis는 RDBMS처럼 스키마가 없고, **키(key)가 곧 스키마** 역할을 합니다. 즉 키 하나하나의 이름과 구조가 데이터 설계 문서의 일부가 됩니다.
- 잘못된 키 설계는 다음을 초래합니다:
  - 의도치 않은 키 충돌(덮어쓰기)
  - TTL(만료) 누락으로 인한 메모리 누수
  - 운영 시 `KEYS *` 같은 명령으로 인한 서비스 정지
  - 클러스터 환경에서 멀티키 연산 실패(다른 슬롯에 흩어짐)

따라서 **키 네이밍 표준화**, **TTL 정책**, **운영 절차**를 먼저 정의하는 것이 중요합니다.

## 2) Redis 키의 기본 제약조건(사실관계)

- **최대 키 길이:** Redis에서 키(및 문자열 값)는 기본적으로 **512MB**까지 허용됩니다. (설정으로 변경 가능)\
  ※ 현실적으로는 메모리·네트워크 비용 때문에 키를 수백 바이트 수준으로 유지하는 것이 권장됩니다.

- **바이너리 안전성:** Redis의 키는 **binary-safe**입니다. 즉, 널바이트(null)나 제어문자도 키에 포함될 수 있습니다.

- **대소문자 구분:** `User:1`과 `user:1`은 서로 다른 키입니다.

- **유일성/덮어쓰기:** 동일한 키로 `SET`하면 기존 값은 덮어써집니다(명시적 덮어쓰기). 덮어쓰기를 방지하려면 `SETNX` 또는 `SET ... NX`를 사용하세요.

- **키 수 제한:** 일반적으로 키의 수는 Redis 인스턴스가 가진 메모리, 내부 해시테이블 크기 등에 좌우되며 실무에서는 '메모리에 담길 수 있는 한도'가 사실상 한계입니다.

(참고: 공식 문서/레퍼런스에서 `512MB` 제한, `binary-safe` 설명을 확인하세요.)

## 3) 키 네이밍 규칙(권장 표준)

### 기본 원칙(목적 중심)

1. **서비스·애플리케이션 접두사**를 넣어 범위를 좁힌다. (`shop:`, `auth:` 등)
2. **도메인/엔티티명**을 명확히 한다. (`user`, `order`, `session`)
3. \*\*고유 식별자(ID)\*\*를 넣어 충돌을 막는다. (`:12345`)
4. \*\*속성(옵션)\*\*은 마지막에 붙여 사람이 읽기 쉽게 만든다. (`:profile`, `:cart`)
5. 구분자는 \*\*콜론(`:`)\*\*을 사용해 네임스페이스처럼 보이게 한다.

### 추천 패턴

```
{app}:{env}:{entity}:{id}:{attribute}
```

예) `shop:prod:user:12345:profile`

### 실무 예시

- 사용자 프로필(해시): `shop:prod:user:12345:profile` (Hash)
- 사용자 세션(토큰): `shop:prod:session:abcdef123456` (String, TTL 있음)
- 주문 집계 (date-based): `shop:prod:order:2025-08-09:summary` (String)
- 채팅 메시지(리스트): `chat:prod:room:456:messages` (List)

### 버전 표시 (Schema Evolution)

- 키 구조가 바뀔 가능성이 있다면 버전 접미사/접두사 사용 권장
  - `shop:prod:user:v2:12345:profile`
  - 또는 필드명에 `__v2`를 붙이는 대신 키 네임스페이스를 바꾸는 편이 안전함

### 멀티테넌시

- 테넌트ID는 접두사로 강제: `tenant:acme:shop:prod:user:12345`
- 테넌트 식별자를 키 내부가 아닌 네임스페이스 최상단에 둬서 분리 관리가 용이함

### 금지사항

- 짧고 모호한 키(`temp`, `data1`) 금지
- 특수문자·공백을 무분별하게 사용하지 말 것(가능하나 가독성·운영성이 떨어짐)
- 너무 긴 키(수 KB 이상)는 네트워크·메모리 비용을 키움

## 4) TTL(만료) 전략 — 캐시/세션/임시데이터별 설계

### TTL이 중요한 이유

- 캐시 특성상 데이터는 유효기간이 있어야 메모리 사용이 통제됩니다.
- TTL 미설정 시 데이터가 계속 쌓여 메모리 오버플로우 유발.

### TTL 적용 패턴

1. **캐시 (Cache-aside)**

   - 읽기 시 캐시 miss → 원본 조회 → 캐시에 `SET key value EX seconds`
   - TTL: 통상 60s \~ 24h 범위(비즈니스 특성에 따라 조정)

2. **세션/토큰**

   - 고정 만료(예: 30분), 재활성화 시 TTL 연장할지 여부를 정함
   - `SET key value EX 1800` 또는 `EXPIRE key 1800`로 연장

3. **슬라이딩 TTL**

   - 액세스가 있을 때마다 TTL을 재설정해 세션을 연장
   - 장점: 사용자 활동 유지, 단점: 오랜 시간 활동많은 키가 계속 유지됨

4. **레이트리밋/버킷 방식**

   - 카운터 기반 키에 TTL을 주어 윈도우 단위로 제한

### 만료 전략 선택 가이드

- 캐시: **짧은 TTL + 무작위화(분산 만료)** 권장(캐시스톰 방지)
- 세션: 사용 패턴에 따라 **고정 또는 슬라이딩** 선택
- 중요 데이터(비캐시): TTL 사용 안 함, 대신 명시적 삭제/마이그레이션 정책 사용

### 구현 팁

- TTL을 동일한 시간으로 맞추면 많은 키가 한꺼번에 만료되는 `Cache Stampede` 발생 가능 → TTL에 +/- jitter(무작위치)를 더해 분산
- 대량 만료가 예측될 경우, 만료 전에 백그라운드에서 정리 작업을 수행

## 5) 대규모 삭제·조회(운영) 기법

### `KEYS`는 절대 프로덕션에서 쓰지 말자

- `KEYS pattern`은 전체 키스페이스를 블로킹으로 스캔하므로 큰 인스턴스에서 서비스 영향을 줍니다.

### 안전한 대체: `SCAN`

- `SCAN`은 cursor 기반 점진적 스캔으로 서버를 장시간 블로킹하지 않는다.
- 예: `SCAN 0 MATCH shop:prod:user:* COUNT 1000`
- SCAN 사용 시 주의: 정렬되지 않은 스트림처럼 동작하므로 스캔 도중 키가 추가/삭제되면 결과가 변할 수 있음.

### 대량 삭제 패턴

- `redis-cli --scan --pattern 'shop:prod:user:*' | xargs -L 100 redis-cli UNLINK`
  - `UNLINK`는 비동기 삭제(서버 블록 시간 최소화) — Redis 4.0 이상
  - `DEL`은 동기 삭제(큰 객체 삭제 시 블로킹 위험)

### 운영 스크립트 예

```bash
# 안전하게 1000개씩 언링크(삭제)
redis-cli --scan --pattern 'shop:prod:temp:*' | \
  while read key; do
    echo "$key"
    redis-cli UNLINK "$key"
  done
```

## 6) Redis Cluster 관련 키 설계(해시 슬롯, 해시태그)

### 해시 슬롯 개념

- Redis Cluster는 **16,384개의 해시 슬롯**(0\~16383)으로 키를 분배함. 키가 어느 슬롯에 배치될지는 키의 바이트에 대한 CRC16 해시 결과로 결정됩니다.
- 멀티키 연산(예: `MGET`, `MULTI`에서 여러 키에 대한 연산)은 **같은 슬롯**에 있어야 성공합니다.

### 해시태그(Hash Tag)

- `{}`로 둘러싸인 문자열이 있다면 **태그 내부의 문자열만 해시 대상**이 됩니다. 예: `user:{123}:followers` 와 `msg:{123}:inbox` 는 둘 다 같은 태그 `123`을 가지므로 같은 슬롯에 배치됩니다.
- **실무 팁:** 연관된 여러 키를 같은 슬롯에 두고 싶을 때만 해시태그를 사용하세요. 태그를 남용하면 슬롯 균형이 깨질 수 있습니다.

### 주의사항

- 해시태그는 반드시 의도적으로 사용. 무분별한 `{}` 사용은 클러스터 분산의 이점을 무력화합니다.
- 태그에 긴 문자열(예: 오브젝트 전체)을 넣지 말 것 — 해시 처리 시간 증가 가능.

## 7) 메모리·성능 관점에서의 키 설계 팁

- **키는 짧게** 유지하되, 의미를 잃지 않을 정도로 분명하게 작성. (권장: 수십 바이트 이내)
- **필드가 많은 데이터는 Hash 사용**: 많은 작은 필드(사용자 속성 등)는 해시(Hash) 하나에 합쳐서 저장하면 키 수를 줄여 메모리와 메타데이터 오버헤드를 절감할 수 있음.
- **큰 바이너리·JSON은 별도의 스토리지 고려**: 로그, 대형 문서 등은 S3 같은 객체 스토리지에 두고 키에는 참조(URI)만 저장.
- **메모리 프로파일링**: `MEMORY USAGE key` 명령으로 개별 키의 메모리 사용량 확인(운영 시 spot check)
- **뎁스 제한**: 애플리케이션에서 키를 재귀적으로 생성하지 말 것(예: `a:b:c:d:e:...` 과도한 단계)

## 8) 원자성·경합 처리

### 간단한 락: `SET key value NX PX <ms>`

- 안전한 단일 노드 환경에서 간단한 락을 구현하려면:  `SET lock:key uuid NX PX 30000`
- 락 해제 시에는 `GET`으로 값 비교 후 `DEL`하거나 Lua 스크립트로 원자적으로 해제.

### Lua 스크립트 사용

- 여러 명령을 원자적으로 실행해야 할 때 Lua 사용: `EVAL`로 복잡한 체크·갱신·삭제 로직을 단일 명령처럼 실행.

예) 락 해제 Lua 예

```lua
-- args: KEYS[1], ARGV[1]
if redis.call('GET', KEYS[1]) == ARGV[1] then
  return redis.call('DEL', KEYS[1])
else
  return 0
end
```

### 트랜잭션 `MULTI/EXEC`

- 단순히 여러 명령을 트랜잭션으로 묶을 수 있으나, 트랜잭션은 롤백이 아닌 실패 시 그냥 오류를 반환하는 점 유의.

## 9) 마이그레이션·백업 전략

### 키 네임스페이스 변경(예: v1 → v2) 전략

1. 새 네임스페이스에 쓰기를 시작(`write-through` 방식으로 두군데 쓰거나 점진적 이전)
2. 점진적 백그라운드 작업으로 기존 키를 읽어 새 키로 변환
3. 변환 완료 후 기존 키 삭제 (SCAN + UNLINK)

### 대규모 데이터 이동

- `MIGRATE` 명령을 사용해 노드 간 키 전송 가능(클러스터 상태에 따라 사용)
- RDB/AOF 방식으로 백업 → 복원도 가능하지만, 복원 시 서비스 중단 고려

## 10) 모니터링·알림 지표, 검사 스크립트

### 필수 모니터링 지표

- 메모리 사용량 (`used_memory`, `used_memory_rss`)
- 키스페이스 통계 (`INFO keyspace`) — DB별 키 개수, 만료 설정 수 등
- 느린 명령(`SLOWLOG`) — `KEYS` 같은 무거운 명령 탐지
- 네트워크 입출력, 연결 수

### 운영 검사 스크립트 예

- `redis-cli INFO keyspace`로 DB별 키 개수와 만료 비율 점검
- `redis-cli --scan --pattern 'shop:prod:*' | wc -l` (주의: 스캔 시간 주의)

## 11) 실무용 체크리스트

-

## 12) FAQ 및 주의사항

**Q: 키 이름에 공백·한글을 써도 되나요?** A: 가능하지만 권장하지 않습니다. 운영·디버깅·스크립트 관점에서 ASCII(콜론·밑줄 등)만 사용하는 것이 관리에 편합니다.

**Q: 키 길이는 정확히 얼마가 적절한가요?** A: Redis가 허용하는 한도(512MB)는 있지만, 실무에서는 수십\~수백 바이트 수준을 권장합니다. 너무 길면 네트워크·메모리 비용이 증가합니다.

**Q: 많은 필드를 가진 객체는 어떻게 저장해야 할까요?** A: Hash 타입으로 한 키에 필드로 저장하거나, RedisJSON 모듈을 활용해 구조화된 저장을 고려하세요.

## 13) 부록 — 유틸 스크립트 & 코드 예제

### Redis CLI: 안전한 스캔 & 삭제 (bash)

```bash
# pattern에 매칭되는 키를 안전하게 삭제 (UNLINK 사용)
pattern='shop:prod:temp:*'
redis-cli --scan --pattern "$pattern" | \
  while read key; do
    echo "UNLINK $key"
    redis-cli UNLINK "$key"
  done
```

### Java(Lettuce) — SCAN 사용 예제 (간단)

```java
RedisClient client = RedisClient.create("redis://localhost:6379");
StatefulRedisConnection<String, String> conn = client.connect();
RedisCommands<String, String> sync = conn.sync();

String cursor = ScanCursor.INITIAL.getCursor();
while (!"0".equals(cursor)) {
  KeyScanCursor<String> scan = sync.scan(ScanArgs.Builder.matches("shop:prod:user:*").limit(1000));
  for (String key : scan.getKeys()) {
    // 처리
  }
  cursor = scan.getCursor();
}

conn.close();
client.shutdown();
```

### Lua - 조건부 갱신(원자성 예)

```lua
-- 키가 존재하면 값 갱신, 아니면 0 반환
if redis.call('EXISTS', KEYS[1]) == 1 then
  return redis.call('SET', KEYS[1], ARGV[1])
else
  return 0
end
```

---

### 마무리

이 문서는 **키 설계의 전 범위**를 다루도록 구성했습니다. 실무에서 Redis를 사용할 때 가장 큰 문제는 "키 설계 부재"에서 시작됩니다. 이 가이드를 기준으로 팀 내 규칙을 만들고, 코드 리뷰 체크리스트에 `redis 키 네이밍`을 추가하세요.

원하시면 이 문서를 실제 `.md` 파일로 만들어 드리거나, 회사 규칙에 맞춰 **템플릿(팀용)** 버전을 따로 만들어드리겠습니다.

