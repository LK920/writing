# 데이터베이스 인덱스 튜닝 규칙 가이드

이 문서는 데이터베이스 인덱스 튜닝을 위한 주요 규칙과 모범 사례를 중요도 순으로 정리한 가이드입니다. 인덱스 설계 및 최적화 시 고려해야 할 핵심 원칙을 다루며, 특히 `WHERE` 절에서 `NOT` 연산자 사용을 피하는 등의 구체적인 규칙을 포함합니다. 예시는 `User`와 `Balance` 테이블을 기반으로 설명하며, MySQL을 기준으로 하지만 다른 RDBMS에도 적용 가능한 원칙을 중심으로 작성되었습니다.

---

## 1. 인덱스 튜닝의 중요성

인덱스는 데이터베이스 쿼리의 성능을 크게 향상시키지만, 잘못 설계하면 저장 공간 낭비, 쓰기 성능 저하, 유지보수 비용 증가 등의 문제가 발생할 수 있습니다. 따라서 적절한 인덱스 설계와 튜닝은 다음과 같은 이점을 제공합니다:
- **조회 성능 향상**: `SELECT` 쿼리의 실행 시간을 단축.
- **효율적인 자원 사용**: 디스크 I/O와 메모리 사용량 감소.
- **서비스 안정성**: 대량 데이터 처리 시 성능 병목 방지.

---

## 2. 인덱스 튜닝 규칙 (중요도 순)

아래는 인덱스 튜닝을 위한 규칙을 중요도(성능 영향 및 적용 빈도) 순으로 정리한 내용입니다. 각 규칙은 설명, 예시, 주의사항으로 구성됩니다.

### 2.1. 자주 사용되는 `WHERE` 조건과 `JOIN` 조건에 인덱스 생성 (중요도: ★★★★★)
- **설명**:
  - `WHERE` 절과 `JOIN` 절에서 자주 사용되는 컬럼에 인덱스를 생성하여 쿼리 실행 속도를 높입니다.
  - 특히, 고빈도 쿼리(예: 메인 페이지 조회, 검색 기능)에서 사용하는 컬럼을 우선순위로 지정.
- **예시**:
  ```sql
  -- User EisenhowerDB에서 사용자 이름으로 조회
  SELECT * FROM user WHERE name = '김철수';
  -- 인덱스 생성
  CREATE INDEX idx_user_name ON user(name);
  ```
  ```sql
  -- Balance 테이블에서 사용자 ID로 자주 조회
  SELECT * FROM balance WHERE user_id = 1;
  -- 인덱스 생성
  CREATE INDEX idx_balance_user_id ON balance(user_id);
  ```
- **주의사항**:
  - 인덱스 크기가 클수록 쓰기 성능(INSERT, UPDATE, DELETE)이 저하될 수 있으므로, 실제 사용 빈도를 확인하세요.
  - 쿼리 실행 계획(EXPLAIN)을 분석하여 인덱스가 실제로 사용되는지 확인하세요.
- **왜 중요한가?**:
  - 자주 실행되는 쿼리의 성능을 직접적으로 향상시키므로 가장 중요한 규칙입니다.

### 2.2. 고유성(카디널리티)이 높은 컬럼에 인덱스 적용 (중요도: ★★★★☆)
- **설명**:
  - 카디널리티(Cardinality)가 높은 컬럼(고유한 값이 많은 컬럼)에 인덱스를 생성하면 검색 효율이 높아집니다.
  - 예: `user_id`(고유), `name`(중간), `status`(낮음, 예: 0 또는 1) 순으로 인덱스 효율성이 좋습니다.
- **예시**:
  ```sql
  -- 고유성이 높은 user_id에 인덱스
  CREATE INDEX idx_user_id ON user(user_id);
  -- 고유성이 낮은 status에는 인덱스 비효율적
  CREATE INDEX idx_user_status ON user(status); -- 비추천
  ```
- **주의사항**:
  - 고유성이 낮은 컬럼(예: 불린 값, 열거형)은 인덱스 효과가 미미할 수 있음.
  - 고유성이 높은 컬럼을 `WHERE`, `JOIN`, `ORDER BY`에 우선 적용.

### 2.3. `WHERE` 절에서 `NOT`, 함수, 연산 사용 피하기 (중요도: ★★★★☆)
- **설명**:
  - `NOT`, 함수(예: `UPPER`, `SUBSTRING`), 연산(예: `column + 1`)이 포함된 `WHERE` 조건은 인덱스를 사용하지 못할 가능성이 높습니다.
  - 인덱스는 컬럼의 원본 값을 기반으로 동작하므로, 값이 변형되면 인덱스가 무효화됩니다.
- **예시**:
  ```sql
  -- 인덱스 사용 불가
  SELECT * FROM user WHERE UPPER(name) = 'KIM';
  -- 인덱스 사용 가능
  SELECT * FROM user WHERE name = 'Kim';
  -- NOT 사용 (인덱스 사용 어려움)
  SELECT * FROM user WHERE name NOT LIKE 'Kim%';
  ```
- **주의사항**:
  - 함수 기반 쿼리가 필요한 경우, 함수형 인덱스(Functional Index, MySQL 8.0 이상) 사용 고려.
  - 예:
    ```sql
    CREATE INDEX idx_upper_name ON user(UPPER(name));
    ```
  - `NOT` 연산은 대체로 풀 테이블 스캔을 유발하므로, 가능하면 긍정 조건으로 변환.

### 2.4. 복합 인덱스(Composite Index)를 적절히 활용 (중요도: ★★★★☆)
- **설명**:
  - 여러 컬럼을 조합한 복합 인덱스를 사용하여 다중 조건 쿼리의 성능을 향상.
  - 컬럼 순서가 중요: 자주 사용되고 고유성이 높은 컬럼을 먼저 배치.
- **예시**:
  ```sql
  -- name과 age로 자주 조회
  SELECT * FROM user WHERE name = '김철수' AND age = 30;
  -- 복합 인덱스
  CREATE INDEX idx_user_name_age ON user(name, age);
  ```
- **주의사항**:
  - 인덱스 컬럼 순서가 쿼리 조건 순서와 일치해야 효과적.
  - 너무 많은 컬럼을 포함하면 인덱스 크기 증가로 쓰기 성능 저하.

### 2.5. 불필요한 인덱스 제거 또는 최소화 (중요도: ★★★☆☆)
- **설명**:
  - 사용되지 않는 인덱스는 저장 공간과 쓰기 성능을 저하시킵니다.
  - 쿼리 실행 계획(EXPLAIN)을 통해 실제 사용 여부 확인 후 제거.
- **예시**:
  ```sql
  -- 사용되지 않는 인덱스 확인
  EXPLAIN SELECT * FROM user WHERE email = 'test@example.com';
  -- 사용되지 않는 경우
  DROP INDEX idx_user_email ON user;
  ```
- **주의사항**:
  - 인덱스 제거 전 쿼리 패턴 분석 필수.
  - 드물게 사용되는 인덱스라도 중요한 쿼리에 필요할 수 있음.

### 2.6. 인덱스 크기 관리 (중요도: ★★★☆☆)
- **설명**:
  - 인덱스 크기가 크면 메모리 사용량과 디스크 I/O가 증가.
  - 문자열 컬럼(예: `VARCHAR`)은 필요한 길이만큼만 인덱싱(부분 인덱스).
- **예시**:
  ```sql
  -- 전체 name(255) 대신 처음 50자만 인덱싱
  CREATE INDEX idx_user_name_partial ON user(name(50));
  ```
- **주의사항**:
  - 부분 인덱스는 `LIKE 'prefix%'` 쿼리에 효과적.
  - 너무 짧은 길이는 검색 정확도 저하 가능.

### 2.7. 기본 키와 고유 키에 자동 인덱스 활용 (중요도: ★★★☆☆)
- **설명**:
  - MySQL에서 기본 키(PK)와 고유 키(UK)는 자동으로 인덱스가 생성됨.
  - 별도의 인덱스 생성 불필요.
- **예시**:
  ```sql
  -- user_id는 PK이므로 인덱스 자동 생성
  CREATE TABLE user (
      user_id BIGINT PRIMARY KEY,
      name VARCHAR(255)
  );
  ```
- **주의사항**:
  - PK는 변경이 적은 고유 컬럼으로 선택(예: `user_id` vs. `name`).
  - PK 변경은 모든 인덱스에 영향, 성능 저하 주의.

### 2.8. `ORDER BY`와 `GROUP BY`를 위한 인덱스 최적화 (중요도: ★★☆☆☆)
- **설명**:
  - 정렬(`ORDER BY`)과 집계(`GROUP BY`) 쿼리는 인덱스를 활용하면 성능 향상.
  - 인덱스 순서와 쿼리 정렬 방향 일치 필요.
- **예시**:
  ```sql
  -- age로 정렬 자주 수행
  SELECT * FROM user ORDER BY age DESC;
  -- 인덱스
  CREATE INDEX idx_user_age ON user(age);
  ```
- **주의사항**:
  - 복합 인덱스 사용 시 정렬 컬럼을 뒤에 배치.

### 2.9. 커버링 인덱스(Covering Index) 활용 (중요도: ★★☆☆☆)
- **설명**:
  - 쿼리에서 필요한 모든 컬럼을 인덱스에 포함시켜 테이블 액세스 없이 결과를 반환.
  - 조회 속도 대폭 향상.
- **예시**:
  ```sql
  -- name과 age만 필요
  SELECT name, age FROM user WHERE name = '김철수';
  -- 커버링 인덱스
  CREATE INDEX idx_user_name_age ON user(name, age);
  ```
- **주의사항**:
  - 인덱스 크기 증가로 쓰기 성능 저하 가능.
  - 쿼리 패턴 분석 후 적용.

### 2.10. 인덱스 통계 업데이트 (중요도: ★☆☆☆☆)
- **설명**:
  - 데이터베이스 통계가 오래되면 쿼리 옵티마이저가 잘못된 실행 계획 선택 가능.
  - 주기적으로 통계 업데이트.
- **예시**:
  ```sql
  -- MySQL에서 통계 업데이트
  ANALYZE TABLE user;
  ```
- **주의사항**:
  - 대규모 테이블의 경우 실행 시간 고려.
  - 자동 통계 업데이트 설정 확인.

---

## 3. 인덱스 튜닝 예시 (User와 Balance 테이블)

### 3.1. 테이블 정의
```sql
CREATE TABLE user (
    user_id BIGINT PRIMARY KEY,
    name VARCHAR(255),
    age INT,
    email VARCHAR(255),
    status ENUM('ACTIVE', 'INACTIVE')
);

CREATE TABLE balance (
    balance_id BIGINT PRIMARY KEY,
    user_id BIGINT,
    amount DECIMAL(10,2),
    FOREIGN KEY (user_id) REFERENCES user(user_id)
);
```

### 3.2. 인덱스 설계
- **User 테이블**:
  ```sql
  -- 자주 조회되는 name과 age
  CREATE INDEX idx_user_name_age ON user(name, age);
  -- email 검색
  CREATE INDEX idx_user_email ON user(email(50));
  ```
- **Balance 테이블**:
  ```sql
  -- user_id로 자주 조인
  CREATE INDEX idx_balance_user_id ON balance(user_id);
  -- amount로 범위 조회
  CREATE INDEX idx_balance_amount ON balance(amount);
  ```

### 3.3. 쿼리 최적화
- **좋은 쿼리**:
  ```sql
  SELECT * FROM user WHERE name = '김철수' AND age > 20;
  -- idx_user_name_age 인덱스 사용
  ```
- **나쁜 쿼리**:
  ```sql
  SELECT * FROM user WHERE UPPER(name) = 'KIM' AND age != 20;
  -- 인덱스 사용 불가, 함수와 NOT 사용
  ```

---

## 4. 주의사항 및 팁

### 4.1. 인덱스 오버헤드 관리
- 인덱스가 많아질수록 쓰기 성능(INSERT, UPDATE, DELETE) 저하.
- 사용 빈도가 낮은 인덱스는 제거.

### 4.2. 쿼리 실행 계획 분석
- `EXPLAIN`으로 인덱스 사용 여부 확인.
  ```sql
  EXPLAIN SELECT * FROM user WHERE name = '김철수';
  ```
- 결과에서 `type: index` 또는 `ref`가 이상적, `ALL`(풀 스캔)은 피해야 함.

### 4.3. 데이터베이스별 차이
- MySQL: B-Tree 인덱스 기본, InnoDB는 클러스터드 인덱스(PK) 중요.
- PostgreSQL: B-Tree 외 GiST, GIN 등 고급 인덱스 지원.
- 규칙은 대부분 공통 적용 가능.

### 4.4. 테스트와 모니터링
- 테스트 컨테이너로 인덱스 성능 테스트.
- 슬로우 쿼리 로그로 병목 쿼리 식별.
- 예: MySQL 슬로우 쿼리 활성화
  ```sql
  SET GLOBAL slow_query_log = 'ON';
  ```

---

## 5. 결론
- **최우선 규칙**: 자주 사용되는 `WHERE`와 `JOIN` 조건에 인덱스 생성, 고유성 높은 컬럼 우선.
- **핵심 주의**: `NOT`, 함수, 연산은 인덱스 사용 방해, 최소화.
- **효율적 설계**: 복합 인덱스, 커버링 인덱스 활용, 불필요한 인덱스 제거.
- **모니터링**: 쿼리 실행 계획과 통계로 지속적 최적화.
- 인덱스 튜닝은 쿼리 패턴 분석과 성능 테스트를 통해 최적의 결과를 얻을 수 있습니다.


---


