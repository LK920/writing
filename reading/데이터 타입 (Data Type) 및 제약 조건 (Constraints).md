
## 1. 서론: 데이터베이스의 뼈대 이해하기

데이터베이스는 단순히 데이터를 저장하는 공간이 아닙니다. 데이터의 종류를 명확히 정의하고, 저장될 데이터의 유효성을 보장하며, 데이터 간의 관계를 설정함으로써 정보의 신뢰성과 효율성을 극대화하는 시스템입니다. 이 과정에서 핵심적인 역할을 하는 것이 바로 **데이터 타입(Data Type)**과 **제약 조건(Constraints)**입니다.

이 문서를 통해 데이터 타입과 제약 조건이 무엇인지, 왜 중요한지, 그리고 실제 데이터베이스에서 어떻게 활용되는지 상세히 알아보겠습니다.

## 2. 데이터 타입 (Data Type): 데이터의 종류 정의

**데이터 타입**은 데이터베이스 컬럼에 저장될 수 있는 데이터의 종류를 정의합니다. 예를 들어, 숫자를 저장할지, 문자를 저장할지, 날짜를 저장할지 등을 명시하는 것입니다. 적절한 데이터 타입 선택은 데이터 저장 효율성, 쿼리 성능, 그리고 데이터의 정확성에 직접적인 영향을 미칩니다.

### 주요 데이터 타입 분류 및 설명

데이터베이스 시스템(DBMS)마다 제공하는 데이터 타입은 약간씩 다를 수 있지만, 대부분 아래와 같은 범주로 나눌 수 있습니다.

#### 2.1. 숫자형 (Numeric Types)

숫자를 저장하는 데 사용됩니다. 정수와 실수로 나뉩니다.

- **정수형 (Integer Types)**: 소수점 이하가 없는 숫자를 저장합니다. 저장할 수 있는 숫자의 범위에 따라 여러 종류가 있습니다.
    
    - `TINYINT`: 매우 작은 정수 (예: -128 ~ 127 또는 0 ~ 255)
        
    - `SMALLINT`: 작은 정수 (예: -32,768 ~ 32,767)
        
    - `MEDIUMINT`: 중간 크기 정수
        
    - `INT` (또는 `INTEGER`): 일반적인 정수 (가장 흔하게 사용)
        
    - `BIGINT`: 매우 큰 정수 (매우 큰 숫자가 필요한 경우)
        
    - **사용 예시**: 사용자 ID, 상품 재고 수량, 나이 등
        
- **실수형 (Floating-Point Types)**: 소수점 이하가 있는 숫자를 저장합니다. 정밀도에 따라 구분됩니다.
    
    - `FLOAT`: 단정밀도 부동 소수점 숫자. 비교적 작은 소수점 수를 저장할 때 사용합니다. 정밀도가 낮아 오차가 발생할 수 있습니다.
        
    - `DOUBLE`: 배정밀도 부동 소수점 숫자. `FLOAT`보다 더 큰 범위와 높은 정밀도를 가집니다.
        
    - `DECIMAL` (또는 `NUMERIC`): 정확한 소수점 숫자를 저장할 때 사용합니다. 금융 데이터와 같이 정확한 계산이 필요한 경우에 주로 사용되며, 저장 공간을 더 많이 차지할 수 있습니다. `DECIMAL(P, S)` 형태로 사용하며, `P`는 전체 자릿수, `S`는 소수점 이하 자릿수를 의미합니다.
        
    - **사용 예시**: 상품 가격, 평점, 키, 몸무게 등
        

#### 2.2. 문자열형 (String Types)

텍스트 데이터를 저장하는 데 사용됩니다.

- `CHAR(n)`: 고정 길이 문자열을 저장합니다. `n`은 저장할 문자의 최대 길이를 의미합니다. 지정된 길이보다 짧은 문자열이 들어오면 나머지 공간을 공백으로 채웁니다. 저장 공간이 고정되어 있어 검색 속도가 빠를 수 있지만, 공간 낭비가 발생할 수 있습니다.
    
    - **사용 예시**: 전화번호(하이픈 포함 고정 길이), 우편번호, 성별(M/F) 등
        
- `VARCHAR(n)`: 가변 길이 문자열을 저장합니다. `n`은 저장할 문자의 최대 길이를 의미합니다. 실제 저장되는 문자열의 길이에 따라 공간이 할당되므로 공간 효율적입니다. `CHAR`보다 검색 속도는 느릴 수 있습니다.
    
    - **사용 예시**: 이름, 주소, 상품명, 게시글 제목 등 (가장 흔하게 사용)
        
- `TEXT`: 매우 긴 텍스트 데이터를 저장할 때 사용합니다. `VARCHAR`보다 훨씬 큰 용량을 저장할 수 있습니다.
    
    - `TINYTEXT`, `TEXT`, `MEDIUMTEXT`, `LONGTEXT` 등 DBMS에 따라 다양한 크기가 있습니다.
        
    - **사용 예시**: 게시글 내용, 상품 상세 설명 등
        
- `BLOB` (Binary Large Object): 이미지, 동영상, 오디오 파일 등 바이너리 데이터를 저장할 때 사용합니다.
    
    - `TINYBLOB`, `BLOB`, `MEDIUMBLOB`, `LONGBLOB` 등 DBMS에 따라 다양한 크기가 있습니다.
        
    - **사용 예시**: 프로필 사진, 첨부 파일 등 (일반적으로 파일 경로나 URL을 저장하고 실제 파일은 파일 시스템에 저장하는 방식이 더 효율적입니다.)
        

#### 2.3. 날짜/시간형 (Date/Time Types)

날짜와 시간을 저장하는 데 사용됩니다.

- `DATE`: 날짜(YYYY-MM-DD)만 저장합니다.
    
    - **사용 예시**: 생년월일, 주문일
        
- `TIME`: 시간(HH:MM:SS)만 저장합니다.
    
    - **사용 예시**: 회의 시작 시간, 영업 시간
        
- `DATETIME`: 날짜와 시간(YYYY-MM-DD HH:MM:SS)을 함께 저장합니다.
    
    - **사용 예시**: 게시글 작성 시간, 로그인 시간
        
- `TIMESTAMP`: 날짜와 시간(YYYY-MM-DD HH:MM:SS)을 저장하며, 특정 시점(예: 1970년 1월 1일 00:00:00 UTC) 이후의 경과 시간을 기준으로 저장되는 경우가 많습니다. 데이터가 변경될 때 자동으로 현재 시간으로 업데이트되는 기능(auto-update)을 제공하는 경우도 있습니다.
    
    - **사용 예시**: 데이터 최종 수정 시간, 이벤트 발생 시간
        

#### 2.4. 논리형 (Boolean Types)

참(True) 또는 거짓(False) 값을 저장합니다.

- `BOOLEAN` (또는 `BOOL`): 1(True) 또는 0(False)으로 저장됩니다.
    
    - **사용 예시**: 활성화 여부, 관리자 권한 여부
        

### 데이터 타입 선택의 중요성

- **저장 공간 효율성**: 데이터 타입에 따라 필요한 저장 공간이 다릅니다. 예를 들어, `INT`로 충분한 값을 `BIGINT`로 저장하면 불필요한 공간 낭비가 발생합니다.
    
- **성능**: 적절한 데이터 타입은 쿼리 처리 속도에 영향을 미칩니다. 예를 들어, 숫자형 컬럼에 문자열형 데이터를 저장하면 비교 및 연산 시 성능 저하가 발생할 수 있습니다.
    
- **데이터 무결성**: 잘못된 데이터 타입은 잘못된 데이터가 저장되는 것을 허용할 수 있습니다. 예를 들어, 나이 컬럼에 문자열 타입이 허용되면 '스무살'과 같은 유효하지 않은 값이 들어갈 수 있습니다.
    

## 3. 제약 조건 (Constraints): 데이터의 유효성 보장

**제약 조건**은 데이터베이스 컬럼에 저장될 데이터의 유효성을 보장하고, 테이블 간의 관계를 정의하는 규칙입니다. 제약 조건을 사용하면 잘못된 데이터가 입력되거나, 데이터 간의 불일치가 발생하는 것을 방지하여 데이터의 **정합성(Integrity)**을 유지할 수 있습니다.

### 주요 제약 조건 분류 및 설명

#### 3.1. NOT NULL

- **설명**: 해당 컬럼에 NULL(값이 없음)이 저장되는 것을 허용하지 않습니다. 즉, 반드시 값이 입력되어야 합니다.
    
- **목적**: 필수적인 데이터가 누락되는 것을 방지합니다.
    
- **SQL 예시**:
    
    ```
    CREATE TABLE Users (
        UserID INT NOT NULL,
        UserName VARCHAR(50) NOT NULL,
        Email VARCHAR(100)
    );
    ```
    
    위 예시에서 `UserID`와 `UserName`은 반드시 값을 가져야 하며, `Email`은 NULL이 허용됩니다.
    

#### 3.2. UNIQUE

- **설명**: 해당 컬럼의 모든 값이 서로 달라야 함을 강제합니다. 중복된 값을 허용하지 않습니다. NULL 값은 여러 번 허용될 수 있습니다 (DBMS에 따라 다름).
    
- **목적**: 특정 컬럼의 값이 유일함을 보장합니다.
    
- **SQL 예시**:
    
    ````
    CREATE TABLE Products (
        ProductID INT NOT NULL UNIQUE,
        ProductName VARCHAR(100) NOT NULL,
        ProductCode VARCHAR(20) UNIQUE
    );
    ```ProductID`와 `ProductCode`는 각각 고유한 값을 가져야 합니다.
    
    ````
    

#### 3.3. PRIMARY KEY (기본 키)

- **설명**: 테이블의 각 행(Row)을 고유하게 식별할 수 있는 하나 이상의 컬럼 집합입니다. 기본 키는 `NOT NULL`과 `UNIQUE` 제약 조건을 모두 포함합니다. 즉, 기본 키 컬럼은 NULL 값을 가질 수 없으며, 중복된 값을 가질 수도 없습니다. 테이블당 하나의 기본 키만 가질 수 있습니다.
    
- **목적**: 테이블의 각 레코드를 유일하게 식별하고, 다른 테이블과의 관계를 설정하는 데 사용됩니다.
    
- **SQL 예시**:
    
    ````
    -- 단일 컬럼 기본 키
    CREATE TABLE Students (
        StudentID INT PRIMARY KEY,
        StudentName VARCHAR(50) NOT NULL
    );
    
    -- 복합 기본 키 (여러 컬럼을 조합하여 기본 키 생성)
    CREATE TABLE Enrollments (
        StudentID INT,
        CourseID INT,
        EnrollmentDate DATE,
        PRIMARY KEY (StudentID, CourseID)
    );
    ```Students` 테이블에서는 `StudentID`가 각 학생을 고유하게 식별합니다. `Enrollments` 테이블에서는 `StudentID`와 `CourseID`의 조합이 각 수강 기록을 고유하게 식별합니다.
    
    ````
    

#### 3.4. FOREIGN KEY (외래 키)

- **설명**: 한 테이블의 컬럼(들)이 다른 테이블의 기본 키(또는 UNIQUE 키)를 참조하는 제약 조건입니다. 외래 키는 참조하는 테이블의 데이터가 참조되는 테이블의 데이터와 일관성을 유지하도록 강제합니다. 이를 **참조 무결성(Referential Integrity)**이라고 합니다.
    
- **목적**: 테이블 간의 관계를 설정하고, 관계형 데이터베이스의 핵심 원리인 참조 무결성을 보장합니다.
    
- **SQL 예시**:
    
    ````
    -- 부모 테이블 (참조되는 테이블)
    CREATE TABLE Departments (
        DeptID INT PRIMARY KEY,
        DeptName VARCHAR(50) NOT NULL UNIQUE
    );
    
    -- 자식 테이블 (참조하는 테이블)
    CREATE TABLE Employees (
        EmployeeID INT PRIMARY KEY,
        EmployeeName VARCHAR(50) NOT NULL,
        DeptID INT,
        FOREIGN KEY (DeptID) REFERENCES Departments(DeptID)
    );
    ```Employees` 테이블의 `DeptID`는 `Departments` 테이블의 `DeptID`를 참조하는 외래 키입니다. 이는 `Employees` 테이블의 모든 `DeptID` 값이 `Departments` 테이블에 실제로 존재하는 `DeptID` 값이어야 함을 의미합니다. 존재하지 않는 `DeptID`를 `Employees` 테이블에 삽입하려고 하면 오류가 발생합니다.
    
    **외래 키 옵션 (참조 무결성 동작)**:
    * `ON DELETE CASCADE`: 부모 테이블의 행이 삭제될 때, 해당 행을 참조하는 자식 테이블의 행도 함께 삭제됩니다.
    * `ON UPDATE CASCADE`: 부모 테이블의 기본 키 값이 변경될 때, 해당 키를 참조하는 자식 테이블의 외래 키 값도 함께 변경됩니다.
    * `ON DELETE SET NULL`: 부모 테이블의 행이 삭제될 때, 해당 행을 참조하는 자식 테이블의 외래 키 값을 NULL로 설정합니다. (외래 키 컬럼이 `NOT NULL`이 아니어야 함)
    * `ON DELETE RESTRICT` (기본값): 부모 테이블의 행이 자식 테이블에서 참조되고 있으면 삭제를 허용하지 않습니다.
    * `ON DELETE NO ACTION`: `RESTRICT`와 유사하나, SQL 표준에서 지연된 제약 조건 검사를 허용합니다.
    
    ````
    

#### 3.5. DEFAULT

- **설명**: 컬럼에 값을 명시적으로 입력하지 않았을 때, 자동으로 할당될 기본값을 지정합니다.
    
- **목적**: 데이터 입력 시 편의성을 제공하고, 특정 값이 자주 사용될 때 반복적인 입력을 줄여줍니다.
    
- **SQL 예시**:
    
    ````
    CREATE TABLE Orders (
        OrderID INT PRIMARY KEY,
        OrderDate DATE DEFAULT CURRENT_DATE, -- 현재 날짜를 기본값으로 설정
        OrderStatus VARCHAR(20) DEFAULT 'Pending' -- 'Pending'을 기본값으로 설정
    );
    ```Orders` 테이블에 데이터를 삽입할 때 `OrderDate`나 `OrderStatus` 컬럼에 값을 지정하지 않으면, 각각 현재 날짜와 'Pending'이 자동으로 입력됩니다.
    
    ````
    

#### 3.6. CHECK

- **설명**: 컬럼에 저장될 값의 범위를 제한하거나, 특정 조건을 만족하는 값만 허용하도록 정의합니다.
    
- **목적**: 데이터의 비즈니스 규칙을 강제하고, 유효하지 않은 데이터가 저장되는 것을 방지합니다.
    
- **SQL 예시**:
    
    ````
    CREATE TABLE Employees (
        EmployeeID INT PRIMARY KEY,
        EmployeeName VARCHAR(50) NOT NULL,
        Age INT CHECK (Age >= 18 AND Age <= 65), -- 나이가 18세 이상 65세 이하만 허용
        Salary DECIMAL(10, 2) CHECK (Salary > 0) -- 급여가 0보다 커야 함
    );
    ```Employees` 테이블에서 `Age` 컬럼에는 18세에서 65세 사이의 값만 입력할 수 있으며, `Salary` 컬럼에는 양수만 입력할 수 있습니다.
    
    ````
    

## 4. 결론: 데이터 정합성과 성능의 핵심

데이터 타입과 제약 조건은 데이터베이스 설계의 가장 기본적인 요소이자, 가장 중요한 요소입니다.

- **데이터 타입**은 데이터를 효율적으로 저장하고, 정확한 연산을 수행하며, 데이터의 의미를 명확히 하는 데 필수적입니다.
    
- **제약 조건**은 데이터의 유효성을 보장하고, 잘못된 데이터 입력으로 인한 오류를 방지하며, 테이블 간의 관계를 통해 데이터베이스의 일관성을 유지하는 데 결정적인 역할을 합니다.
    

이들을 적절하게 활용함으로써 데이터의 신뢰성을 높이고, 애플리케이션의 안정성을 확보하며, 궁극적으로 데이터베이스 시스템의 성능을 최적화할 수 있습니다. 데이터베이스를 설계하거나 다룰 때는 항상 이 두 가지 개념을 깊이 이해하고 신중하게 적용해야 합니다.