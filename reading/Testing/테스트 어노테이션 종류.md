---
tags:
  - study
  - test
  - TDD
---
# Spring Boot 테스트 어노테이션 가이드

이 문서는 Spring Boot 애플리케이션의 테스트 코드에서 자주 사용되는 어노테이션들을 설명하고, 각각의 사용 사례를 정리합니다.

## 테스트 어노테이션의 종류

Spring Boot 테스트에서 사용하는 어노테이션은 크게 세 가지 범주로 나눌 수 있습니다.

1.  **JUnit 5 어노테이션**: 자바 표준 테스트 프레임워크인 JUnit 5에서 제공하는 기본적인 테스트 어노테이션입니다.
2.  **Mockito 어노테이션**: 의존성을 격리하여 순수 단위 테스트를 작성할 때 사용하는 Mock 객체 관련 어노테이션입니다.
3.  **Spring Boot 테스트 어노테이션**: 스프링 컨테이너와 기능을 활용하여 테스트를 진행하기 위한 어노테이션입니다.

---

## 1. JUnit 5 기본 어노테이션

테스트 코드를 작성하기 위한 가장 기본적인 어노테이션들입니다.

### `@Test`

메소드가 테스트를 수행하는 코드를 포함하고 있음을 JUnit에 알립니다. 이 어노테이션이 붙은 메소드는 테스트 실행 시 호출됩니다.

```java
import org.junit.jupiter.api.Test;

class MyTest {
    @Test
    void myTestMethod() {
        // 테스트 로직
    }
}
```

### `@DisplayName("설명")`

테스트 클래스나 메소드에 사람이 읽기 좋은 이름을 붙여줄 때 사용합니다. 테스트 결과창에 이 이름이 표시되어 테스트의 목적을 쉽게 파악할 수 있습니다.

```java
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

@DisplayName("포인트 컨트롤러 테스트")
class PointControllerTest {

    @Test
    @DisplayName("포인트 조회 API는 성공적으로 응답해야 한다")
    void getPoint() {
        // ...
    }
}
```

---

## 2. Mockito 어노테이션 (단위 테스트)

외부 의존성을 차단하고 특정 클래스나 메소드의 로직만 순수하게 검증하는 **단위 테스트(Unit Test)**에서 주로 사용됩니다. 스프링 컨테이너를 구동하지 않아 테스트 속도가 매우 빠릅니다.

### `@ExtendWith(MockitoExtension.class)`

JUnit 5 환경에서 Mockito 프레임워크를 통합하기 위해 클래스 레벨에 선언합니다. 이 어노테이션이 있어야 `@Mock`, `@InjectMocks` 등의 Mockito 어노테이션이 올바르게 동작합니다.

### `@Mock`

가짜 객체(Mock Object)를 생성합니다. 테스트 대상이 의존하는 객체를 실제 객체 대신 가짜로 만들어, 특정 상황을 시뮬레이션 할 수 있습니다.

### `@InjectMocks`

테스트 대상 객체를 생성하고, `@Mock`으로 생성된 가짜 객체들을 해당 객체에 자동으로 주입합니다.

**사용 예시: `PointServiceImplTest.java`**
```java
@ExtendWith(MockitoExtension.class) // 1. Mockito 활성화
@DisplayName("PointService 구현체 단위 테스트")
class PointServiceImplTest {

    @Mock // 2. 가짜 Repository 생성
    private UserPointRepository userPointRepository;

    @InjectMocks // 3. 테스트 대상에 가짜 객체 주입
    private PointServiceImpl pointService;

    @Test
    @DisplayName("존재하지 않는 유저의 포인트 조회 시 0포인트를 반환한다")
    void getPointForNonExistentUser() {
        // given: userPointRepository.findById(1L)이 호출되면, 미리 정해진 결과를 반환하도록 설정 (Stubbing)
        given(userPointRepository.findById(1L)).willReturn(UserPoint.empty(1L));

        // when
        UserPoint result = pointService.getPoint(1L);

        // then
        assertThat(result.point()).isEqualTo(0L);
    }
}
```

---

## 3. Spring Boot 테스트 어노테이션 (통합/슬라이스 테스트)

실제 스프링 컨테이너(ApplicationContext)를 메모리에 구동하여 테스트를 진행합니다.

### 가. 슬라이스(Slice) 테스트: 웹 계층

컨트롤러와 같은 특정 계층(Layer)만 잘라내어 테스트합니다. 웹 계층 테스트에 주로 사용됩니다.

#### `@WebMvcTest(TestTargetController.class)`

-   웹과 관련된 빈(`@Controller`, `@RestController`, `Filter`, `WebMvcConfigurer` 등)만 스캔하여 메모리에 올립니다.
-   `@Service`, `@Repository` 같은 비즈니스/데이터 계층의 빈은 등록하지 않습니다.
-   괄호 안에 테스트할 컨트롤러 클래스를 명시하여 테스트 범위를 최소화하고 속도를 높입니다.

#### `@MockBean`

-   `@WebMvcTest` 환경에서는 서비스 계층이 빈으로 등록되지 않으므로, 컨트롤러가 의존하는 서비스 객체는 가짜 빈(Mock Bean)으로 만들어야 합니다.
-   `@MockBean`은 스프링 컨테이너에 가짜 객체를 빈으로 등록해주는 역할을 합니다.

#### `@Autowired`

-   스프링 컨테이너에 등록된 빈을 주입받을 때 사용합니다.
-   `@WebMvcTest` 환경에서는 `MockMvc` 객체를 주입받아, 실제 서버를 띄우지 않고도 API 요청을 보내고 응답을 검증할 수 있습니다.

**사용 예시: `PointControllerTest.java`**
```java
@WebMvcTest(PointController.class) // 1. 웹 계층 테스트 + 대상 컨트롤러 지정
@DisplayName("PointController 웹 레이어 테스트")
class PointControllerTest {

    @Autowired // 3. MockMvc 주입
    private MockMvc mockMvc;

    @MockBean // 2. Controller가 의존하는 Service를 가짜 빈으로 등록
    private PointService pointService;

    @Test
    @DisplayName("포인트 조회 API 테스트")
    void getPoint() throws Exception {
        // given: pointService.getPoint(1L)가 호출되면, 특정 UserPoint 객체를 반환하도록 설정
        given(pointService.getPoint(1L)).willReturn(new UserPoint(1L, 1000L, System.currentTimeMillis()));

        // when & then: MockMvc를 사용해 /point/1 로 GET 요청을 보내고, 응답 상태와 JSON 본문을 검증
        mockMvc.perform(get("/point/{id}", 1L))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.point").value(1000L));
    }
}
```

### 나. 통합(Integration) 테스트

애플리케이션의 모든 빈을 스프링 컨테이너에 등록하여 실제 운영 환경과 가장 유사한 환경에서 테스트합니다.

#### `@SpringBootTest`

-   프로젝트에 정의된 모든 빈(`@Component`, `@Service`, `@Repository`, `@Controller` 등)을 스캔하여 스프링 컨테이너를 구동합니다.
-   여러 계층에 걸친 전체 비즈니스 시나리오를 검증하기에 적합합니다.
-   모든 것을 로드하므로 테스트 실행 시간이 가장 오래 걸립니다.

#### `@AutoConfigureWebMvc`

-   `@SpringBootTest`는 기본적으로 `MockMvc`를 자동으로 설정해주지 않습니다.
-   통합 테스트 환경에서 API 호출까지 테스트하고 싶을 때 이 어노테이션을 추가하여 `MockMvc`를 활성화하고 주입받을 수 있도록 합니다.

**사용 예시: `PointIntegrationTest.java`**
```java
@SpringBootTest // 1. 모든 빈을 로드하여 통합 테스트 환경 구성
@AutoConfigureWebMvc // 2. MockMvc 사용 설정
@DisplayName("포인트 시스템 통합 테스트")
class PointIntegrationTest {

    @Autowired // 3. MockMvc 주입
    private MockMvc mockMvc;

    @Autowired // 실제 서비스 빈도 주입 가능
    private PointService pointService;

    @Test
    @DisplayName("포인트 충전 후 조회 시나리오 테스트")
    void chargeAndGetPointScenario() throws Exception {
        // given: 포인트 500 충전 요청
        mockMvc.perform(patch("/point/{id}/charge", 1L).content("500").contentType(MediaType.APPLICATION_JSON));

        // when & then: 포인트 조회 시 500이 반환되는지 검증
        mockMvc.perform(get("/point/{id}", 1L))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.point").value(500));
    }
}
```

---

## 요약: 테스트 전략

| 어노테이션 조합                                           | 테스트 종류                  | 특징                                                             | 속도     |
| -------------------------------------------------- | ----------------------- | -------------------------------------------------------------- | ------ |
| `@ExtendWith(MockitoExtension.class)` + `@Mock`... | **단위(Unit) 테스트**        | 스프링 컨테이너 없이, 순수 자바 객체로 특정 클래스의 로직만 검증.                         | **빠름** |
| `@WebMvcTest` + `@MockBean`                        | **슬라이스(Slice) 테스트**     | 웹 계층(Controller)만 테스트. 서비스/리포지토리는 가짜(Mock)로 대체. API 명세 검증에 유용. | **보통** |
| `@SpringBootTest` + `@AutoConfigureWebMvc`         | **통합(Integration) 테스트** | 모든 빈을 다 띄워서 실제 환경처럼 테스트. 여러 계층에 걸친 전체 시나리오 검증.                 | **느림** |

일반적으로는 빠른 **단위 테스트**로 각 클래스의 로직을 꼼꼼히 검증하고, **슬라이스 테스트**로 Controller의 요청/응답 명세를 확인한 뒤, 마지막으로 여러 기능이 엮인 핵심 시나리오들을 **통합 테스트**로 검증하는 '테스트 피라미드' 전략을 권장합니다.