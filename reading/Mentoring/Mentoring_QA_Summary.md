# 멘토링 세션 질문 및 답변 정리

아래는 2025년 7월 15일 화요일 오후 9시 2분에 진행된 멘토링 세션에서 참석자들이 질문한 내용과 코치가 제공한 상세한 답변을 질문-답변 구조로 정리한 내용입니다.

## 질문 1: 상태 다이어그램과 시퀀스 다이어그램의 차이점
**참석자**: 승준  
**질문**: 상태 다이어그램과 시퀀스 다이어그램을 비슷한 맥락으로 봐야 하나요?  
**코치의 답변**:  
- **상태 다이어그램**: 시간과 무관하게 상태의 전환에 초점을 맞춘 다이어그램입니다. 예를 들어, 재고가 있다가 없다가, 누가 빌려갔다가, 대출 가능 상태로 바뀌는 등의 순환 구조를 표현합니다. 순서보다는 상태 변화의 가능성에 집중합니다.
- **시퀀스 다이어그램**: 시간의 흐름을 위에서 아래로 표현합니다. 예를 들어, 셔프 호출 후 프리페어스 호출, 반환, 모디파일 호출, 반환, 기분 호출 등의 시간 순서를 나타냅니다. 따라서 시퀀스 다이어그램은 프리페이어스로 시작해 밴드 리졸트로 끝나는 시간 순서의 호출 흐름을 보여줍니다.
- **결론**: 상태 다이어그램은 시간과 무관한 상태 변화를, 시퀀스 다이어그램은 시간 순서에 따른 흐름을 나타내므로 다르게 접근해야 합니다. 질문이 있으면 바로 말씀해 주세요.

## 질문 2: 테이블 설계에서 외래 키 사용 여부
**참석자**: 승준  
**질문**: 테이블 설계 및 구현 단계에서 외래 키를 사용하는 것이 좋은지 궁금합니다.  
**코치의 답변**:  
- 실무에서는 외래 키를 지정하는 경우가 드뭅니다. 운영 중 데이터를 임의로 추가하거나 삭제할 때 외래 키가 제약을 걸어 불편함을 초래하기 때문입니다. 예를 들어, 데이터를 추가할 때 순서 제약이 생겨 작업이 복잡해질 수 있습니다.
- 외래 키는 논리적으로만 사용되며, 실제로 데이터베이스에 외래 키 제약을 걸지는 않는 것이 일반적입니다.
- 추가 질문(참석자 3): ORM 레벨에서 외래 키를 설정하는 경우가 있나요?  
  - **코치의 답변**: ORM 레벨에서도 외래 키를 잘 설정하지 않습니다. 대신, 토스 같은 곳에서는 테이블에 PK임을 코멘트로 남겨 추적 가능성을 유지합니다. 예를 들어, ‘아이디’라는 키워드는 PK에만 사용하도록 팀 내 컨벤션을 정합니다.
  - JPA의 연관 관계는 복잡성과 러닝 커브가 높아 제한적으로 사용됩니다. 해외에서는 JPA의 복잡성에 대한 부정적인 시각이 늘고 있으며, 네이버의 정상혁 같은 개발자는 JPA 대신 JDBC 플러스 같은 중간 기술을 사용하기도 합니다.
  - 주크(Jooq) 같은 기술도 대안으로 떠오르고 있지만, 공부보다는 키워드 정도로만 알아두는 것을 추천합니다.

## 질문 3: 과제의 오버 엔지니어링 문제
**참석자**: 우영  
**질문**: 과제가 기획 설계에 가까워 문서 작성이 과도해지는 경향이 있습니다. 현재 프로젝트는 MSA와 서버로 접근했는데, 실제로 MSA로 구현되나요?  
**코치의 답변**:  
- **우영의 추가 설명**: 상품, 주문, 결제 관련 도메인을 생각하다 보니 장바구니, 주문서, 배송지 정보 등이 떠올라 도메인을 한정해야겠다고 생각했습니다.
- **코치의 답변**: 이는 정상적인 접근입니다. 하지만 프로젝트를 통짜 도메인으로 보는 시각을 추천합니다. MSA로 나누면 오버 엔지니어링에 빠질 위험이 있습니다. 개발자는 비즈니스 가치를 제공하는 데 집중해야 하며, DDD나 헥사고날 아키텍처 같은 접근은 오버 엔지니어링으로 이어질 수 있습니다.
- 면접관은 오버 엔지니어링을 선호하지 않으므로, 이력서에서 DDD나 헥사고날 같은 키워드는 빼는 것이 좋습니다. 통짜 도메인으로 접근해 적절한 기술 선택을 보여주는 것이 면접에서 유리합니다.
- **추가 질문(민정)**: 오버 엔지니어링 없이 통짜 도메인으로 보라는 의미가 잘 이해되지 않습니다.
  - **코치의 답변**: 예를 들어, 사용자 팀, 주문 팀, 결제 팀이 있다고 가정하면, 각 팀이 독립적으로 작업하면 도메인 이벤트로 통신하며 의존성을 줄입니다. 하지만 통짜 도메인으로 보면 한 사람이 모든 것을 관리하므로 도메인 이벤트가 필요 없습니다. 이렇게 하면 오버 엔지니어링을 피하고 면접관에게 간결한 설계 능력을 어필할 수 있습니다.

## 질문 4: 캐싱과 동시성 고려
**참석자**: 우영  
**질문**: 프로젝트 고도화에서 캐싱과 동시성을 고려해야 합니다. Redis나 Kafka를 사용하지 않으면 나중에 고생할까요?  
**코치의 답변**:  
- Redis나 Kafka 같은 특정 기술을 시퀀스 다이어그램에 넣으면 구현에 강결합됩니다. 대신 인터페이스를 두어 확장성을 열어두는 설계를 추천합니다.
- 과제에서는 5~6주 차에 Redis나 Kafka가 등장하더라도 추상화를 통해 유연하게 설계해야 합니다.
- **우영의 추가 의견**: 확장성을 고려해 여지를 두고 설계해야 할 것 같습니다.
  - **코치의 답변**: 맞습니다. 인터페이스를 통해 기술 결합을 최소화하면 코드 변경 없이 새로운 기술을 적용할 수 있습니다.

## 질문 5: 시퀀스 다이어그램의 액터 분리 기준
**참석자**: 현성  
**질문**: 시퀀스 다이어그램 작성 시 액터를 어떤 기준으로 나누는 것이 적절한가요? 너무 상세하면 유지보수가 어렵고, 너무 뭉뚱그리면 설계 의도를 전달하기 어렵습니다.  
**코치의 답변**:  
- 이상적인 시퀀스 다이어그램은 높은 추상화 수준에서 그리는 것이 좋습니다. 예를 들어, 컨트롤러 호출이나 메서드 호출을 상세히 그리면 메서드명 변경 시 비효율적입니다.
- 실무에서는 서비스 간 호출 정도의 수준(예: MSA 기준)에서 그리는 것이 적절합니다. 클래스나 메서드 세부사항은 피해야 변경에 취약하지 않습니다.
- 연습 단계에서는 상세히 그려보며 경험을 쌓는 것이 중요하지만, 실무에서는 추상화된 수준에서 그리는 것이 효율적입니다.

## 질문 6: 설계 단계에서 외부 요소 제외 여부
**참석자**: 지수  
**질문**: 설계 단계에서 요구사항 명세나 시퀀스 다이어그램 작성 시 복잡하거나 특정 기술이 필요한 기능을 배제해야 하나요?  
**코치의 답변**:  
- 연습 단계에서는 세부적으로 그려보는 것이 좋지만, 실무에서는 추상화된 수준에서 그리는 것이 적합합니다. 예를 들어, 유저 DB나 캐시를 간단히 표시하고 세부 기술은 생략합니다.
- 큰 맥락에서 서비스 간 협력이 필요할 때 시퀀스 다이어그램을 작성하며, 혼자 개발하는 경우라면 굳이 그릴 필요는 없습니다.
- 연습 과정에서는 다양한 다이어그램을 그려보며 학습하는 것이 중요합니다.

## 질문 7: 동시성 제어 설계
**참석자**: 용준  
**질문**: 이번 주차 과제에서 Kafka나 Redis를 고려한 설계보다 JPA 수준의 동시성을 고려한 설계를 추천하시나요?  
**코치의 답변**:  
- 동시성 제어는 특정 기술(Redis, Kafka, DB)에 의존하지 않고 추상화된 수준에서 설계하는 것이 좋습니다. 예를 들어, 낙관적 락, 비관적 락, Redis의 Setnx, 분산 락 등을 단계적으로 배워가며 확장성을 열어둡니다.
- 실무에서는 서버가 여러 대일 경우 JVM 레벨의 락(ReentrantLock, Synchronized)은 동작하지 않으므로 분산 락을 사용합니다.
- DB 락은 DB가 장애의 주요 원인(80%)이므로 피하는 것이 좋습니다. Redis의 Setnx는 싱글 스레드 동작으로 동시성을 보장하며, 대부분의 서비스에서 충분합니다. 분산 락은 필요 시 사용하면 됩니다.
- Redis의 싱글 스레드 특성상 여러 요청이 순차적으로 처리되므로 동시성 제어가 가능합니다.

## 질문 8: 패키지 구조와 비즈니스 표현력
**참석자**: (구체적인 이름 미지정)  
**질문**: 패키지 구조를 어떻게 설계하면 비즈니스 표현력이 높아질까요?  
**코치의 답변**:  
- 좋은 패키지 구조는 직관적이고 가독성이 높아야 합니다. 예를 들어, 에러 핸들링이나 Redis 설정이 어디 있는지 직관적으로 알 수 있어야 합니다.
- 패키지 구조의 적절성을 확인하려면 팀원에게 코드를 보여주고 특정 파일을 찾도록 요청해 보세요. 쉽게 찾으면 구조가 직관적이고 표현력이 좋은 것입니다.
- 비즈니스 표현력이 높은 코드는 서비스 계층에서 기능(예: 친구 목록 조회)을 명확히 드러내고, 과도한 추상화(BTO, 인터페이스 분리)를 피해야 합니다.
- 과도한 추상화는 관리 비용을 늘리므로, 확장성이 필요 없는 경우 인터페이스를 도입하지 않는 것이 좋습니다.

## 질문 9: ERD 작성 시기
**참석자**: (구체적인 이름 미지정)  
**질문**: ERD는 언제 작성하는 것이 적절한가요?  
**코치의 답변**:  
- ERD는 너무 일찍 작성하기보다는 개발 중 임시 코드로 구현을 테스트한 후 완성하는 것이 좋습니다. 예를 들어, 인메모리 형태로 엔티티를 작성해 필드명이나 구조를 정한 뒤 ERD로 최종 정리합니다.
- 큰 기업에서는 DBA에게 테이블/컬럼 추가를 요청하는데, 초기 ERD가 구현과 맞지 않으면 수정 요청이 빈번해져 DBA와의 마찰이 생길 수 있습니다.
- 따라서 개발 초기에 임시 코드로 구현을 검증한 후 ERD를 완성하는 접근이 효율적입니다.

## 질문 10: 코드에서 약어 사용
**참석자**: 윤호  
**질문**: 패키지나 코드에서 과한 약어 사용에 대해 어떻게 생각하시나요?  
**코치의 답변**:  
- 약어는 팀 내에서 모두가 이해하는 경우(예: HP가 ‘하드 프로덕트’로 정의된 경우)에만 사용해도 괜찮습니다. 하지만 새로운 팀원이 이해하지 못할 수 있으므로 풀어 쓰는 것이 일반적입니다.
- 스프링 같은 프레임워크는 클래스명(예: AbstractNamedValueArgumentResolver)을 줄이지 않고 명확히 작성합니다. 글로벌하게 통용되는 약어(예: AOT)나 비즈니스 용어(예: Calls)는 사용해도 괜찮습니다.
- 클래스명 길이 제한(예: 15자)은 비현실적이며, 소통에 불편을 초래할 수 있습니다. 적당히 줄이는 것은 괜찮지만, 과도한 약어는 피하는 것이 좋습니다.

## 질문 11: 클래스 다이어그램의 필요성
**참석자**: (구체적인 이름 미지정)  
**질문**: 클래스 다이어그램에 대해 어떻게 생각하시나요?  
**코치의 답변**:  
- 클래스 다이어그램은 구현과 강결합되어 필드명 변경 시 수정이 필요하므로 실무에서 자주 사용되지 않습니다(코치 본인도 6년 전 이후 사용하지 않음).
- 계층 간 관계나 도메인 모델링 수준에서는 유용할 수 있지만, 세부적인 클래스 다이어그램은 피하는 것이 좋습니다.
- 이번 과제에서는 클래스 다이어그램을 그리지 않아도 됩니다. 대신 ERD, 시퀀스 다이어그램, API 설계 문서(예: Swagger 기반)에 집중하세요.

## 질문 12: 클린 아키텍처와 레이어드 아키텍처 비교
**참석자**: (구체적인 이름 미지정)  
**질문**: 클린 아키텍처의 유스케이스, 레포지토리, 어댑터와 레이어드 아키텍처(컨트롤러, 서비스, 레포지토리)의 차이점은 무엇인가요? 어댑터는 레포지토리 구현체를 폴더만 바꾼 느낌 아닌가요?  
**코치의 답변**:  
- 클린 아키텍처의 포트와 어댑터 패턴은 확장성을 고려한 설계입니다. 포트는 인터페이스로, 외부로 나가는 수단(예: DB, Redis)을 정의합니다. 어댑터는 포트의 구현체(예: DB 레포지토리, Redis 레포지토리)로, 구현을 갈아 끼울 수 있게 합니다.
- 예: 유저 포트 인터페이스를 두고, DB 어댑터(DB 레포지토리)나 Redis 어댑터(Redis 레포지토리)로 구현 가능. 하지만 실무에서는 DB에서 Redis로 전환하는 경우가 드물어 오버 엔지니어링으로 간주될 수 있습니다.
- 클린 아키텍처의 핵심은 의존성 방향입니다. 모든 의존성은 안쪽(유스케이스, 엔티티)으로 향해야 하며, 컨트롤러나 프레임워크(스프링)를 외부로 둡니다. 스프링의 서비스는 프레임워크 레벨이므로 클린 아키텍처에서는 별도 빈으로 관리해 의존성을 유지합니다.
- 레이어드 아키텍처의 레포지토리와 클린 아키텍처의 어댑터는 역할이 비슷하지만, 폴더 구조와 의존성 방향에서 차이가 있습니다. 클린 아키텍처는 파일 관리와 확장성을 위해 계층을 더 명확히 나눕니다.

## 질문 13: 자바 트렌드 변화
**참석자**: (구체적인 이름 미지정)  
**질문**: 자바의 트렌드가 어떻게 바뀌고 있나요?  
**코치의 답변**:  
- 자바 언어의 아키텍트(자바 원어 설계자)가 발표한 바에 따르면, 자바는 과거 객체 지향을 강조했지만, MSA 시대에서는 데이터 주고받음이 중요해졌습니다.
- 이를 위해 자바는 레코드 클래스를 추가해 데이터 오리엔티드 프로그래밍을 강화했습니다. 객체 지향은 약점이 되고, 데이터 중심 설계가 중요해지고 있습니다.
- 자바는 앞으로도 데이터 처리와 관련된 혁신을 준비 중이니 관련 영상을 참고하면 좋습니다.

## 추가 코치의 조언
- **멘토링 노트 간소화**: 현재 멘토링 노트가 너무 방대해 작성 부담이 큽니다. 팀원들과 논의해 간소화 방안을 마련할 예정입니다.
- **과제 우선순위**: ERD, 시퀀스 다이어그램, API 설계 문서(Swagger 기반)에 집중하세요. 상태 다이어그램과 플로우 차트는 커머스 프로젝트에 적합하지 않으므로 생략 가능합니다. 시퀀스 다이어그램은 추상화된 수준(예: 대기열, 서비스 간 호출)으로 그리되, 연습 삼아 상세히 그려보는 것도 유익합니다.
- **목 API**: 과제에서 목 API를 활용하는 것도 추천합니다.
- **설계 문서**: 실무에서는 설계 문서(특히 시퀀스 다이어그램)를 상세히 그리기보다는 운영용으로 간단히 작성합니다. 연습 단계에서는 다양한 다이어그램을 그려보며 경험을 쌓으세요.