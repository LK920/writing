# 2주차 발제 상세 정리

## 1. 1주차 과제 리뷰
### 1.1 과제 제출 피드백
- 참석자들의 과제 제출 수준이 전반적으로 훌륭했으며, 코치진은 100점을 목표로 꼼꼼히 피드백 제공.
- **피드백에 대한 조언**:
  - 피드백이 많더라도 부정적으로 보지 말고 개선 기회로 삼아야 함. 코치진은 세심히 검토하며 최대한 많은 개선점을 제시.
  - 피드백이 적은 경우, 잘 수행한 것으로 간주 가능.
  - 이해 안 되는 피드백은 다음 주 멘토링이나 개별 연락으로 확인 권장.
  - 3~4주차에는 더 많은 피드백 예상되므로, 지금부터 마음 단단히 준비.
- **명예의 전당**:
  - **은솔**:
    - **인터페이스 활용**: 서비스와 인프라 분리, 데이터 저장소 확장(인메모리 → 데이터베이스)에 유리한 설계.
    - **객체 지향적 사고**: 포인트 충전/차감 책임을 적절히 배분.
    - **테스트**: 네스티드 구조로 포인트 API 테스트를 세분화(정상 충전, 최대 잔고 초과 예외 등). 경계값(0원, 1원, -100원 등) 테스트와 문서화 우수.
  - **서희**:
    - 객체 지향적 코드와 클래스 책임 검증 우수.
    - 커밋 단위 명확히 분리, 작업 내용 파악 용이.
    - 생성자 예외 처리와 테스트 범위(경계값 포함) 꼼꼼히 작성.
    - 리뷰 포인트 명확히 제시, 코치와 소통 잘함.
  - **세훈**:
    - 동시성 분석(애플리케이션 레벨, 데이터베이스, 분산 환경) 상세히 수행.
    - 타입스크립트/자바스크립트 활용, 성능과 안정성 트레이드오프 조사 우수.
    - 요구사항에 맞춰 동시성 기법 3가지로 분류해 분석.

### 1.2 1주차 학습 목표
- **테스트 개념**:
  - 유닛 테스트, 통합 테스트, E2E 테스트 이해.
  - 테스트 대역(목, 스터, 페이크 객체)의 사용 시점 학습.
  - 예: 실제 객체 대신 테스트 대역 사용 여부 판단.
- **좋은 테스트의 중요성**:
  - **FIRST 원칙**: 리피터블(반복 가능), 셀프 밸리데이팅(자체 검증), 인디펜던트(독립적) 테스트 작성.
  - 테스트는 서비스 안전성 보장, 리팩토링 시 문제 감지해야 함.
  - 100% 커버리지보다 핵심 기능에 집중한 50%의 좋은 테스트가 더 가치 있음.
  - 예: 리팩토링 후 테스트 실패 시 문제 시그널 제공.
- **TDD (테스트 주도 개발)**:
  - 테스트 코드 작성 전 요구사항과 테스트 케이스 분석 필수.
  - 입력값에 따른 예외/정상 동작 분석, 요구사항 분석 능력 중요.
  - 예: 0원 충전 시 예외, 1원 충전 시 정상 동작 등 경계값 테스트.

### 1.3 협업과 이력서 작성
- **상대방 입장 고려**:
  - 과제 제출, 코드 리뷰, 이력서 작성 시 상대방(코치, 면접관) 관점에서 접근.
  - 예: 이력서는 공통 템플릿 대신 회사 JD에 맞춰 차별화(회사 매력 포인트, 적합성 강조).
  - 면접관은 공통 템플릿 이력서에서 지원자의 진정성 부족 감지.
- **셀프 코드 리뷰**:
  - 코드 리뷰 요청 전, 불필요한 커밋이나 잘못된 파일(.idea 등) 포함 여부 확인.
  - 예: 과제 제출 시 변경 사항 명확히 제시, 제3자 시선에서 보기 쉽게 정리.
- **협업과 이직**:
  - 이직은 연애와 유사: 상대방(회사)이 원하는 것을 고민하고 준비.
  - 예: 지원 회사 JD 분석, 이력서에 회사와의 적합성 강조.
  - 과제 제출도 협업과 유사: 코치가 쉽게 평가할 수 있도록 준비.

## 2. 2주차 과제 상세
### 2.1 목표
- **요구사항 분석**: 기능적(예: API 기능) 및 비기능적(예: 트래픽 처리) 요구사항 명확히 분석.
- **확장 가능 설계**: 유지보수와 확장이 쉬운 설계 고민.
- **좋은 테스트**: 테스트 코드 작성 및 가능하면 TDD 적용.
- **견고한 서버**: 동시성 제어와 유연한 애플리케이션 서버 구축.

### 2.2 시나리오
#### 2.2.1 이커머스 서비스
- **API (5개)**:
  - 잔액 충전/조회.
  - 상품 조회.
  - 주문 결제.
  - 쿠폰 발급.
  - 인기 판매 상품 조회(판매량 기준 추천).
- **고려사항**:
  - 동시성 이슈: 여러 사용자 동시 주문 시 재고 관리.
  - 다중 인스턴스 요청 처리 시 문제 없어야 함.
  - 확장 가능한 코드 설계(예: 데이터베이스 도입 대비).
- **특징**: 익숙한 서비스로 이해 쉬움, 팀원 간 협업 및 의견 교환 권장.

#### 2.2.2 콘서트 예약 서비스
- **API (5개)**:
  - 대기열 토큰 발급.
  - 예약 가능 날짜/좌석 조회.
  - 좌석 예약 요청.
  - 잔액 충전/조회.
  - 결제(대기열 완료 후).
- **고려사항**:
  - 대기열 관리: 만 명 이상 사용자 처리(예: 3,000번째 대기 표시).
  - 동시성 제어: 여러 서버 인스턴스 간 동시 요청 처리.
  - 확장 가능한 애플리케이션 구축.
- **특징**: 대기열 중심 서비스, 요구사항 구현 정보 제공.

#### 2.2.3 시나리오 선택 팁
- 팀원들과 논의해 시나리오 선택, 프렌즈/학습 메이트의 경험 기반 조언 활용.
- 이커머스와 콘서트 예약은 서로 다른 책임(SRP 위반 우려)으로, 단일 프로젝트로 병합 비추천.
- 예: 두 시나리오 동시 진행은 가능하나 별도 프로젝트로 관리 권장.
- 맛집 검색 시나리오도 있으나 선택 비율 낮음, 이커머스/콘서트 예약 권장.

### 2.3 설계 문서
- **시퀀스 다이어그램**:
  - 시스템 간 상호작용 표현, 핵심 기능 1~2개에 집중(예: 주문/결제 흐름, 역등성 보장).
  - 모든 API(5개) 작성은 비효율적, 상품 조회 등 단순 기능 제외.
  - 이직 시 요구되는 문서, 현업에서 점차 비중 감소하나 학습 필요.
- **클래스 다이어그램**:
  - 객체 지향적 설계 기반, 도메인 모델링 반영.
  - 클래스 간 관계(예: 은솔의 객체 체계) 명확히 표현.
- **ER 다이어그램**:
  - 테이블 간 관계, PK, 클러스터링 인덱스, 정규화/반정규화 고려.
  - 구현 전 인메모리 설계 후 최종 ERD 작성 권장(구현 후 변경 빈번).
  - 예: 필드명 미리 정하지 않고 코드 베이스 완성 후 ERD 설계.
- **상태 다이어그램**:
  - 상태 전이 표현(예: 회원 가입 → 로그인 → 휴면 계정 → 탈퇴).
  - 게임(레벨업, 직업 변경)이나 회원 관리 시 유용.
  - 예: 토스 회원 관리(휴면 계정, SMS 인증, 기기 변경 케이스).
- **API 명세**:
  - 프론트엔드와 협업 위해 공통화된 스펙(스웨거 UI, 레스트 독스) 사용.
  - 더미 데이터 제공(목 API)으로 프론트엔드 병렬 작업 지원.
  - 예: 잔액 10,000원 초과 불가, 100원 단위 제한 명세화.

### 2.4 작업 플로우
1. **요구사항 분석**:
   - **기능적 요구사항**: 예: 대기열 10만 명 지원, API 기능 구현.
   - **비기능적 요구사항**: 트래픽 처리, 암호화 등.
   - 불명확한 요구사항은 기획자/개발자 역할로 구체화(예: 대기열 최대 인원).
2. **더미 데이터 제공**:
   - 목 API로 프론트엔드에 응답 데이터 제공, 병렬 개발 지원.
   - 예: 서비스 계층 비어 있어도 API 스펙 기반 응답 제공.
3. **설계 문서 작성**:
   - 시퀀스 다이어그램, ERD, 클래스 다이어그램, 상태 다이어그램 작성.
   - 스웨거/레스트 독스로 API 문서화.
4. **아키텍처 패턴 고민**:
   - 레이어드, 헥사고날 등 패턴 선택, SOLID 원칙(SRP, DIP) 적용.
   - 예: 단일 책임 원칙(SRP)은 변경 이유 하나로 제한, 고수준/저수준 의존성 관리(DIP).
5. **셀프 체크리스트**:
   - 요구사항 구체화 및 작업 단위 정리.
   - RESTful 설계: HTTP 메소드(GET, POST 등), 패스, 응답 스테이터스(200, 400 등) 적절성.
   - 협업 관점: 프론트엔드 개발자 편의 고려(더미 데이터 제공).
   - KPT 회고: 과제 진행 중 좋았던 점, 아쉬운 점, 개선 계획 정리.

### 2.5 평가 기준
- **스텝 3**:
  - 요구사항 분석, 설계 문서(시퀀스 다이어그램, ERD, 클래스 다이어그램 등) 완성도.
- **스텝 4**:
  - 목 API 작성, 스웨거/레스트 독스 기반 API 문서화.
  - RESTful 설계 준수(HTTP 메소드, 패스, 스테이터스).
- **베스트 프랙티스**:
  - 요구사항 분석 정확성.
  - 객체 지향적/도메인 중심 설계, 책임 분리.
  - 시퀀스 다이어그램, ERD, API 스펙의 완성도 및 RESTful 준수.
  - 커밋 단위 명확성, 코드/문서 가독성.

## 3. 추가 조언
- **설계와 구현의 균형**:
  - 설계는 요구사항 분석 수단, 구현과 불일치 시 수정 가능(에자일 방식).
  - 예: ERD는 구현 후 조정 빈번, 인메모리 설계 후 최종 작성 권장.
- **팀 협업**:
  - 팀원, 프렌즈/학습 메이트와 시나리오 선택 및 설계 논의.
  - 코치진의 멘토링, QnA 적극 활용(예: 5시 20분 QnA 세션).
- **3주차 연계**:
  - 2주차 설계를 기반으로 3주차에서 컨트롤러, 서비스, 레포지토리 등 코드 작성.
  - 이후 부하 테스트, 레디스/카프카 도입 등 확장.
- **TDD 선택적 적용**:
  - 프로덕션 코드 미포함으로 테스트 코드 작성은 선택 사항.
  - TDD 적용 시 요구사항 분석과 테스트 케이스 설계 강화.
- **현업 적용**:
  - 설계 비중이 코드 작성보다 클 수 있음(1:9 비율 아님).
  - 명확한 설계는 AI 활용 시에도 중요, 요구사항 명확히 전달 필요.
- **코드 패턴**:
  - 팀원 간 논의로 유지보수/가독성 좋은 패턴 선택.
  - SOLID 원칙(특히 SRP: 단일 책임, DIP: 의존성 역전) 고민.
  - 예: 고수준 모듈이 저수준 모듈 의존 시 사이드 이펙트 최소화.

## 4. QnA
- **질문 1**: 설계 주제인데 로직도 작성해야 하나요?
  - 스텝 3은 설계 문서(ERD, 시퀀스 다이어그램) 중심, 스텝 4는 목 API와 문서화.
  - 실제 로직 구현은 3주차부터, 이번 주차는 설계와 더미 데이터 제공 집중.
- **질문 2**: 3주차는 2주차 프로젝트를 이어가나요?
  - 2주차 설계를 기반으로 3주차에서 코드/테스트 작성, 이후 레디스/카프카 도입.
- **질문 3**: 이커머스와 콘서트 예약 모두 진행 가능한가요?
  - 가능하나, 서로 다른 책임으로 별도 프로젝트 관리 권장(SRP 위반 방지).
  - 두 시나리오 병합 시 복잡도 증가, 취소 가능성 고려.