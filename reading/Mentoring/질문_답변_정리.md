# Redis 기반 시스템 설계 Q&A 정리

**일시**: 2025년 8월 16일 (토) 오후 5:20  
**주제**: Redis 기반 랭킹 시스템 및 비동기 시스템 설계 관련 질문 답변  
**목표**: 질문별 답변을 체계적으로 정리하고, 학습에 필요한 Redis 관련 키워드 설명 추가  

---

## 1. 질문 및 답변

### 1.1. 김지유: Sorted Set으로 3일간 랭킹 구현 가능 여부
**질문**:  
스텝 13 과제에서 Sorted Set을 이용하면 3일간 랭킹을 뽑기 어려울 것 같습니다. Sorted Set을 사용해서 3일간 랭킹을 적용할 수 있는 방법이 있을까요?

**답변**:  
- **가능성**: Sorted Set으로 3일간 랭킹 구현 가능.  
- **요구사항 명세 필요**:  
  - 3일간 랭킹의 기준 정의 필요 (예: 8월 14일 00:00 ~ 8월 16일 현재 시점 vs. 8월 13일 ~ 15일 전체).  
  - 실시간성 요구 여부에 따라 설계 달라짐.  
- **방법 1: 실시간 3일치 랭킹**  
  - 3개의 Sorted Set 생성:  
    - 3일 전체: `ranking:3days:20250816`.  
    - 2일: `ranking:2days:20250816`.  
    - 1일: `ranking:1day:20250816`.  
  - 각 키에 데이터 합산 후 삽입.  
  - 매일 갱신: 하루 지나면 가장 오래된 키 삭제, 새 키 생성.  
  - 예: `ZINCRBY ranking:3days:20250816 1 product123`.  
- **방법 2: 비실시간 3일치 랭킹 (예: 13~15일)**  
  - 일별 Sorted Set 생성: `ranking:daily:20250813`, `ranking:daily:20250814`, `ranking:daily:20250815`.  
  - 배치 작업으로 합산: `ZUNIONSTORE`로 3일치 데이터를 하나의 Sorted Set으로 통합.  
  - 예: `ZUNIONSTORE ranking:3days:20250815 3 ranking:daily:20250813 ranking:daily:20250814 ranking:daily:20250815`.  
- **실시간 특정 시간대 (예: 8월 14일 17:21 ~ 현재)**  
  - Sorted Set은 매초 갱신되는 실시간 랭킹에 비효율적.  
  - 이유: 데이터 추가/삭제 빈번 → 캐싱 무의미, 메모리 부담.  
  - 대안: DB에서 직접 조회 후 결과 캐싱.  
- **결론**:  
  - 요구사항에 따라 Sorted Set 개수와 배치 작업 조정.  
  - 실시간성 요구 시 DB 조회가 더 효율적일 수 있음.

### 1.2. 안은솔: 실시간 인기 선물 세트 구현 및 메타데이터 처리
**질문**:  
- 설로인의 '실시간 인기 선물 세트'는 어떤 방식으로 구현되어 있는지?  
- Sorted Set으로 구현 가정 시, 상품 메타데이터를 포함한 인기 상품 목록 제공 시 캐싱 vs. DB 조회 고민.  
  - DB와 캐시 정합성 문제.  
  - 매번 DB 조회 비효율성 우려.

**답변**:  
- **설로인 구현 방식**:  
  - 실시간 인기 선물 세트는 DB에서 데이터 조회 후 Redis에 캐싱.  
  - Sorted Set 미사용, 긴 입력 파라미터 기반 캐싱 (예: `home:body:upper`, `home:body:lower`).  
  - 스케줄러로 하루치 데이터 갱신, 기존 캐시 삭제 후 업데이트.  
  - 이유: 상품 수가 많지 않아 Sorted Set보다 단순 캐싱 적합.  
- **Sorted Set 사용 시 메타데이터 처리**:  
  - **방법 1: 별도 캐싱**  
    - 인기 상품 목록: Sorted Set (`ranking:daily:20250816`).  
    - 메타데이터: 별도 키로 캐싱 (예: `product:meta:product123`).  
    - 조회 시 조합: Sorted Set에서 상품 ID 목록 → 메타데이터 키 조회 → 결과 조합.  
  - **방법 2: 메타데이터 포함 저장**  
    - Sorted Set 멤버에 메타데이터 직렬화 (예: JSON 문자열).  
    - 구분자(예: `|`)로 상품 ID와 메타데이터 결합.  
    - 조회 시 역직렬화.  
    - 단점: 메타데이터 크기/형태 다양 → 관리 복잡.  
  - **권장**: 별도 캐싱 방식 권장 (관리 용이, 유연성 높음).  
- **정합성 관리**:  
  - 캐시 만료 시간(TTL) 설정 (예: `EXPIRE product:meta:product123 86400`).  
  - 스케줄러로 주기적 갱신.  
- **DB vs. 캐싱**:  
  - 캐싱: 조회 성능 향상, DB 부하 감소.  
  - DB 조회: 실시간 정합성 보장, 캐시 관리 비용 감소.  
  - 권장: 캐싱 우선, 정합성 위해 주기적 동기화.  

### 1.3. 김정필: 7주차 과제 방향성 및 동일 점수 처리
**질문**:  
- **STEP 13**: 기존 "최근 3일간 잘 팔린 상품 5개 조회"에 Redis 캐싱 적용 vs. Sorted Set으로 리팩토링 vs. 실시간 인기 상품 조회 개발?  
- **STEP 14**: 선착순 쿠폰 발급에서 Sorted Set으로 선착순 구현.  
- **동일 점수 처리**:  
  - 인기 상품 랭킹에서 동일 수량 상품 처리 방법?  
  - 상품 ID로 정렬 vs. 마지막 판매 시간 기준 정렬?  

**답변**:  
- **STEP 13 방향성**:  
  - **리팩토링 권장**: 기존 "최근 3일간 잘 팔린 상품 5개 조회"를 Sorted Set으로 리팩토링.  
    - 이유: 기존 로직 분석 → 리팩토링 시 수정 범위 최소화 학습 → 실무 적용 가능성 높임.  
  - **신규 구현**: 실시간 인기 상품 조회 개발도 가능.  
    - Sorted Set으로 구현: `ZINCRBY`로 판매 시 스코어 증가.  
  - **리팩토링 고려사항**:  
    - 도메인 서비스 수정 최소화.  
    - 리포지토리 구현체 변경 (예: JPA → Redis).  
    - 인터페이스 유지, 구현체만 변경.  
- **STEP 14**:  
  - Sorted Set으로 선착순 구현 가능.  
    - 예: `ZADD coupon:queue:coupon123 <timestamp> user123`.  
    - 순서 보장: 타임스탬프 기반 FIFO.  
- **동일 점수 처리**:  
  - **옵션 1: 상품 ID 정렬**  
    - Sorted Set 기본 동작: 동일 스코어 시 사전순 정렬 (상품 ID).  
    - 장점: 구현 간단, 화면에서 순위 안정적.  
  - **옵션 2: 마지막 판매 시간**  
    - 스코어에 타임스탬프 추가 (예: `<판매수>.<타임스탬프>`).  
    - 단점: 복잡도 증가, 사용자에게 큰 차이 없음.  
  - **권장**: 상품 ID 정렬 (단순, 사용자 반응 덜 예민).  
  - **참고**: 동률 상품이 2~5개 수준이면 사용자 민감도 낮음.  

### 1.4. 박서희: Redis 논블로킹 필요성
**질문**:  
Redis는 싱글 스레드로 순차 처리하는데, 논블로킹 요청이라도 앞선 요청 완료 후 처리. 논블로킹의 필요성 이해 어려움.

**답변**:  
- **Redis 동작 원리**:  
  - 싱글 스레드 이벤트 루프 기반.  
  - 논블로킹 I/O: 다중 클라이언트 요청을 비동기적으로 처리.  
- **블로킹 vs. 논블로킹**:  
  - **블로킹**: 요청 처리 완료 후 다음 요청 처리.  
    - 예: 요청 A(10ms) + 요청 B(10ms) = 20ms.  
  - **논블로킹**: 이벤트 루프가 요청을 소켓으로 전달, 대기 없이 다음 요청 처리.  
    - 예: 요청 A(10ms) 처리 중 B 즉시 전달 → 전체 처리 시간 단축.  
- **왜 논블로킹 필요?**  
  - 다중 클라이언트 환경에서 처리량 증가.  
  - 이벤트 루프가 I/O 대기 시간 감소 → 성능 향상.  
- **비교: Spring WebFlux**  
  - Spring MVC: 멀티 스레드, 블로킹 (JPA 포함).  
  - WebFlux: 싱글 스레드, 논블로킹 → Redis와 유사.  
  - JPA는 블로킹 → WebFlux에서 비효율적.  

### 1.5. 박서희: 트랜잭션 내 Redis 조작 롤백 처리
**질문**:  
트랜잭션 내부에 Redis 데이터 조작 포함 시, 트랜잭션 롤백되면 Redis 조작도 롤백되는지? 롤백 안 된다면 설계 방법?

**답변**:  
- **Redis와 트랜잭션**:  
  - Redis 조작은 DB 트랜잭션과 별개 → 롤백 미지원.  
- **설계 방법**:  
  - **방법 1: 트랜잭션 외부 처리**  
    - DB 트랜잭션 완료 후 Redis 조작 (`@TransactionalEventListener`로 `afterCommit`).  
    - 예: DB 커밋 후 `ZADD` 실행.  
  - **방법 2: 사가 패턴 (Saga Pattern)**  
    - Redis 조작 실패 시 보상 트랜잭션 실행.  
    - 예: Redis 에러 → 이전 상태 복원 메소드 호출 (예: `ZREM`).  
  - **권장**: `afterCommit` 이벤트로 Redis 조작, 에러 핸들러로 보상 로직 추가.  

### 1.6. 김지수: 캐싱 전략 선택
**질문**:  
Look-Aside 캐싱은 읽기 성능을 위해 정합성 트레이드오프. 쿠폰 수량 차감은 Write-Through 캐싱 적합? 기능별 캐싱 전략 필요?

**답변**:  
- **Look-Aside vs. Write-Through**:  
  - **Look-Aside**: 읽기 성능 우선, 캐시 미스 시 DB 조회 → 캐시 저장.  
  - **Write-Through**: 쓰기 시 DB와 캐시 동시 업데이트 → 정합성 보장.  
- **쿠폰 수량 차감**:  
  - 캐싱 아님, Redis를 NoSQL DB로 사용.  
  - 예: `LPUSH coupon:stock:coupon123 100`, `LPOP`으로 차감.  
  - 정합성 보장: Redis 명령어 원자성 활용.  
- **기능별 캐싱 전략**:  
  - **캐싱**: 읽기 성능 우선 (예: 인기 상품 목록).  
  - **NoSQL DB**: 정합성 우선 (예: 쿠폰 수량, 대기열).  
  - Redis와 MySQL 역할 분리:  
    - Redis: 실시간 처리.  
    - MySQL: 영구 저장.  
  - **정합성 관리**:  
    - Redis 단독 사용 시 장애 대응 (예: Redis 다운 → DB 폴백).  
    - Redis-DB 동기화: 스케줄러로 주기적 반영.  
  - **권장**: 기능별로 Redis를 캐싱/NoSQL로 구분, 정합성 요구 시 Write-Through 유사 접근.  

### 1.7. 박서희: 클러스터 환경에서의 순서 보장
**질문**:  
Redis 단일 인스턴스는 싱글 스레드로 대기열/좌석 점유 순서 보장. 클러스터 환경에서 `ZADD`/`SETNX`로 순서 보장 가능?

**답변**:  
- **Redis 클러스터 구조**:  
  - 멀티 마스터, 샤딩 지원.  
  - 샤딩: 데이터 분산 저장, 단일 인스턴스처럼 동작.  
- **순서 보장**:  
  - 단일 인스턴스: 싱글 스레드 → `ZADD`, `SETNX`로 순서 보장.  
  - 클러스터: 샤딩으로 키 분산 → 동일 키는 동일 노드에서 처리 → 원자성/순서 보장.  
  - 예: `ZADD waiting:concert456` → 동일 키는 동일 샤드에서 순차 처리.  
- **멀티 인스턴스 주의**:  
  - 클러스터와 별개로 Redis 서버 2대 운영 시 동기화 문제 발생 가능.  
  - 해결: 클러스터 모드로 통합 관리.  
- **결론**: 클러스터 환경에서도 `ZADD`, `SETNX`로 순서 보장 가능 (샤딩 기반).

---

## 2. 중요 키워드 설명

### 2.1. Sorted Set
- **정의**: Redis 자료구조로, 멤버에 스코어 부여 후 오름차순 정렬. 동일 스코어 시 사전순 정렬.  
- **주요 명령어**:  
  - `ZADD`: 멤버와 스코어 추가.  
  - `ZINCRBY`: 스코어 증가.  
  - `ZRANGE`/`ZREVRANGE`: 범위 조회.  
  - `ZUNIONSTORE`: 다중 Sorted Set 합산.  
- **활용**: 실시간 랭킹, 대기열 관리.  
- **주의점**: 메모리 사용량 관리 (TTL 설정 필수).  

### 2.2. 논블로킹 I/O
- **정의**: 요청 처리 완료를 기다리지 않고 다음 요청 처리. 이벤트 루프 기반.  
- **Redis에서의 역할**: 싱글 스레드에서 다중 클라이언트 요청 효율적 처리.  
- **장점**: 처리량 증가, 레이턴시 감소.  
- **비교**: 블로킹 I/O는 요청 순차 처리 → 대기 시간 증가.  

### 2.3. Write-Through 캐싱
- **정의**: 데이터 쓰기 시 DB와 캐시 동시 업데이트.  
- **장점**: 정합성 보장.  
- **단점**: 쓰기 성능 저하.  
- **활용**: 쿠폰 수량 차감 등 정합성 중요한 경우.  

### 2.4. Look-Aside 캐싱
- **정의**: 캐시 미스 시 DB 조회 후 캐시 저장.  
- **장점**: 읽기 성능 향상.  
- **단점**: 정합성 트레이드오프.  
- **활용**: 인기 상품 조회 등 읽기 빈번한 경우.  

### 2.5. 사가 패턴 (Saga Pattern)
- **정의**: 분산 시스템에서 트랜잭션 실패 시 보상 트랜잭션으로 롤백 처리.  
- **Redis 활용**: DB 트랜잭션 완료 후 Redis 조작 실패 시 이전 상태 복원.  
- **예**: Redis `ZADD` 실패 → `ZREM`으로 롤백.  

### 2.6. Redis 클러스터
- **정의**: 멀티 마스터, 샤딩 기반으로 데이터 분산 저장.  
- **특징**: 키별 샤드 할당 → 동일 키는 동일 노드에서 처리 → 원자성 보장.  
- **활용**: 대기열(`ZADD`), 좌석 점유(`SETNX`) 순서 보장.  

### 2.7. @TransactionalEventListener (afterCommit)
- **정의**: Spring에서 트랜잭션 커밋 후 이벤트 처리.  
- **Redis 활용**: DB 트랜잭션 완료 후 Redis 조작 보장.  
- **예**: `@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)`로 Redis `ZADD`.  

---

## 3. 학습 포인트
- **요구사항 명세**: 랭킹 시스템 설계 시 시간 범위와 실시간성 명확히 정의.  
- **Redis 활용 전략**:  
  - Sorted Set: 랭킹, 대기열.  
  - Set/List: 쿠폰 발급, 중복 방지.  
- **정합성 관리**: Redis와 DB 역할 분리, 주기적 동기화, 장애 대응 로직 필수.  
- **리팩토링**: 인터페이스 유지, 구현체 변경 최소화.  
- **논블로킹**: Redis의 이벤트 루프 이해, 성능 최적화.