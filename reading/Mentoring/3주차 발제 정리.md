# 소프트웨어 설계 및 아키텍처 상세 가이드

## 개요
2025년 7월 19일 토요일 오후 2:30에 진행된 이번 발제는 TDD(Test-Driven Development), 레이어드 아키텍처, 헥사고날 아키텍처, 클린 아키텍처에 대한 내용을 다룹니다. 장우영 강사가 주관하며, 63분 24초 동안 진행된 이 세션은 소프트웨어 설계의 기초를 다지고, 실제 현업에서 적용 가능한 개념을 학습하는 데 초점을 맞췄습니다. 비가 내리는 날에도 오프라인 참여자들의 열정을 언급하며, 집중과 학습의 중요성을 강조했습니다.

## 1. TDD (Test-Driven Development)

### 1.1 개요 및 배경
- TDD는 테스트 코드를 먼저 작성한 뒤 해당 테스트를 통과하는 코드를 구현하는 개발 방법론.
- 이전 챕터(1-1)에서 TDD를 경험하며, 2-1에서는 설계와 간단한 코드 작성을 진행.

### 1.2 TDD의 중요성
- 단순히 "테스트 먼저 작성"을 넘어, 코드 품질과 안정성을 보장하는 필수 요소로 인식.
- 업계에서 TDD가 주목받는 이유는 개발자들이 테스트의 중요성을 공감하고 있기 때문.
- 예: 버그 감소, 리팩토링 용이성, 팀 간 코드 공유 개선.

### 1.3 1주간 TDD 경험 및 도전 과제
- **학습 과정**: 1주간의 TDD 챕터를 통해 시나리오 기반 기능 구현 및 테스트 코드 작성 연습.
- **도전 과제**:
  - **경험 부족**: 테스트 코드 작성 경험이 없어 초보자에게 어려움.
  - **분석 능력 부족**: 요구사항 분석 및 필요한 테스트 파악 어려움 (예: 어떤 경우에 단위 테스트 필요).
  - **시간 부족**: 기능 개발에 집중하느라 테스트 시간 확보 어려움, 현업자 추가 부담.
  - **구조적 어려움**: 작성한 코드의 테스트 방법을 고민, 설계 미숙.
- **향후 계획**: 10주간 항해 플러스 과정에서 지속적인 테스트 코드 작성 실습.

### 1.4 기존 개발 방식 vs 개선된 방식
- **기존 방식**:
  - 기능 정리 후 코드 작성 → 문제 발견 시 수정 → 마감 압박으로 야근 → 팀장 사과 및 혼란.
  - 예: "이상하다" 느끼며 지속적인 수정, 스트레스 증가.
- **개선된 방식**:
  - 기능 정의 명확화 → 요구사항 나열 → 동작 순서 및 책임 정의 → 테스트 케이스 작성 → 기능 개발.
  - 예: 요구사항 그룹핑 후 작은 기능으로 분류, 안전한 코드 보호.
- **목표**: 미리 문제를 방지하고, 테스트를 통해 코드 안정성 확보.

### 1.5 추가 고려 사항
- 책임 분석(과도한 책임 분산 여부), 테스트 케이스 다양성, 응집도, 리팩토링을 통한 코드 품질 향상.
- 예: 너무 많은 책임 가진 함수 분리, 불필요한 테스트 제거.

## 2. 아키텍처의 필요성

### 2.1 아키텍처의 목적
- 요구사항 충족뿐 아니라 유지보수 및 성장 가능성을 고려한 구조 설계 필요.
- 효율적인 개발과 유지보수를 위한 룰 정립 (가독성, 변경 용이성, 원칙 도입).

### 2.2 아키텍처 패턴의 종류
- 레이어드, 헥사고날, 클린 아키텍처 등 학습 필요.
- 프로젝트 성장에 따른 구조적 고민이 개발자의 역할로 강조.

### 2.3 클린 코드의 중요성
- **코드 가독성**: 복잡한 비즈니스 로직으로 이해 시간 증가.
- **협업 및 유지보수**: 함수 네이밍, 주석, 응집도, 결합도 등 클린 코드 원칙 적용.
- 예: 남의 코드 이해 시간 단축, 팀원 간 코드 공유 개선.

### 2.4 코드 수정의 어려움
- **문제점**:
  - 수정 범위 파악 어려움.
  - 타 로직 영향 우려.
  - 테스트 어려움.
  - 신규 팀원 적응 시간 (몇 주 소요 가능).
- **해결책**: 아키텍처 도입으로 구조적 안정성 확보.

### 2.5 챕터 목표
- **계층 분리 이해**: 컨트롤러에 로직 몰림 문제 경험, 계층 분리 효과 인지.
- **의존성 관리**: 단방향 의존성 구현, 순환 참조 문제 이해 및 해결.
- **테스트 가능성**: 단위 테스트 작성, 외부 의존성 격리(DB, API), 계층별 테스트 전략 수립.
- **과제 연계**: 선택한 아키텍처 적용, 책임 명확화, 동시성/트랜잭션 개선.

## 3. 아키텍처 패턴 상세

### 3.1 레이어드 아키텍처

#### 3.1.1 개요
- 전통적이고 직관적인 패턴. 건물 층처럼 계층별 역할 명확.
- 예: 아파트 구조에 비유, 각 층이 고유 역할 수행.

#### 3.1.2 계층별 역할
- **Presentation Layer**:
  - 역할: 사용자와 직접 상호작용, UI 및 컨트롤러 포함.
  - 기능: HTTP 요청 처리, 응답 생성, 인증/인가.
  - 예: Spring `@RestController`.
- **Business Layer**:
  - 역할: 서비스 클래스 포함, 비즈니스 로직 구현.
  - 기능: 주문 금액 5만 원 이상 무료 배송, VIP 10% 할인.
  - 예: `OrderService`.
- **Persistence Layer**:
  - 역할: 리포지토리, DAO 포함, DB 상호작용.
  - 기능: SQL 쿼리 실행, 데이터 매핑.
  - 예: Spring `Repository`.
- **Database Layer**:
  - 역할: 실제 DB 관리.
  - 기능: 데이터 저장, 인덱싱, 무결성 보장.
  - 예: MySQL, MongoDB.

#### 3.1.3 핵심 규칙
- **허용 의존성**: 각 계층은 바로 위 계층만 의존 (컨트롤러 → 서비스 → 리포지토리 → DB).
- **단방향 의존성**: 위에서 아래로 흐름, 하위 계층 상위 모름.
- **순환 참조 금지**: A → B → A 구조 금지.
- **관심사 분리**:
  - Presentation: HTTP 처리, 인증.
  - Business: 비즈니스 규칙, 트랜잭션.
  - Persistence: 쿼리, 데이터 매핑.
  - Database: 인덱싱, 제약 조건.

#### 3.1.4 장점
- 역할 명확성, 관심사 분리, 병렬 개발 가능.

#### 3.1.5 단점
- 로직 분산(응집도 저하), DB 변경 시 전체 영향, 도메인 모델 빈약화(Anemic Model).
- 예: 컨트롤러에 비즈니스 로직 포함 가능성.

#### 3.1.6 참고 자료
- 마틴 파울러의 레이어드 아키텍처 글 (필독).

### 3.2 레이어드 + 인터페이스 아키텍처

#### 3.2.1 개요
- 레이어드 단점 보완을 위해 인터페이스 도입.
- 릴렉시드 레이어드 또는 디펜던시 인버전(DIP) 적용 패턴.

#### 3.2.2 차이점
- 리포지토리를 인터페이스로 정의, 서비스가 구현체 대신 인터페이스 의존.
- 예: `UserService`가 `UserRepository` 인터페이스 의존.

#### 3.2.3 의존성 역전 원칙 (DIP)
- 고수준 모듈(서비스)이 저수준 모듈(DB)에 직접 의존 X, 추상화(인터페이스)에 의존.
- 예: 런타임에 JPA 또는 Mock `UserRepository` 주입.

#### 3.2.4 장점
- 유연성(DB 변경 시 서비스 영향 최소), 테스트 용이성(Mock 사용), 구현체 교체 용이.

#### 3.2.5 단점
- 서비스 계층 비대화, 컨트롤러가 서비스 메서드 의존, 도메인 모델 빈약화, 외부 API 통합 시 복잡성.

#### 3.2.6 참고 자료
- 마틴 파울러의 DIP 및 코드 예시 글 (필독).

### 3.3 헥사고날 아키텍처

#### 3.3.1 개요
- 알리스타 컴번 제안. 포트와 어댑터로 외부 상호작용 정의.
- 육각형 모양은 비유, 포트와 어댑터 개념이 핵심.

#### 3.3.2 핵심 개념
- **Domain/Business Logic**: 외부 기술 독립적 비즈니스 로직.
- **Ports**: 비즈니스와 외부 간 인터페이스.
  - Inbound: 입력 (예: `CreateOrderUseCase`).
  - Outbound: 출력 (예: `SaveUserPort`).
- **Adapters**: 포트 구현, 외부 시스템 연결 (예: JPA, REST).

#### 3.3.3 의존성 방향
- 모든 의존성 외부에서 내부로 향함. 비즈니스 로직이 외부를 제어.
- 예: REST API, GraphQL이 동일 도메인 로직 활용.

#### 3.3.4 포트와 어댑터 역할
- **Inbound Port**: 요청 처리 (예: `CreateOrderUseCase`).
- **Outbound Port**: 외부 요청 (예: `SendEmailPort`).
- **Adapter**: 기술별 구현 (예: JPA `SaveUserAdapter`).

#### 3.3.5 장점
- 의존성 역전 완성, 어댑터 추가 용이, 테스트 용이(Mock 대체), 비즈니스 로직 순수성.

#### 3.3.6 단점
- 인터페이스/구현체 증가, 설계 시간 소요, 소규모 프로젝트 과도함(오버엔지니어링).

#### 3.3.7 적용 시기
- 복잡한 도메인, 장기 유지보수, 다중 외부 시스템 통합, 빈번한 요구사항 변경.

#### 3.3.8 참고 자료
- 헥사고날 아키텍처 비교 및 필독 아티클.

### 3.4 클린 아키텍처

#### 3.4.1 개요
- 로버트 마틴 제안. 헥사고날과 유사하나 동심원 구조로 세분화.

#### 3.4.2 계층 구조
- **Entities**: 핵심 비즈니스 규칙.
- **Use Cases**: 애플리케이션 특화 규칙.
- **Interface Adapters**: 데이터 변환.
- **Frameworks & Drivers**: 프레임워크, DB.

#### 3.4.3 의존성 규칙
- 의존성 안으로 향, 안쪽 원은 바깥 모름.
- 추상화 수준 높아짐, 변경 가능성 낮아짐 (비즈니스 규칙 > UI/DB).

#### 3.4.4 특징
- 프레임워크 독립성, DB 독립성, 테스트 용이성.
- 예: Spring, Oracle 변경 시 영향 없음.

#### 3.4.5 참고 자료
- 클린 코드 블로그 (필독).

## 4. 도메인 이해

### 4.1 도메인 정의
- 특정 기능/속성 응집화 개념.
- **비즈니스 도메인**: 주문, 결제, 배송 등 영역.
- **도메인 모델**: 속성+행위 객체 (예: `Order`에 취소, 배송 시작).
- **도메인 이해도**: 전문가 소통 및 요구사항 표현 능력.

### 4.2 Entity (엔티티)
- **도메인 맥락**: 응집화된 도메인 모델, 식별자+생명 주기.
- **DB 맥락**: 테이블 매핑 객체 (예: JPA `@Entity`).

### 4.3 도메인 모델 vs DB Entity 분리
- **장점**: 비즈니스 로직 독립성, DB 변경 영향 최소화.
- **단점**: 변환 작업 증가, 코드 량 증가.
- 예: 도메인 `Order`와 DB `OrderEntity` 분리.

## 5. 클린 코드 원칙

### 5.1 핵심 철학
- 읽기 쉽고 단순한 코드 작성.

### 5.2 원칙
- **한 가지 일만 하기**: 단일 책임 원칙, 부작용 최소화.
  - 예: "getAndSave" 대신 분리.
- **의미 있는 이름**: 역할/목적 명확, 약어 최소화.
  - 예: `daysSinceCreation` vs `d`.
- **중복 제거**: 유지보수성 향상, 의미 있는 중복 구분.
  - 예: 동일 로직 함수화.
- **주석 최소화**: "왜" 설명, 코드 개선 시 주석 갱신.
  - 예: "법적 요구사항" 주석만 남김.
- **작은 단위 분리**: 복잡성 관리, 현대 최적화 신뢰.
- **코딩 스타일 일관성**: 팀워크 및 전문성 강화.
  - 예: PR 템플릿 준수.
- **의존성 격리**: 인터페이스로 유연성 확보.
  - 예: DB 교체 시 영향 최소화.

## 6. 학습 및 과제 가이드

### 6.1 학습 계획 (Java, Kotlin, TypeScript)
- **Day 1**: 클린/레이어드 아키텍처 비교, SOLID/DIP/OCP 학습, 시나리오 분석.
- **Day 2**: 도메인 모델 설계, Use Case/파사드 분리.
- **Day 3-5**: 단위 테스트, 리팩토링, 외부 의존성 분리.

### 6.2 과제 목표
- **Step 5**:
  - 아키텍처 일관성, 계층 책임, 의존성 방향, 기능 구현, 테스트.
- **Step 6**:
  - 동시성/트랜잭션 해결, 개선점 파악.

### 6.3 PR 템플릿 체크리스트
- **아키텍처 설계**: 패턴 일관성, 의존성 방향, 설명(선택 이유).
- **핵심 구현**: 비즈니스 로직 위치, 외부 분리.
- **테스트**: 단위 테스트, 의존성 격리.
- **기타**: 추가 체크 가능.

### 6.4 팀별 토론 주제
- **비즈니스 규칙**: 예약 코드 위치.
- **동시성**: 잠금/재시도 로직.
- **알림 설계**: 추상화 계층 위치.
- **확장성**: 병목 예측 및 설계 개선.
- **시간**: 5시 이후 조별 토론, 4:50까지 결과 공유.

### 6.5 추가 참고
- 필독 아티클, PR 템플릿 MD 파일 생성 권장.

## 7. 좋은 아키텍처 패턴의 정의
- 유행 기술 따라감 X, 성장 가능성 있는 안정적 소프트웨어 가이드라인.
- **조건**:
  - 코드 위치 기준 제공.
  - 변경/확장 유연성.
  - 테스트 용이성.
  - 개발 가이드라인 제공.
- 예: 상품 조회 수 증가 로직 위치(서비스 vs 리포지토리).

## 8. 결론
TDD와 아키텍처 패턴은 코드 품질과 프로젝트 지속 가능성을 보장합니다. 팀별 토론과 과제를 통해 실질적인 경험을 쌓아가세요. 질문은 언제든 환영합니다!