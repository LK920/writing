
## 1. 전자상거래 시스템의 동시성 소개

동시성 문제는 여러 트랜잭션이나 프로세스가 공유 자원에 동시에 접근할 때 발생하며, 이는 일관성 없는 결과나 잘못된 결과를 초래할 수 있습니다. 전자상거래 시스템에서는 높은 사용자 트래픽과 재고, 사용자 포인트, 쿠폰과 같은 공유 자원 때문에 이러한 문제가 특히 중요합니다.

### 1.1 동시성 문제의 주요 시나리오
전자상거래 서비스에서 동시성 문제가 발생하기 쉬운 주요 시나리오는 다음과 같습니다:
- **재고 차감**: 여러 사용자가 동시에 동일한 상품을 구매하려고 시도할 때, 재고 확인과 업데이트가 원자적(atomic)이지 않으면 재고가 초과 판매되는 레이스 컨디션(race condition)이 발생할 수 있습니다.
  - 예: 사용자 A와 B가 동시에 재고가 1개 남은 상품을 구매하려고 합니다. 둘 다 재고가 있다고 확인한 후 구매를 진행하면 재고가 -1로 잘못 업데이트될 수 있습니다.
- **사용자 포인트 잔액**: 여러 트랜잭션이 동시에 사용자 포인트 잔액을 업데이트할 때, 비일관성 업데이트로 인해 잔액이 잘못 계산될 수 있습니다.
- **선착순 쿠폰**: 제한된 수의 쿠폰을 여러 사용자가 동시에 획득하려고 하면, 레이스 컨디션으로 인해 쿠폰이 초과 발행될 수 있습니다.

**코치 팁**: 동시성 문제는 단순히 DB뿐만 아니라 애플리케이션 레벨에서도 발생할 수 있습니다. 예를 들어, Java에서 `ConcurrentHashMap` 같은 도구를 사용하지 않으면, 메모리 내 객체를 수정하는 여러 스레드가 충돌할 수 있습니다.

**추가 설명**: 동시성 문제는 트랜잭션 크기와 요청 빈도에 따라 더 심각해질 수 있습니다. 예를 들어, 트랜잭션이 길거나 느린 쿼리(Slow Query)가 포함된 경우, 다른 트랜잭션이 공유 자원에 접근할 가능성이 높아져 충돌 위험이 증가합니다.

---

## 2. 동시성 제어 기법

동시성 문제를 해결하기 위해 다양한 기법이 사용됩니다. 이 섹션에서는 데이터베이스 트랜잭션의 기본 개념과 동시성 제어를 위한 주요 전략을 다룹니다.

### 2.1 트랜잭션의 기본 개념

트랜잭션은 데이터베이스에서 일관성과 무결성을 보장하기 위한 논리적 작업 단위입니다. 트랜잭션은 ACID 특성을 만족해야 합니다:
- **원자성(Atomicity)**: 트랜잭션 내 모든 작업이 전부 성공하거나 전부 실패해야 합니다. 일부만 반영되는 상태는 허용되지 않습니다.
- **일관성(Consistency)**: 트랜잭션 수행 전후로 시스템 상태는 항상 일관성을 유지해야 합니다. 예: 주문 완료 시 주문 시각이 반드시 기록되어야 합니다.
- **고립성(Isolation)**: 동시에 실행되는 트랜잭션은 서로 간섭하지 않아야 하며, 각 트랜잭션은 독립적으로 실행된 것처럼 동작해야 합니다.
- **지속성(Durability)**: 성공적으로 완료된 트랜잭션의 결과는 시스템 장애가 발생해도 보존되어야 합니다.

**코치 팁**: 트랜잭션은 DB뿐만 아니라 CS 전반에서 사용되는 개념입니다. 예를 들어, 파일 복사, 은행 송금, 온라인 주문 등도 트랜잭션으로 간주될 수 있습니다. 특히 마이크로서비스 아키텍처(MSA)에서는 서비스 간 호출 흐름 전체를 하나의 트랜잭션으로 묶어 관리할 수 있습니다.

**추가 설명**: 트랜잭션의 ACID 특성은 전자상거래 시스템에서 특히 중요합니다. 예를 들어, 주문 처리 트랜잭션에서 재고 차감, 포인트 차감, 배송 정보 저장이 모두 성공해야 주문이 완료됩니다. 하나라도 실패하면 롤백하여 데이터 일관성을 유지해야 합니다.

---

### 2.2 트랜잭션 격리 수준(Isolation Levels)

트랜잭션 격리 수준은 트랜잭션 간 상호작용을 제어하여 동시성 문제를 관리합니다. 격리 수준에 따라 데이터 일관성과 성능 간의 균형이 달라집니다.

1. **Uncommitted Read (Dirty Read)**:
   - 커밋되지 않은 데이터를 읽을 수 있는 가장 낮은 격리 수준입니다.
   - 문제: Dirty Read 발생 가능. 롤백된 데이터를 다른 트랜잭션이 읽어 잘못된 결과를 초래할 수 있습니다.
   - 예: 주문 트랜잭션이 재고를 차감했지만 커밋되지 않은 상태에서 다른 트랜잭션이 이 데이터를 읽으면, 롤백 시 데이터 불일치가 발생할 수 있습니다.
   - **코치 팁**: 실무에서 Uncommitted Read는 문제가 많아 거의 사용되지 않습니다.

2. **Committed Read**:
   - 커밋된 데이터만 읽을 수 있는 격리 수준입니다. Dirty Read는 방지되지만, Non-Repeatable Read 문제가 발생할 수 있습니다.
   - Non-Repeatable Read: 동일한 트랜잭션 내에서 같은 쿼리를 여러 번 실행했을 때, 다른 트랜잭션의 커밋으로 인해 결과가 달라지는 현상.
   - 예: 재고를 조회하는 트랜잭션이 여러 번 실행되는 동안 다른 트랜잭션이 재고를 차감하면, 조회 결과가 달라질 수 있습니다.
   - **코치 팁**: Committed Read는 통계 데이터 추출 등 정확성이 덜 중요한 경우에 사용될 수 있지만, 비즈니스 로직에서는 드물게 사용됩니다.

3. **Repeatable Read**:
   - 트랜잭션 시작 시점의 데이터를 유지하여 Non-Repeatable Read를 방지합니다. MySQL에서는 MVCC(Multi-Version Concurrency Control)를 사용하여 이를 구현합니다.
   - 문제: Phantom Read가 발생할 수 있습니다. 동일한 조건으로 조회 시 새로운 레코드가 추가되어 결과 레코드 수가 달라질 수 있습니다.
   - **코치 팁**: MySQL의 기본 격리 수준은 Repeatable Read이며, 실무에서 90% 이상 이 수준으로 해결됩니다. Phantom Read는 MySQL에서 특수한 상황이 아니면 드물게 발생합니다.

4. **Serializable**:
   - 가장 엄격한 격리 수준으로, 트랜잭션이 순차적으로 실행된 것처럼 동작합니다. 모든 쿼리에 암묵적으로 락을 걸어 다른 트랜잭션의 접근을 차단합니다.
   - 문제: 성능 저하와 데드락(Deadlock) 발생 가능성이 높습니다.
   - **코치 팁**: Serializable은 데드락 위험이 크므로 실무에서 거의 사용되지 않습니다. 한 사례에서 Serializable 사용으로 인해 DB 담당자가 직접 사용 중지를 요청한 경우도 있었습니다.

**추가 설명**: MySQL에서 Repeatable Read는 대부분의 동시성 문제를 해결하는 데 적합하며, 성능과 안정성의 균형을 제공합니다. 특정 상황에서 Committed Read를 사용할 수 있지만, Uncommitted Read와 Serializable은 문제 가능성 때문에 피하는 것이 좋습니다.

---

### 2.3 동시성 제어 메커니즘

동시성 문제를 해결하기 위해 데이터베이스에서 사용하는 주요 메커니즘은 락(Lock)과 낙관적 락(Optimistic Lock)입니다.

#### 2.3.1 락(Lock) 기반 동시성 제어

락은 공유 자원에 대한 접근을 제한하여 동시성 문제를 방지합니다. 데이터베이스에서는 두 가지 주요 락이 사용됩니다:
- **공유 락(Shared Lock)**: 읽기 작업만 허용하며, 다른 트랜잭션의 읽기는 허용하지만 쓰기(업데이트, 삭제)는 차단합니다.
  - 쿼리 예: `SELECT ... FOR SHARE`
  - 사용 사례: 데이터 조회 시 다른 트랜잭션이 데이터를 수정하지 못하도록 보호.
- **배타 락(Exclusive Lock)**: 읽기와 쓰기 모두 허용하며, 다른 트랜잭션의 읽기와 쓰기를 차단합니다.
  - 쿼리 예: `SELECT ... FOR UPDATE`
  - 사용 사례: 재고 차감과 같은 중요한 업데이트 작업에서 사용.

**예제: 재고 차감 시나리오**
- 트랜잭션 A: `SELECT stock FROM product WHERE id = 777 FOR UPDATE`
  - 재고를 조회하고 배타 락을 걸어 다른 트랜잭션의 접근을 차단.
  - 재고를 차감하고 커밋.
- 트랜잭션 B: 동일한 상품 ID로 조회 시도 시, 트랜잭션 A가 커밋할 때까지 대기.
- 결과: 재고가 올바르게 차감되며, 분실 갱신(Lost Update) 문제가 방지됨.

**코치 팁**: 락을 사용할 때는 성능 저하와 데드락 가능성을 테스트해야 합니다. 무분별한 락 사용은 시스템 성능을 저하시킬 수 있습니다.

**추가 설명**: 락은 정합성을 강하게 보장하지만, 락이 걸린 상태에서 대기 시간이 길어지면 성능 병목이 발생할 수 있습니다. 따라서 락의 범위와 지속 시간을 최소화하는 설계가 중요합니다.

#### 2.3.2 낙관적 락(Optimistic Lock)

낙관적 락은 명시적 락을 사용하지 않고, 버전 컬럼을 활용하여 데이터 충돌을 감지합니다. 충돌 빈도가 낮은 경우에 적합합니다.
- 동작 방식:
  - 데이터를 조회할 때 버전 번호를 함께 가져옵니다.
  - 업데이트 시 버전 번호가 일치하는지 확인하고, 일치하지 않으면 업데이트를 실패 처리합니다.
  - 쿼리 예: `UPDATE product SET stock = stock - 1, version = version + 1 WHERE id = 777 AND version = 1`
- 결과: 충돌 시 롤백하거나 재시도 전략을 적용.

**예제: 좌석 예약**
- 트랜잭션 A: 좌석 정보를 조회(`version = 1`)하고 상태를 업데이트.
- 트랜잭션 B: 동일한 좌석을 조회(`version = 1`)하고 업데이트 시도.
- 트랜잭션 A가 먼저 커밋하면, 트랜잭션 B는 버전 불일치로 실패하고 롤백 또는 재시도.

**코치 팁**: 낙관적 락은 성능이 비관적 락보다 우수하지만, 충돌이 자주 발생하면 롤백/재시도 로직을 신중히 설계해야 합니다. 특히, 재시도 로직이 커넥션을 오래 점유하면 타임아웃 문제가 발생할 수 있습니다.

**추가 설명**: 낙관적 락은 재고 차감, 좌석 예약 등 충돌이 드물지만 정합성이 필요한 경우에 적합합니다. 반면, 선착순 쿠폰처럼 충돌 빈도가 높은 경우에는 비관적 락이 더 적합할 수 있습니다.

#### 2.3.3 데드락(Deadlock)

데드락은 둘 이상의 트랜잭션이 서로의 자원을 기다리며 무한 대기 상태에 빠지는 상황입니다.
- 발생 조건:
  - 두 트랜잭션이 각각 다른 자원에 락을 걸고, 상대방의 락이 풀리기를 기다림.
  - 예: 트랜잭션 A가 좌석 테이블에 락을 걸고, 트랜잭션 B가 콘서트 테이블에 락을 걸며, 각각 상대 테이블에 접근하려고 함.
- 해결 방안:
  - MySQL은 데드락을 감지하고, 한 트랜잭션을 희생자(Victim)로 선택해 롤백시킵니다.
  - 애플리케이션에서는 예외 처리를 통해 재시도 로직을 구현해야 합니다.

**코치 팁**: 데드락은 락 메커니즘을 사용할 때 항상 발생 가능성이 있으므로, 락 순서를 일관되게 유지하거나 락 타임아웃을 설정하여 예방해야 합니다.

**추가 설명**: 데드락 예방을 위해 자원 접근 순서를 표준화하거나, 트랜잭션 크기를 최소화하는 것이 중요합니다. 예를 들어, 항상 `concert` 테이블을 먼저 락 걸고 `seat` 테이블을 락 걸도록 설계하면 데드락 가능성을 줄일 수 있습니다.

---

## 3. 테스트 전략

동시성 문제를 해결한 코드는 철저한 테스트를 통해 검증해야 합니다. 테스트는 단위 테스트와 통합 테스트로 나뉘며, 각각의 역할과 주의점이 다릅니다.

### 3.1 단위 테스트

단위 테스트는 개별 메서드나 모듈의 동작을 독립적으로 검증합니다.
- **독립성**: 단위 테스트는 다른 테스트나 상태에 의존하지 않아야 합니다. 전체 테스트 실행 시에도 동일한 결과가 보장되어야 합니다.
- **속도**: 단위 테스트는 의존성을 모킹(Mock)하여 빠르게 실행되어야 합니다.
- **코치 팁**: 테스트가 독립적이지 않으면, DB 상태 변경(예: 저장, 삭제)이 다른 테스트에 영향을 미쳐 실패할 수 있습니다. 테스트 시작 전 데이터 설정과 종료 후 클린업 작업을 철저히 수행해야 합니다.

**추가 설명**: 예를 들어, 재고 차감 테스트에서 동일한 상품 ID를 사용하는 테스트가 서로 간섭하지 않도록, 테스트 전후로 데이터를 초기화하거나 테스트 컨테이너를 활용해 격리된 환경을 구성해야 합니다.

### 3.2 통합 테스트

통합 테스트는 DB와 같은 외부 시스템과의 상호작용을 검증합니다.
- **도구**: 테스트 컨테이너(Testcontainers)를 사용하여 실제 DB 환경을 시뮬레이션할 수 있습니다.
- **문제점**: 통합 테스트는 컨테이너를 띄우는 비용 때문에 단위 테스트보다 느립니다.
- **코치 팁**: 단위 테스트와 통합 테스트를 분리하여 실행하세요. 예를 들어, Gradle 태스크를 분리하여 단위 테스트는 자주 실행하고, 통합 테스트는 별도로 실행하는 방식이 효과적입니다.

**추가 설명**: 통합 테스트에서는 동시성 문제를 재현하기 위해 멀티스레드 환경을 시뮬레이션할 수 있습니다. 예를 들어, 여러 스레드가 동시에 재고 차감을 시도하는 테스트를 작성하여 락의 동작을 검증할 수 있습니다.

### 3.3 테스트 환경 설정

- **임베디드 데이터베이스**: Spring Test에서 제공하는 임베디드 데이터베이스(H2 등)를 사용하면 설정이 간단하고 테스트 속도가 빠릅니다.
- **코치 팁**: 테스트 컨테이너 외에도 다양한 도구를 활용해 테스트 환경을 구성하세요. 팀의 요구사항에 맞는 도구를 선택하는 것이 중요합니다.

**추가 설명**: 임베디드 데이터베이스는 가벼운 테스트에 적합하지만, 실제 DB와의 동작 차이를 고려해야 합니다. 예를 들어, MySQL의 MVCC와 H2의 동작 방식이 다를 수 있으므로, 프로덕션 환경과 유사한 테스트 환경을 구성하는 것이 이상적입니다.

---

## 4. 서비스 계층 설계

전자상거래 시스템에서 서비스 계층은 비즈니스 로직을 처리하는 핵심 구성 요소입니다. 서비스 계층은 애플리케이션 서비스, 도메인 서비스, 인프라 서비스로 나뉩니다.

### 4.1 애플리케이션 서비스

애플리케이션 서비스는 컨트롤러와 도메인 간의 중개 역할을 하며, 여러 도메인의 로직을 조합합니다.
- **특징**: 상태를 가지지 않으며, 비즈니스 로직을 조율합니다.
- **구현**: `@Service` 또는 `@Injectable` 어노테이션을 사용하여 정의.
- **코치 팁**: 애플리케이션 서비스는 특정 도메인에 속하지 않는 로직을 처리하며, Use Case 패턴으로 추상화하면 컨트롤러가 더 간단해집니다.

**예제**:
```java
@Service
public class OrderService {
    private final OrderRepository orderRepository;
    private final CustomerRepository customerRepository;

    public void placeOrder(Order order, Customer customer) {
        orderRepository.save(order);
        customerRepository.update(customer);
    }
}
```

**추가 설명**: 애플리케이션 서비스는 트랜잭션 경계를 설정하는 역할도 수행합니다. `@Transactional` 어노테이션을 사용하여 트랜잭션의 원자성을 보장할 수 있습니다.

### 4.2 도메인 서비스

도메인 서비스는 여러 도메인 간 협력이 필요한 비즈니스 로직을 처리합니다.
- **특징**: 특정 도메인에 속하지 않는 로직을 캡슐화합니다.
- **예제**: 할인 정책 적용. 주문과 고객 정보를 바탕으로 할인율을 계산하는 로직은 도메인 서비스로 분리.
- **코치 팁**: 도메인 서비스는 도메인 객체를 직접 참조하며, DB 접근 로직은 포함시키지 않습니다. 이는 도메인 로직의 순수성을 유지하기 위함입니다.

**예제**:
```java
public class DiscountService {
    public BigDecimal calculateDiscount(Order order, Customer customer) {
        if (customer.getGrade() == Grade.VIP) {
            return order.getTotalAmount().multiply(new BigDecimal("0.1"));
        }
        return BigDecimal.ZERO;
    }
}
```

**추가 설명**: 도메인 서비스는 재사용성을 높이고, 애플리케이션 서비스의 복잡성을 줄이는 데 유용합니다. 예를 들어, 할인 계산 로직을 도메인 서비스로 분리하면 장바구니, 주문, 결제 등 여러 시나리오에서 재사용할 수 있습니다.

### 4.3 인프라 서비스

인프라 서비스는 외부 시스템(DB, 메시징 시스템 등)과의 상호작용을 처리합니다.
- **특징**: 핵심 비즈니스 로직은 포함하지 않으며, 데이터 접근이나 외부 API 호출을 추상화합니다.
- **예제**: JPA Repository, Transaction Manager.
- **코치 팁**: 인프라 서비스는 추상화 수준이 높아 코드가 간결해지며, JPA의 기본 메서드(save, findById 등)를 활용하면 구현이 간단해집니다.

**추가 설명**: 인프라 서비스는 ORM(Object-Relational Mapping) 도구를 활용하여 데이터베이스 작업을 단순화합니다. 예를 들어, Spring Data JPA를 사용하면 복잡한 JDBC 작업을 추상화할 수 있습니다.

---

## 5. 동시성 문제 해결 사례

### 5.1 재고 차감
- **문제**: 여러 사용자가 동시에 동일한 상품을 구매하면 재고가 잘못 차감될 수 있습니다.
- **해결 방안**:
  - **비관적 락**: `SELECT ... FOR UPDATE`를 사용하여 재고 조회 시 락을 걸고, 업데이트 후 커밋.
  - **낙관적 �락**: `version` 컬럼을 추가하고, 업데이트 시 버전 조건을 확인.
- **테스트**: 멀티스레드 테스트를 통해 동시 요청 시 재고가 올바르게 차감되는지 검증.

### 5.2 사용자 포인트 잔액
- **문제**: 포인트 잔액 업데이트 시 여러 트랜잭션이 충돌하면 잔액이 잘못 계산될 수 있습니다.
- **해결 방안**:
  - **비관적 락**: 포인트 조회 시 배타 락을 걸어 다른 트랜잭션의 접근을 차단.
  - **낙관적 락**: 포인트 테이블에 버전 컬럼을 추가하여 충돌 감지.
- **테스트**: 통합 테스트로 여러 요청이 동시에 포인트를 차감할 때 잔액 일관성을 확인.

### 5.3 선착순 쿠폰
- **문제**: 제한된 쿠폰을 여러 사용자가 동시에 획득하려 하면 초과 발행될 수 있습니다.
- **해결 방안**:
  - **비관적 락**: 쿠폰 테이블에 락을 걸어 순차적으로 처리.
  - **분산 락**: Redis와 같은 외부 시스템을 사용하여 분산 환경에서 동시성 제어.
- **테스트**: 고부하 테스트를 통해 쿠폰 발행 수가 제한을 초과하지 않는지 검증.

**코치 팁**: 동시성 문제는 서비스별로 다를 수 있으므로, 문제 발생 가능성을 식별하고 적절한 해결 방법을 선택해야 합니다. 문서화는 포트폴리오나 업무 성과 정리에도 유용합니다.

**추가 설명**: 분산 락은 다중 서버 환경에서 효과적이며, Redis의 `SETNX`(Set if Not Exists) 명령어를 사용하여 구현할 수 있습니다.

---

## 6. 실무에서의 팁과 고려사항

### 6.1 트랜잭션 크기 최적화
- 트랜잭션은 가능한 한 작게 유지하여 DB 부하를 줄이고, 롤백 시 복구 비용을 최소화해야 합니다.
- **코치 팁**: 트랜잭션이 너무 길면 장애가 발생할 수 있습니다. 예를 들어, 주문 트랜잭션이 실패하면 모든 작업이 롤백되어야 하므로, 트랜잭션 범위를 명확히 정의하세요.

### 6.2 데드락 예방
- **일관된 락 순서**: 자원 접근 순서를 표준화하여 데드락 가능성을 줄입니다.
- **타임아웃 설정**: 락 대기 시간을 제한하여 무한 대기를 방지합니다.
- **코치 팁**: 데드락은 사용자에게 오류로 나타날 수 있으므로, 예외 처리와 재시도 로직을 철저히 설계하세요.

### 6.3 DB 커넥션 풀 관리
- **문제**: 대용량 데이터 처리 시 DB 커넥션 풀이 고갈될 수 있습니다.
- **해결 방안**:
  - Slow Query 최적화.
  - 커넥션 풀 크기 조정.
  - 트랜잭션 크기 최소화.
- **코치 팁**: 커넥션 풀이 고갈되면 DB가 놀고 있는 상황에서도 성능이 저하될 수 있습니다. 모니터링 도구를 활용해 병목 원인을 식별하세요.

**추가 설명**: 모니터링 도구(New Relic, Prometheus 등)를 사용하면 커넥션 풀 사용량, 쿼리 성능, CPU/메모리 사용량을 실시간으로 확인할 수 있습니다.

---

## 7. 과제 가이드

이번 주 과제는 동시성 문제를 식별하고 해결 방안을 구현 및 문서화하는 것입니다.

### 7.1 과제 1: 동시성 문제 문서화 (Step 9)
- **내용**:
  - 서비스에서 발생 가능한 동시성 문제 식별 (예: 재고 차감, 포인트 잔액, 선착순 쿠폰).
  - DB를 활용한 해결 방법 제안 (비관적 락, 낙관적 락 등).
  - 해결 방법의 장단점과 적용 사례 문서화.
- **코치 팁**: 문서화는 포트폴리오나 업무 성과 정리에도 유용하니, 문제와 해결 방안을 명확히 정리하세요.

### 7.2 과제 2: 구현 및 테스트 (Step 10)
- **내용**:
  - 문서화한 동시성 해결 방안을 코드로 구현.
  - 락(비관적/낙관적)을 적용하고, 통합 테스트로 검증.
- **코치 팁**: 1주차에 작성했던 동시성 테스트 코드를 참고하여, 멀티스레드 환경에서 동작을 검증하세요.

**추가 설명**: 테스트 케이스는 실제 서비스 시나리오를 반영해야 합니다. 예를 들어, 100개의 동시 요청이 재고 차감을 시도할 때, 재고가 음수로 떨어지지 않는지 확인하는 테스트를 작성하세요.

---

## 8. 토론 주제

팀별 토론을 통해 실무 적용 사례를 공유하고, 문제 해결 방안을 논의하세요.

1. **트랜잭션 크기**:
   - 트랜잭션을 얼마나 작게 유지해야 하는지, 장단점은 무엇인지 논의.
   - 긴 트랜잭션으로 인해 장애가 발생한 사례 공유.
2. **데드락 예방 및 대응**:
   - 데드락을 예방하는 방법(락 순서, 타임아웃 등).
   - 데드락 발생 시 애플리케이션의 대응 전략.
3. **DB 커넥션 풀 고갈**:
   - 커넥션 풀 고갈의 원인(Slow Query, 긴 트랜잭션 등).
   - 대응 방안과 모니터링 방법.

**코치 팁**: 실무 사례를 공유하면 동시성 문제의 실제 영향을 이해하는 데 도움이 됩니다. 특히, DB 커넥션 풀 고갈은 대용량 데이터 처리 시 자주 발생하니, 모니터링과 최적화 전략을 깊이 논의하세요.

---

## 9. 결론

전자상거래 시스템에서 동시성 문제는 재고, 포인트, 쿠폰 등 공유 자원의 일관성을 유지하는 데 핵심적인 도전 과제입니다. 트랜잭션 격리 수준, 락 기반 제어, 낙관적 락을 적절히 활용하여 문제를 해결하고, 철저한 테스트로 정합성을 검증해야 합니다. 서비스 계층 설계와 테스트 전략은 코드의 유지보수성과 협업 효율성을 높이는 데 기여합니다.

**코치 팁**: 동시성 문제는 이론뿐만 아니라 실무에서 자주 발생하므로, 학습 단계에서 다양한 시나리오를 테스트하고 문서화하는 연습을 하세요. 이는 실무 역량 강화와 포트폴리오 구성에 큰 도움이 됩니다.

**추가 설명**: 동시성 문제는 시스템 규모가 커질수록 더 복잡해집니다. 분산 시스템(예: MSA)에서는 분산 락, 사가 패턴 등 추가적인 기법이 필요할 수 있으니, 추후 학습에서 이를 탐구하는 것도 추천합니다.