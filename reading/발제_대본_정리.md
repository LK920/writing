# Redis 기반 시스템 설계 발제 대본 정리

**일시**: 2025년 8월 16일 (토) 오후 2:40  
**주제**: 대용량 트래픽 처리와 Redis 기반 시스템 설계 (6~9주 차)  
**목표**: 데이터 정합성 보장, Redis 자료구조 활용, 랭킹 및 비동기 시스템 설계 학습  

---

## 1. 발제 개요

### 1.1. 학습 목표 및 배경
- **1~5주 차 복습**: 기존 학습 내용 복습 및 정리.
- **6~9주 차 주제**: 대용량 트래픽 처리에 초점.
  - **데이터 정합성**: 대규모 트래픽 환경에서 데이터 정합성을 보장하는 방법 학습.
  - **동시성 제어**: 트래픽 처리 시 동시성 문제 해결.
  - **Redis 활용**: Redis의 자료구조와 기능을 활용한 시스템 설계.
- **중요성**:
  - 스타트업 성장 시 대규모 유저와 트래픽 처리 필요.
  - 잘못된 동시성 제어로 인해 데이터 정합성 이슈 발생 가능.
  - 예: 콘서트 티켓 중복 예약, 쿠폰 초과 발급으로 인한 금전적 손실.

### 1.2. 사례를 통한 문제 설명
- **콘서트 시나리오**:
  - 동일 좌석 중복 예약 발생 시 문제:
    - 티켓 가격: 5만 원 ~ 30만 원 (암표 포함).
    - 중복 예약이 5천 명 발생 시 대규모 환불 및 고객 불만 발생.
  - 데이터 정합성 보장이 필수.
- **이커머스 시나리오**:
  - 쿠폰 발급 시 문제:
    - 5만 원 쿠폰 100명 제한 → 1만 명 발급 시 500만 원 → 5억 원 손실.
  - 데이터 정합성 보장으로 금전적 손실 방지 필요.

---

## 2. 동시성 제어 복습

### 2.1. 락의 종류 비교
- **낙관적 락 (Optimistic Lock)**:
  - **특징**: DB에 락을 걸지 않고, 데이터 수정 시 버전 확인으로 충돌 감지.
  - **비용**: 가장 저렴.
  - **적합한 경우**: 경합(충돌)이 적은 경우 (예: 재고 차감 드문 시나리오).
  - **장점**:
    - DB 부하 적음.
    - 조회 성능에 영향 없음.
  - **단점**:
    - 충돌 빈번 시 재시도(Retry) 비용 증가.
    - 실패 처리 로직 필요.
- **비관적 락 (Pessimistic Lock)**:
  - **특징**: DB에 락을 걸어 다른 트랜잭션 접근 차단.
  - **비용**: 낙관적 락보다 높음, 분산 락보다 낮음.
  - **적합한 경우**: 순차 처리 필요, 빠른 처리 요구 (예: 콘서트 좌석 예약).
  - **장점**:
    - 빠른 처리 속도 (작은 트랜잭션 범위).
    - Spring `@Transactional`로 순서 보장.
  - **단점**:
    - 락 범위 크면 조회 쿼리에도 대기 시간 발생.
    - DB 부하 증가 가능.
- **분산 락 (Distributed Lock)**:
  - **특징**: Redis 등 외부 리소스로 락 관리 (예: Redisson).
  - **비용**: 가장 높음 (개발 및 관리 복잡).
  - **적합한 경우**: 분산 환경에서 다수 서버가 동일 자원 접근 (예: 다중 서버 쿠폰 발급).
  - **장점**:
    - DB 부하 분산.
    - 원자성 보장.
  - **단점**:
    - 복잡한 로직, 개발 비용 증가.
    - Redis 장애 시 서비스 전체 영향.

### 2.2. 락 선택 기준
- **낙관적 락**: 경합 적고, 실패 처리 가능 시.
- **비관적 락**: 순차 처리 필수, 빠른 처리 필요 시.
- **분산 락**: 분산 환경, DB 부하 분산 필요 시.

### 2.3. 분산 락 문제 사례
#### 잘못된 구현 예시
```java
@Transactional
public void charge(Long userId, BigDecimal point) {
    RLock lock = redissonClient.getLock("userChargeLock");
    try {
        if (lock.tryLock()) {
            User user = userRepository.findById(userId);
            user.charge(point);
        } else {
            throw new LockAccruedFailedException();
        }
    } finally {
        lock.unlock();
    }
}

@Transactional
public void pay(Long userId, BigDecimal point) {
    RLock lock = redissonClient.getLock("userPayLock");
    try {
        if (lock.tryLock()) {
            User user = userRepository.findById(userId);
            user.pay(point);
        } else {
            throw new LockAccruedFailedException();
        }
    } finally {
        lock.unlock();
    }
}
```

**문제점**:
1. **트랜잭션과 락 순서**:
   - `@Transactional`이 락 획득 전 시작 → 락 획득 전 트랜잭션 시작 → 데이터 정합성 이슈.
2. **다른 키 사용**:
   - `userChargeLock`과 `userPayLock`으로 키 분리 → 동일 사용자에 대해 충전/결제 동시 수행 가능.
   - 예: 잔액 1만 원 → 충전 10만 원(11만 원) → 결제 5만 원 → 잔액 부족 이슈 발생 가능.
3. **전체 사용자 단일 락**:
   - 모든 사용자가 동일 락 공유 → 병목 현상.
   - 예: 10만 명 사용자 모두 동일 락 대기.

#### 모범 답안
```java
public void charge(Long userId, BigDecimal point) {
    RLock lock = redissonClient.getLock("user:" + userId);
    try {
        if (lock.tryLock()) {
            executeInTransaction(() -> {
                User user = userRepository.findById(userId);
                user.charge(point);
            });
        } else {
            throw new LockAcquireFailedException();
        }
    } finally {
        lock.unlock();
    }
}

public void pay(Long userId, BigDecimal point) {
    RLock lock = redissonClient.getLock("user:" + userId);
    try {
        if (lock.tryLock()) {
            executeInTransaction(() -> {
                User user = userRepository.findById(userId);
                user.pay(point);
            });
        } else {
            throw new LockAcquireFailedException();
        }
    } finally {
        lock.unlock();
    }
}

@Transactional
private void executeInTransaction(Runnable runnable) {
    runnable.run();
}
```

**개선점**:
- **트랜잭션 순서**: 락 획득 후 트랜잭션 시작.
- **사용자별 락**: `"user:{userId}"`로 사용자별 고유 락 → 병목 감소.
- **동일 자원 보호**: 충전/결제 동일 키 사용 → 동시성 문제 방지.

### 2.4. 키 관리 전략
- **프리픽스 활용**: 키를 기능별로 구분 (예: `ranking:*`, `coupon:*`).
- **키 크기 제한**:
  - 공식 문서: 최대 512MB.
  - 실무 권장: 500KB 이하.
  - 긴 키는 해시로 변환 (64KB 또는 128KB 유지).
- **문제 사례**:
  - 포인트, 쿠폰, 마일리지 등 자원별 키 관리 부족 → 데이터 정합성 이슈.
  - 예: 동일 사용자에 대해 포인트와 마일리지가 겹치지 않도록 키 설계 필요.

---

## 3. Redis 동작 원리

### 3.1. Redis의 특징
- **인메모리 저장소**:
  - RAM 기반 → SSD(마이크로초) 대비 약 1000배 빠른 나노초 단위 처리.
  - 예: L1/L2/L3 캐시보다 빠름.
- **싱글 스레드 이벤트 루프**:
  - 단일 스레드에서 이벤트 루프 실행 → 메모리 기반 동시성 이슈 감소.
  - 멀티 스레드 I/O → 단일 스레드 이벤트 루프 처리.
  - 예: 32코어 CPU에서 이벤트 루프는 단일 코어(예: 4번째 코어)만 사용.
- **비교: Node.js**:
  - Node.js도 싱글 스레드, 논블로킹 I/O 제공.
  - 하지만 Redis는 메모리 기반으로 더 빠르며, 동시성 이슈 관리에 유리.
- **용도**:
  - **NoSQL 저장소**: Key-Value 기반 데이터 저장.
  - **분산 락**: Redisson 기반 락 관리.
  - **메시지 큐**: Pub/Sub 패턴.
  - **캐싱**: DB 부하 감소.

### 3.2. 루아 스크립트 주의점
- **문제점**:
  - 루아 스크립트는 처리 속도 느림 (나노초 → 밀리초).
  - 싱글 스레드 환경에서 병목 및 레이턴시 증가.
  - 처리량 감소 위험.
- **권장사항**:
  - 루아 스크립트 최소화.
  - Redis 기본 자료구조 활용 우선.
- **비유**: MSSQL의 Stored Procedure, Oracle의 PL/SQL과 유사 → 관리 복잡.

---

## 4. Redis 자료구조

### 4.1. Strings
- **특징**: 단일 키에 문자열(최대 512MB) 저장.
- **활용**: 캐싱, 재고 관리 (예: `SET`, `INCR`, `DECR`).

### 4.2. Sets
- **특징**:
  - 중복 불허, 순서 보장 안 함.
  - 집합 연산 지원 (예: `SADD`, `SINTER`).
- **활용**: 쿠폰 발급 중복 방지, 태그 관리.

### 4.3. Sorted Sets
- **특징**:
  - 스코어 기반 오름차순 정렬.
  - 동일 스코어 시 사전순 정렬.
  - 명령어: `ZADD`, `ZRANGE`, `ZINCRBY`.
- **활용**:
  - 실시간 랭킹 (예: 인기 상품, 매진 콘서트).
  - 대기열 관리 (스코어: 시간).

### 4.4. 기타 자료구조
- **Hash**: 객체 기반 Key-Value 관리.
- **List**: 순서 보장, 중복 허용.
- **Bitmap/Bitfield**: 비트 단위 연산.

---

## 5. STEP 13: 랭킹 시스템 설계

### 5.1. 목표
- **이커머스**: 가장 많이 주문된 상품 랭킹 (Sorted Set).
- **콘서트**: 빠르게 매진된 공연 랭킹 (Sorted Set).

### 5.2. 설계 포인트
- **Sorted Set 활용**:
  - 키: `ranking:daily:{date}`.
  - 멤버: 상품/공연 ID.
  - 스코어: 주문 수(이커머스), 매진 시간(콘서트).
- **구현**:
  - 주문/매진 시: `ZINCRBY`로 스코어 증가.
  - 상위 조회: `ZREVRANGE 0 9 WITHSCORES`.
  - 순위 조회: `ZREVRANK`.
- **TTL**: 일간 랭킹 → `EXPIRE`로 하루 만료.

### 5.3. 예시
- **이커머스**:
  - 상품 주문: `ZINCRBY ranking:daily:20250816 1 product123`.
  - 상위 10개: `ZREVRANGE ranking:daily:20250816 0 9 WITHSCORES`.
- **콘서트**:
  - 매진 시간: `ZADD ranking:daily:20250816 1629115200 concert456`.
  - 상위 10개: `ZREVRANGE ranking:daily:20250816 0 9 WITHSCORES`.

---

## 6. STEP 14: 비동기 시스템 설계

### 6.1. 목표
- **이커머스**: 선착순 쿠폰 발급 로직 개선 (Redis로 이관).
- **콘서트**: 대기열 토큰 발급 및 관리 (Redis 기반).

### 6.2. 쿠폰 발급 설계
- **구현**:
  - **재고 관리**: List (`LPUSH`, `LPOP`) 또는 Sorted Set.
  - **중복 방지**: Set (`SADD`).
  - **원자성**: Redis 명령어로 동시성 보장.
- **예시**:
  - 재고 설정: `LPUSH coupon:stock:coupon123 100`.
  - 발급: `SADD coupon:issued:coupon123 user123`, `LPOP coupon:stock:coupon123`.
  - TTL: `EXPIRE coupon:issued:coupon123 86400`.

### 6.3. 대기열 설계
- **구현**:
  - **대기열**: Sorted Set (`ZADD`, 스코어: 시간).
  - **활성 큐**: Set (`SADD`).
  - **스케줄러**: 상위 N명 이동 (`ZRANGE`, `SADD`, `ZREM`).
- **예시**:
  - 대기열 추가: `ZADD waiting:concert456 1629115200 user123`.
  - 활성 이동: `ZRANGE waiting:concert456 0 29`, `SADD active:concert456 user123`.

---

## 7. DB와 Redis 분리 주의점
- **데이터 정합성**:
  - Redis와 DB 동기화 로직 필요.
  - 트랜잭션과 락 순서 명확히 정의.
- **저장소 역할**:
  - Redis: 실시간 처리 (랭킹, 쿠폰, 대기열).
  - DB: 영구 저장, 최종 정합성.
- **TTL 관리**: Redis 데이터 만료 시간 설정.
- **키 관리**: 기능별 키 구분, 프리픽스 활용.

---

## 8. 추가 강조사항
- **PR 템플릿 준수**:
  - 명확한 PR 작성 → 동료 및 리뷰어 시간 절약.
- **자료구조 선택**:
  - 각 스텝에 적합한 Redis 자료구조 논의.
  - 예: 쿠폰 발급 → Set (중복 방지), List (재고 관리).
- **팀 논의**:
  - 조원 간 Redis 자료구조 선택 및 DB-Rediss 정합성 유지 방안 논의.

---

## 9. 마무리
- **질문 시간**: 발제 후 질문을 통해 추가 학습.
- **권장 행동**:
  - Redis 공식 문서 및 기술 블로그 참고.
  - 팀별 키 관리 전략 공유 (예: 1조의 디스코드 공유).
- **과제**:
  - **STEP 13**: Sorted Set 기반 랭킹 시스템.
  - **STEP 14**: Redis로 쿠폰 발급/대기열 이관.
  - PR 템플릿 준수 및 상세 보고서 작성.