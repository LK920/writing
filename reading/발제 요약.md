# 대용량 트래픽 환경에서의 동시성 제어와 캐싱 전략

이 문서는 2025년 8월 9일 발제 발표 대본과 제공된 문서를 기반으로, 대용량 트래픽 환경에서 동시성 제어와 캐싱 전략을 학습하기 위해 구조화된 자료입니다. 초보자부터 현업 개발자까지 이해할 수 있도록 단계별로 정리되었으며, 실습 중심의 학습 로드맵을 포함합니다. 특히, 분산락 구현 시 락과 트랜잭션 순서 보장 및 동일 자원에 대한 락 키 통일의 중요성을 반영하여 수정된 코드 예시를 추가하였습니다.

---

## 📚 학습 목표
- **동시성 제어**: 대규모 트래픽 환경에서 데이터 정합성을 유지하기 위해 낙관적/비관적 락 및 분산락을 이해하고 적용한다.
- **캐싱 전략**: DB 부하를 줄이고 조회 성능을 최적화하기 위해 적절한 캐싱 전략을 설계하고 구현한다.
- **실습 중심 학습**: Redis를 활용한 분산락과 캐싱을 실제 시나리오에 적용하며, 성능 개선 효과를 분석한다.

---

## 🛠 핵심 개념

### 1. 동시성 이슈와 락 전략

#### 1.1 동시성 이슈란?
동시성 이슈는 여러 요청이 동시에 동일한 자원(예: 재고, 쿠폰)을 수정하려고 할 때 발생합니다. 예를 들어, 100개의 쿠폰을 100명에게 발행해야 하지만 동시성 제어 실패로 2,000명에게 발행되는 경우, 이는 서비스 신뢰도와 금전적 손실로 이어질 수 있습니다.

**현업 사례**:
- **쿠폰 발급**: 제한된 쿠폰이 초과 발행됨.
- **콘서트 예약**: 동일한 좌석이 중복 예약됨.
- **재고 관리**: 재고가 음수로 감소하거나 초과 차감됨.

**질문**:
- 동시성 이슈는 왜 발생하나요?  
  → 동시에 동일한 자원을 수정하려는 경쟁 조건(Race Condition) 때문입니다.

#### 1.2 락 전략: 낙관적 락 vs 비관적 락
락은 동시성 이슈를 방지하기 위해 자원에 대한 접근을 제어하는 메커니즘입니다.

- **낙관적 락 (Optimistic Lock)**:
  - **특징**: 충돌이 드물 것이라고 가정하고, 데이터 수정 시 버전 정보를 확인하여 충돌 여부를 판단.
  - **적합 상황**:
    - 수정 실패가 비즈니스 로직에 큰 영향을 미치지 않는 경우.
    - 동시 수정 요청이 적은 경우 (재시도로 해결 가능).
  - **예시**: 10만 명이 동시에 요청할 때, 1명만 성공하고 나머지 9만 9,999명은 재시도.
  - **장점**: DB 부하가 적고, 구현이 간단.
  - **단점**: 충돌이 빈번하면 재시도 비용 증가.

- **비관적 락 (Pessimistic Lock)**:
  - **특징**: 자원에 대한 락을 선점하여 다른 요청을 대기시킴.
  - **적합 상황**:
    - 순서대로 처리해야 하는 작업.
    - 빠른 처리가 필요한 경우.
  - **예시**: 10만 명 요청 중 1명이 락을 획득하고 나머지는 DB에서 대기.
  - **장점**: 확실한 순서 보장, 빠른 처리.
  - **단점**: 락 범위가 크면 대기 시간 증가, 다른 테이블 조회에도 영향 가능.

**질문**:
- 낙관적 락과 비관적 락 중 어느 것이 더 적합할까요?  
  → 트래픽 양과 비즈니스 요구사항(실패 허용 여부)에 따라 다릅니다. 예를 들어, 쿠폰 발급은 비관적 락, 조회 중심 로직은 낙관적 락이 적합할 수 있습니다.

#### 1.3 분산 환경에서의 동시성 제어
단일 DB에서는 락으로 동시성을 제어할 수 있지만, MSA(Microservices Architecture) 환경에서는 주문 DB와 결제 DB가 분리되어 있어 동일한 트랜잭션과 락을 적용하기 어렵습니다. 이를 해결하기 위해 **분산락(Distributed Lock)**을 사용합니다.

- **분산락의 필요성**:
  - 서로 다른 서버/클러스터 간 데이터 일관성 보장.
  - DB 부하를 줄이고, 외부 리소스(Redis 등)를 통해 락 관리.
- **중요 고려사항**:
  - **락-트랜잭션 순서**: 락 획득 → 트랜잭션 시작 → 비즈니스 로직 → 트랜잭션 커밋 → �락 해제 순서를 반드시 지켜야 함.
  - **동일 자원에 대한 락 키 통일**: 예를 들어, 사용자 잔액을 수정하는 충전과 결제는 동일한 �락 키를 사용해야 동시성 이슈를 방지.

- **Redis를 활용한 분산락**:
  - **특징**: Redis의 원자적 연산(SETNX 명령어)을 활용해 키 선점을 통해 락을 획득.
  - **방식**:
    - **Simple Lock**: 락 획득 실패 시 즉시 예외 발생.
    - **Spin Lock**: 락 획득 실패 시 일정 시간/횟수 재시도.
    - **Pub/Sub Lock**: 락 해제 이벤트를 구독하여 효율적으로 대기.
  - **문제점 예시**:
    - **트랜잭션 선행 시**: 락 획득 전에 데이터를 조회하면 동시 요청이 동일 데이터를 읽어 데이터 불일치 발생.
    - **락 해제 선행 시**: 트랜잭션 커밋 전에 락이 해제되면 다른 요청이 커밋 전 데이터를 읽음.
    - **다른 락 키 사용 시**: 충전과 결제가 동일 자원(잔액)을 수정하는데 다른 락 키를 사용하면 동시 수정 가능.

**질문**:
- 락을 먼저 획득하지 않고 트랜잭션을 시작하면 어떤 문제가 발생하나요?  
  → 다른 요청이 락 획득 전에 데이터를 조회해 동시성 이슈 발생(예: 재고 초과 차감).

---

### 2. 캐싱 전략

#### 2.1 캐싱이란?
캐싱은 데이터를 임시로 저장하여 빠른 조회를 가능하게 하는 기술입니다. DB I/O 비용을 줄이고, API 응답 속도를 향상시킵니다.

**현업 사례**:
- **DNS 캐싱**: 웹사이트 IP를 저장해 조회 속도 향상.
- **CPU 캐싱**: 자주 접근하는 데이터를 메모리에 저장.
- **CDN**: 이미지/영상 콘텐츠를 캐싱해 서버 부하 감소.

#### 2.2 캐싱 전략
- **메모리 캐싱 (Application Level)**:
  - **특징**: 애플리케이션 메모리에 데이터를 저장.
  - **장점**:
    - 빠른 응답 속도.
    - 별도 네트워크 비용 없음.
  - **단점**:
    - 휘발성(애플리케이션 종료 시 데이터 삭제).
    - 메모리 부족 가능성.
    - 분산 환경에서 데이터 불일치 문제.
  - **예시 코드** (Spring Cacheable):
    ```java
    @Cacheable(value = "popularItems", key = "'daily'")
    public List<PopularItem> getPopularItems() {
        return statisticsService.findPopularItems();
    }
    ```

- **외부 캐싱 (Redis 등)**:
  - **특징**: 별도 캐시 스토리지(Redis)를 통해 데이터 관리.
  - **장점**:
    - 분산 환경에서 데이터 일관성 보장.
    - 안정성(스냅샷 저장으로 장애 복구 용이).
    - 고가용성(HA 구성 가능).
  - **단점**: 네트워크 비용 및 추가 서버 비용 발생.
  - **예시**: Redis에 인기 상품 데이터를 TTL과 함께 저장.

#### 2.3 캐시 관리 전략
- **Expiration**: 캐시 데이터에 유효기간(TTL)을 설정해 자동 삭제.
  - 예: 인기 상품 데이터를 24시간마다 갱신.
- **Eviction**: 명시적으로 캐시를 삭제(스케줄러 또는 관리자 요청).
  - 예: 인기 상품이 변경되면 캐시 강제 갱신.

**질문**:
- 캐시 스탬피드(Cache Stampede)란 무엇인가요?  
  → 캐시가 동시에 만료되어 다수 요청이 DB로 몰리는 현상. TTL을 랜덤화하거나 Lock을 사용해 방지 가능.

---

## 🔍 학습 로드맵

### 10시간 학습 로드맵

#### Day 1: 동시성 이슈와 락 전략 이해
- **목표**: 동시성 이슈를 실제 사례와 연관지어 이해하고, 락 선택 기준을 학습.
- **활동**:
  - 낙관적/비관적 락의 판단 기준 정리.
  - 동시성 이슈 시나리오 상상(예: 쿠폰 초과 발급).
- **자가진단**:
  - 낙관적/비관적 락의 사용 시점을 구분할 수 있나요? (1~5점)
  - 락 충돌 발생 상황을 설명할 수 있나요? (1~5점)

#### Day 2: Redis 분산락 구현
- **목표**: Redis 기반 분산락을 구현하고, 락-트랜잭션 순서의 중요성을 이해.
- **활동**:
  - Simple Lock 구현.
  - 락-트랜잭션 순서 문제 사례 분석.
  - Pub/Sub 기반 락 구조 학습.
- **자가진단**:
  - Redis 락 획득/해제 플로우를 설명할 수 있나요? (1~5점)
  - 락 순서 보장의 필요성을 이해했나요? (1~5점)

#### Day 3: 캐시 전략 설계
- **목표**: 메모리 캐시와 외부 캐시의 차이를 이해하고, 캐시 일관성 문제를 학습.
- **활동**:
  - 메모리 캐시 vs Redis 캐시 비교.
  - Cache Miss 대응 전략 고민.
  - 분산 환경 캐시 일관성 이슈 정리.
- **자가진단**:
  - Expiration과 Eviction의 차이를 설명할 수 있나요? (1~5점)
  - 캐시 일관성 문제의 원인을 설명할 수 있나요? (1~5점)

#### Day 4: 분산락 & 캐시 실습
- **목표**: 주문/예약/결제 시나리오에 분산락과 캐시를 적용하고, 성능 개선을 문서화.
- **활동**:
  - Redis 분산락 적용 실습.
  - 조회 API에 캐시 적용.
  - 성능 비교 보고서 작성.
- **자가진단**:
  - 분산락과 캐시 적용을 완료했나요? (1~5점)
  - 성능 차이를 수치로 표현할 수 있나요? (1~5점)

---

### 3시간 압축 학습 가이드

#### 세션 1: 낙관적/비관적 락 (40분)
- **핵심**: 동시성 문제의 심각성과 락 선택 기준 이해.
- **퀴즈**:
  - 낙관적 락이 적합한 상황은?
  - 비관적 락의 주의점은?

#### 세션 2: Redis 분산락 (40분)
- **핵심**: Redis로 분산락 구현 및 락-트랜잭션 순서 보장.
- **퀴즈**:
  - Simple/Spin/Pub/Sub 방식의 차이는?
  - 락을 먼저 잡지 않을 경우 문제는?

#### 세션 3: 캐시 전략 (40분)
- **핵심**: 캐시로 조회 부하 감소 및 일관성 유지.
- **퀴즈**:
  - 메모리 캐시와 외부 캐시의 차이는?
  - Expiration과 Eviction의 차이는?

#### 세션 4: 종합 실습 플랜 (20분)
- **핵심**: 분산락과 캐시를 함께 적용해 성능과 일관성 보장.
- **퀴즈**:
  - 락과 캐시 적용 시 주의점은?
  - 캐시 일관성 문제 해결 방법은?

---

## 📝 과제 요구사항

### STEP 11: Distributed Lock
- **목표**: Redis 기반 분산락을 구현하고, 주문/예약/결제 기능에 적용.
- **요구사항**:
  - 적절한 키와 범위로 분산락 적용.
  - 락-트랜잭션 순서 보장(락 획득 → 트랜잭션 시작 → 비즈니스 로직 → 트랜잭션 커밋 → 락 해제).
  - 동일 자원(예: 사용자 잔액)에 대해 충전/결제 간 동일한 락 키 사용.
  - 통합 테스트 작성(TestContainer 활용).
- **수정된 예시 코드** (Java with Redisson):
  ```java
  public void charge(Long userId, BigDecimal point) {
      RLock lock = redissonClient.getLock("userLock:" + userId); // 동일한 락 키
      try {
          if (lock.tryLock(5, 10, TimeUnit.SECONDS)) { // 락 획득 (5초 대기, 10초 유지)
              TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager);
              transactionTemplate.execute(new TransactionCallback<Void>() {
                  @Override
                  public Void doInTransaction(TransactionStatus status) {
                      User user = userRepository.findById(userId)
                              .orElseThrow(() -> new IllegalArgumentException("User not found"));
                      user.charge(point);
                      return null;
                  }
              });
          } else {
              throw new LockAcquisitionFailedException("Failed to acquire lock for user: " + userId);
          }
      } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
          throw new RuntimeException("Lock acquisition interrupted", e);
      } finally {
          if (lock.isHeldByCurrentThread()) {
              lock.unlock();
          }
      }
  }

  public void pay(Long userId, BigDecimal point) {
      RLock lock = redissonClient.getLock("userLock:" + userId); // 동일한 락 키
      try {
          if (lock.tryLock(5, 10, TimeUnit.SECONDS)) {
              TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager);
              transactionTemplate.execute(new TransactionCallback<Void>() {
                  @Override
                  public Void doInTransaction(TransactionStatus status) {
                      User user = userRepository.findById(userId)
                              .orElseThrow(() -> new IllegalArgumentException("User not found"));
                      user.pay(point);
                      return null;
                  }
              });
          } else {
              throw new LockAcquisitionFailedException("Failed to acquire lock for user: " + userId);
          }
      } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
          throw new RuntimeException("Lock acquisition interrupted", e);
      } finally {
          if (lock.isHeldByCurrentThread()) {
              lock.unlock();
          }
      }
  }
  ```
- **코드 특징**:
  - **락-트랜잭션 순서 보장**: `TransactionTemplate`을 사용해 락 획득 후 트랜잭션 시작.
  - **동일 락 키 사용**: 충전과 결제가 동일한 `userLock:<userId>` 키를 사용해 동시성 이슈 방지.
  - **안전한 락 해제**: `isHeldByCurrentThread()`로 현재 스레드의 락 소유 확인 후 해제.
  - **예외 처리**: `InterruptedException` 처리 및 사용자 조회 실패 시 적절한 예외 던짐.

### STEP 12: Cache
- **목표**: 조회 성능 개선을 위해 Redis 기반 캐싱 전략 적용.
- **요구사항**:
  - 조회가 오래 걸리거나 자주 변하지 않는 데이터에 캐시 적용.
  - 성능 개선 보고서 작성.
- **예시 코드** (Spring Cache with Redis):
  ```java
  @Cacheable(value = "popularItems", key = "'daily'")
  public List<PopularItem> getPopularItems() {
      return statisticsService.findPopularItems();
  }

  @Scheduled(cron = "0 0 0 * * *")
  @CacheEvict(value = "popularItems", key = "'daily'")
  public void evictPopularItemsCache() {}
  ```

---

## 🚥 과제 평가 기준

### STEP 11: Distributed Lock
- **P/F 기준**:
  - 분산락의 적절한 적용 여부.
  - 락과 트랜잭션 순서 보장(락 획득 → 트랜잭션 → 커밋 → 락 해제).
  - 충전/결제 간 동일 락 키 사용.
  - 통합 테스트로 동시성 검증.
- **BP 기준**:
  - RedisTemplate을 활용한 의존성 최소화.
  - 동시성 이슈 원인 분석 및 최적화(예: Pub/Sub 락, 지수 백오프).
  - 통합 테스트에서 동시 요청 시나리오 검증.

### STEP 12: Cache
- **P/F 기준**:
  - 캐시 가능 구간 분석 및 적용.
  - 성능 개선 보고서 완성도.
- **BP 기준**:
  - 캐시 전략(LookAside, WriteThrough)의 명확한 이해.
  - 캐시 스탬피드 방어 전략 포함(예: TTL 랜덤화).
  - 보고서의 구조화(배경, 해결, 테스트, 한계점, 결론).

---

## 🧠 핵심 역량

### Distributed Lock
- **Transaction 이해**: 작업 단위로서의 트랜잭션 개념.
- **분산락 구현**: Redis의 원자성을 활용한 락 설계.
- **순서 보장**: 락-트랜잭션 순서 및 동일 락 키 사용으로 동시성 이슈 방지.

### Cache
- **성능 분석**: 트래픽 병목 지점 파악 및 캐시 포인트 선정.
- **캐시 전략**: TTL, Eviction, Cache-Aside 패턴 설계.
- **안정성**: Cache Stampede 및 데이터 불일치 방지.

---

## 🧪 통합 테스트 예시
Redis와 DB 환경에서 동시 요청 시나리오를 검증하는 테스트 코드입니다.

```java
@Test
void testConcurrentChargeAndPay() throws InterruptedException {
    ExecutorService executor = Executors.newFixedThreadPool(2);
    CountDownLatch latch = new CountDownLatch(2);
    
    executor.submit(() -> {
        service.charge(1L, BigDecimal.valueOf(50));
        latch.countDown();
    });
    executor.submit(() -> {
        service.pay(1L, BigDecimal.valueOf(30));
        latch.countDown();
    });
    
    latch.await(10, TimeUnit.SECONDS);
    User user = userRepository.findById(1L).get();
    assertEquals(BigDecimal.valueOf(120), user.getBalance()); // 초기 100 + 50 - 30
}
```

---

## 📌 PR 템플릿
```markdown
## :pushpin: PR 제목 규칙
[STEP0X] 이름 - 선택 시나리오 (e-commerce/concert)

---
### **핵심 체크리스트** :white_check_mark:

#### :one: 분산락 적용 (3개)
- [ ] 적절한 곳에 분산락이 사용되었는가? 
- [ ] 트랜잭션 순서와 락순서가 보장되었는가?
- [ ] 충전/결제 간 동일 락 키가 사용되었는가?

#### :two: 통합 테스트 (2개)
- [ ] infrastructure 레이어를 포함하는 통합 테스트가 작성되었는가?
- [ ] 핵심 기능에 대한 흐름이 테스트에서 검증되었는가?
- [ ] 동시성을 검증할 수 있는 테스트코드로 작성 되었는가?
- [ ] Test Container 가 적용 되었는가?

#### :three: Cache 적용 (3개)
- [ ] 적절하게 Key 적용이 되었는가?

---
#### STEP11
- [ ] Redis 분산락 적용
- [ ] Test Container 구성
- [ ] 기능별 통합 테스트

#### STEP12
- [ ] 캐시 필요한 부분 분석
- [ ] redis 기반의 캐시 적용
- [ ] 성능 개선 등을 포함한 보고서 제출

### **간단 회고** (3줄 이내)
- **잘한 점**: 
- **어려운 점**: 
- **다음 시도**:
```

---

## 🔗 추가 참고 자료
- [Redis 분산락 구현 가이드](https://notspoon.tistory.com/48)
- [Spring Cache 문서](https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#cache)
- [Redisson 공식 문서](https://github.com/redisson/redisson/wiki)