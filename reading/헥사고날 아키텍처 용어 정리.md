

헥사고날 아키텍처(포트와 어댑터 패턴)는 도메인 로직을 중심에 두고 외부 시스템과의 상호작용을 분리하는 설계 방식입니다. 하지만 용어들이 모호하게 사용되거나, 다른 아키텍처(예: 클린 아키텍처, DDD)와 혼용되어 혼란을 일으킬 수 있습니다. 이 문서는 헥사고날 아키텍처에서 자주 등장하는 용어들을 명확히 정의하고 구분합니다.

## 1. 주요 구성 요소

### 도메인 레이어 (Domain Layer)
- **정의**: 애플리케이션의 핵심 비즈니스 로직과 도메인 모델을 포함하는 레이어. 외부 시스템에 의존하지 않으며, 순수한 비즈니스 규칙을 구현.
- **구성 요소**:
  - **엔터티(Entity)**: 비즈니스 객체(예: `Order`, `User`)와 그에 따른 비즈니스 규칙.
  - **도메인 서비스(Domain Service)**: 엔터티 간의 복잡한 비즈니스 로직을 처리. (예: `OrderDomainService`가 주문 상태 변경 로직 처리)
- **특징**: 외부 시스템(DB, API 등)에 대한 의존성을 완전히 배제.
- **예시**: `Order` 클래스가 주문의 상태를 관리하거나, `OrderDomainService`가 주문 할인 계산 로직을 수행.

### 포트 (Port)
- **정의**: 도메인과 외부 시스템 간의 인터페이스를 정의하는 계약(Contract). 도메인 레이어에 속하며, 외부 시스템과의 상호작용 방식을 명세.
- **종류**:
  - **드라이빙 포트(Driving Port)**:
    - 외부 시스템(예: UI, REST API)이 도메인을 호출하기 위한 인터페이스.
    - 예: `OrderService` 인터페이스 (`createOrder(OrderRequest)` 메서드 포함).
    - 역할: 외부 입력을 받아 도메인 로직을 실행.
  - **드리븐 포트(Driven Port)**:
    - 도메인이 외부 시스템(예: DB, 메시지 큐)을 호출하기 위한 인터페이스.
    - 예: `OrderRepository` 인터페이스 (`findOrderById(Long id)`, `saveOrder(Order order)` 포함).
    - 역할: 도메인 로직이 외부 시스템에 접근할 때 추상화된 방식 제공.
- **특징**:
  - 도메인 레이어의 경계(Boundary)에 위치.
  - 외부 시스템의 구현 세부사항(DB 종류, 프로토콜 등)을 알지 못함.
  - 의존성 역전 원칙(DIP)을 따르며, 도메인은 포트에만 의존.
- **위치**: 도메인 레이어 안에 있지만, 외부 시스템과의 연결을 정의하는 경계 역할.
- 실무에서 드라이빙 포트는 보통 "서비스 인터페이스"로, 드리븐 포트는 "리포지토리 인터페이스"로 불리며, 이게 헥사고날 용어와 섞여 혼란을 일으킴.

### 어댑터 (Adapter)
- **정의**: 포트를 구현하여 도메인과 외부 시스템을 실제로 연결하는 구성 요소. 인프라 레이어에 속함.
- **종류**:
  - **드라이빙 어댑터(Driving Adapter)**: 드라이빙 포트를 호출하여 외부 입력을 도메인에 전달.
    - 예: REST 컨트롤러가 `OrderService` 포트를 호출해 HTTP 요청 처리.
  - **드리븐 어댑터(Driven Adapter)**: 드리븐 포트를 구현하여 도메인이 외부 시스템에 접근하도록 연결.
    - 예: `JdbcOrderRepositoryAdapter`가 `OrderRepository` 포트를 구현해 DB와 통신.
- **특징**:
  - 외부 시스템의 세부 구현(예: JDBC, HTTP 클라이언트)을 처리.
  - 도메인과 외부 시스템 간의 데이터 변환(예: DTO ↔ 엔터티) 담당.
- **위치**: 인프라 레이어에 속하며, 헥사고날 아키텍처에서 가장 바깥쪽 레이어.

### 인프라 레이어 (Infrastructure Layer)
- **정의**: 실제 외부 시스템(DB, 네트워크, 파일 시스템 등)과의 구현을 처리하는 레이어.
- **구성 요소**:
  - 어댑터(드라이빙/드리븐 어댑터).
  - 외부 시스템과의 직접적인 연결 코드(예: JDBC 드라이버, HTTP 클라이언트).
- **특징**: 도메인 로직과 독립적이며, 어댑터를 통해 포트와 연결.
- **예시**: MySQL DB, RabbitMQ 클라이언트, 외부 API 호출 코드.

## 2. 혼란스러운 용어 구분

### 서비스 (Service) vs 유스케이스 (Use Case)
- **서비스 (Service)**:
  - **정의**: 비즈니스 로직을 처리하는 클래스나 모듈. 헥사고날 아키텍처에서는 도메인 레이어 또는 애플리케이션 레이어(유스케이스 레이어)에 속함.
  - **종류**:
    - **도메인 서비스**: 엔터티 간의 복잡한 비즈니스 로직을 처리. (예: `OrderDomainService`가 주문 할인 계산).
    - **애플리케이션 서비스**: 유스케이스를 구현하며, 도메인 로직과 외부 시스템(포트를 통해)을 조율. (예: `OrderApplicationService`가 주문 생성 워크플로우 관리).
  - **특징**:
    - "서비스"는 전통적인 계층형 아키텍처와 DDD에서 유래된 용어로, 헥사고날 아키텍처에서는 드라이빙 포트로 구현되거나 도메인 서비스로 나뉨.
    - 실무에서 여러 유스케이스를 하나의 서비스 클래스에 묶는 경우가 많아 모호성 발생.
  - **예시**:
    - `OrderService`가 `createOrder`, `cancelOrder` 등 여러 유스케이스를 처리.

- **유스케이스 (Use Case)**:
  - **정의**: 애플리케이션의 특정 비즈니스 시나리오(예: "주문 생성", "주문 취소")를 나타냄. 클린 아키텍처에서 주로 사용되지만, 헥사고날에서도 비슷한 개념으로 사용.
  - **특징**:
    - 단일 책임 원칙을 따르며, 하나의 유스케이스는 하나의 구체적인 작업을 처리.
    - 헥사고날에서는 드라이빙 포트로 표현되거나, 애플리케이션 서비스로 구현.
  - **예시**:
    - `CreateOrderUseCase`, `CancelOrderUseCase`처럼 특정 작업에 초점.
  - **서비스와의 차이**:
    - 유스케이스는 더 세분화된 단위(하나의 시나리오)로 정의되며, 서비스는 여러 유스케이스를 포괄할 수 있음.
    - 실무에서는 `OrderService`라는 이름으로 유스케이스를 구현하는 경우가 많아 혼용됨.

- **혼란 원인**:
  - "서비스"는 프레임워크(예: Spring의 `@Service`)와 DDD에서 널리 사용되며, 유스케이스와 역할이 겹침.
  - 개발자들이 `UseCase` 접미사보다 `Service`를 선호해 네이밍 관행으로 굳어짐.
- **해결책**:
  - 팀 내에서 네이밍 규칙을 명확히 정의(예: `UseCase` vs `Service`).
  - 유스케이스 단위로 클래스를 나누거나, 서비스 클래스 내에서 유스케이스를 구분.

## 3. 레이어 구조와 포트의 위치
헥사고날 아키텍처의 레이어 구조를 시각적으로 정리하면:

1. **도메인 레이어** (가장 안쪽):
   - 엔터티, 도메인 서비스, 포트(드라이빙/드리븐) 포함.
   - 포트는 도메인 레이어의 경계에 위치하며, 외부 시스템과의 상호작용을 정의.
2. **어댑터 레이어**:
   - 드라이빙 어댑터(외부 → 도메인)와 드리븐 어댑터(도메인 → 외부).
   - 포트를 구현하여 도메인과 외부 시스템 연결.
3. **인프라 레이어** (가장 바깥쪽):
   - 실제 외부 시스템(DB, API, 메시지 큐 등)과의 구현.

**포트의 위치**:
- 포트는 도메인 레이어 안에 있지만, 외부 시스템과의 경계(Boundary) 역할을 함.
- 드라이빙 포트는 외부 입력을 받아 도메인으로 전달.
- 드리븐 포트는 도메인이 외부 시스템에 접근하도록 추상화.
- **가장 바깥쪽 레이어는 아님**: 어댑터와 인프라 레이어가 그 바깥에 위치.

## 4. 예시: 주문 시스템
주문 시스템을 통해 용어와 구조를 이해해봅시다.

- **도메인 레이어**:
  - **엔터티**: `Order` (주문 데이터와 비즈니스 규칙).
  - **도메인 서비스**: `OrderDomainService` (주문 할인 계산).
  - **드라이빙 포트**: `OrderService` 인터페이스 (`createOrder(OrderRequest)`).
  - **드리븐 포트**: `OrderRepository` 인터페이스 (`findOrderById(Long id)`, `saveOrder(Order)`).
- **어댑터 레이어**:
  - **드라이빙 어댑터**: REST 컨트롤러가 `OrderService`를 호출해 HTTP 요청 처리.
  - **드리븐 어댑터**: `JdbcOrderRepositoryAdapter`가 `OrderRepository`를 구현해 DB와 통신.
- **인프라 레이어**:
  - MySQL DB, HTTP 클라이언트 등.

## 5. 혼란 방지를 위한 팁
- **명확한 네이밍 규칙**:
  - 드라이빙 포트: `OrderService`, `CreateOrderUseCase`.
  - 드리븐 포트: `OrderRepository`, `NotificationPort`.
  - 도메인 서비스: `OrderDomainService`.
  - 애플리케이션 서비스: `OrderApplicationService`.
- **문서화**: 아키텍처 다이어그램과 용어 정의를 팀과 공유.
- **단일 책임 원칙**: 유스케이스 단위로 클래스를 나누어 역할 명확화.
- **프레임워크와의 조화**: Spring의 `@Service`를 사용할 경우, 주석으로 유스케이스인지 도메인 서비스인지 명시.

## 6. 결론
헥사고날 아키텍처는 도메인 중심 설계를 통해 유연성과 유지보수성을 높이지만, 용어(서비스, 유스케이스, 포트 등)의 모호성으로 혼란이 발생할 수 있습니다. 포트는 드라이빙과 드리븐으로 나뉘며 도메인 레이어의 경계에 위치하고, 어댑터는 인프라 레이어에서 외부 시스템과 연결합니다. 명확한 네이밍과 문서화를 통해 혼란을 줄이고, 팀 내에서 용어 사용을 일관되게 유지하는 것이 중요합니다.