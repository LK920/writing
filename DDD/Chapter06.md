---
tags:
  - study
  - architecture
  - domain
  - ddd
  - 표현영역
  - 응용영역
aliases:
---
 본 문은 <도메인 주도 개발 시작하기> 도서의 챕터 6(응용 서비스와 표현 영역)를 학습하고 정리한 내용이다.
# 응용 서비스와 표현 영역
## 6.1 표현 영역과 응용 영역
![[스크린샷 2025-08-26 오후 9.30.56.png]]
	 표현 영역은 사용자의 요청을 해석, 응용역역은 실제 사용자가 원하는 기능을 제공
	 표현 영역 -> 응용 영역 : 요구하는 형식으로 데이터 생성
	 사용자와 상호작용은 표현 영역이 처리, 응용 영역은 표현 영역에 의존하지 않음
## 6.2 응용 서비스의 역할
- 사용자가 요청한 기능을 실행
- 도메인 객체를 사용해서 사용자의 요청을 처리
- 도메인 객체 간 흐름을 제어
```
public Result doSomeFunc(SomeReq req){

	// 1. 리포지터리에서 애그리거트를 구함
	SomeAgg agg = somAggRepository.findById(req.getId());
	checkNull(agg);
	
	// 2. 애그리거트의 도메인 기능을 실행
	agg.doFunc(req.getValue());
	
	// 3. 결과를 리턴
	return createSuccessResult(agg);
}
```
- 새로운 애그리거트를 생성
```
public Result doSomeCreation(CreateSomeReq req){
	// 1. 데이터 유효성 검사
	validate(req);
	// 2. 애그리거트를 생성
	SomeAgg newAgg = createSome(req);
	// 3. 리포지터리에 애그리거트 저장
	someAggRepository.save(newAgg);
	// 4. 결과를 리턴
	return createSuccessResult(newAgg);
}

```
- 트랜잭션 처리 담당
- 주의점
	- 응용 서비스가 복잡하다면 도메인 로직의 일부를 응용 서비스에서 구현하고 있을 가능성이 높음
		- 코드 중복, 로직 분상 등 코드 품질 저하
### 6.2.1 도메인 로직 넣지 않기
- 도메인 로직은 도메인 영역에만 구현
	- 응집성
	- 코드 중복
## 6.3 응용 서비스의 구현
	응용 서비스 = 표현 영역 <-> 도메인 영역 연결 매개체
### 6.3.1 응용 서비스의 크기
- 응용 서비스 구현 방식
	- 한 응용 서비스에 도메인의 모든 기능 구현
		```
			public class MemberService{
				// 각 기능을 구현하는 데 필요한 리포지터리, 도메인 서비스 필드 추가
				private MemberRepository memberRepository;
				private Notifier notifier;
				
				public void join(...) {...};
				publci void leave(...){...};
				
			}
			// 장점 : 동일 로직에 대한 코드 중복 제거
				-> join, leave 메서드에서 동일 코드가 있을 경우 한번에 처리 가능
			// 단점 : 클래스의 크기가 커짐 
				-> 연관성이 적은 코드가 한 클래스에 위치하게 됨 -> 유지 보수 힘들어짐
		```
	- 구분되는 기능별로 응용 서비스 따로 구현(추천)
		- 한 응용서비스 당 한 개 내지 2~3개 기능을 구현
		```
			public class ChangePasswordService{
				private MemberRepository memberRepository;
				private Notifier notifier;
				
				public void changePassword(String memberId, String current){}
			}
			// 장점 : 코드 품질 일정 수준 유지, 다른 기능에 영향 x
			// 단점 : 동일 로직 중복 가능성 O -> 공통 클래스는 별도 클래스로 구현
		```
### 6.3.2 응용 서비스의 인터페이스와 클래스
- 인터페이스가 필요한 때
	- 구현 클래스가 여러개일 경우
	- 런타임에 구현 객체를 교체해야할 때
	- ->인터페이스가 명확히 필요하기 전까진 작성할 필요는 없다
### 6.3.3 메서드 파라미터와 값 리턴
- 개별 파라미터, 데이터 클래스 등을 이용해서 전달 받음
- 애그리거트 그 자체로 리턴을 할 수 있지만 좋은 선택은 아님
	- -> 표현영역에서도 쓰이고, 응용 영역에서도 쓰이게 됨 -> 기능 실행 영역이 분산됨 -> 응집도가 낮아짐
- 응용 서비스는 표현영역에서 필요한 데이터만 리턴!
### 6.3.4 표현 영역에 의존하지 않기
- 응용 서비스 영역의 파라미터를 표현 영역과 관련된 타입을 사용해선 안됨
	- 예를 들어 HttpSevletReqeust 등등
	- 관련 타입을 사용시 응용 서비스는 표현영역에 의존하게 됨
### 6.3.5 트랜잭션 처리

## 6.4 표현 영역
- 표현 영역의 책임
	- 사용자가 시스템을 사용할 수 있는 흐름(화면)을 제공하고 제어
	- 사용자의 요청을 알맞는 응용 서비스에 전달하고 결과를 사용자에게 제공
	- 사용자의 세션을 관리
## 6.5 값 검증
	값 검증 : 응용 서비스와 표현 영역 모두 수행 가능
	응용 서비스에서 에러를 공통으로 에러를 처리한 뒤 -> 표현 영역에서 공통으로 잡아 리턴하는 방안
	표현 영역 : 필수 값, 값의형식, 범위 등을 검증
	응용 서비스 : 데이터의 존재 유무와 같은 논리적 오류를 검증
		-> 반드시 이렇게 할 필요는 없음, 응용 서비스에서 값검증이 일어나기도 함
## 6.6 권한 검사
- 권한검사 : 단순 인증, 관리자 여부, 실행 가능한 기능 등 다양한 권한검사 필요
	- -> 스프링 시큐리티 같은 프레임 워크 사용
- 권한 검사 수행 위치
	- 표현 영역 : 사용자 인증 여부
		- 서블릿 필터 에서 구현
	- 응용 서비스 : url 만으로 접근 제어 할 수 없는 경우 -> 메서드 단위로 권한 검사 실행
		- AOP 사용
			- `@PreAuthorize("hasRole('ADMIN')")`을 사용하기도 함
	- 도메인
		- 게시글 삭제는 본인 또는 관리자만 가능 -> 본인 확인 여부를 게시글 애그리거트를 먼저 조회해야함 -> 응용에서 할 수 없음 -> 도메인에서 직접 권한 검사 로직 구현