---
aliases:
  - 레디스_키관리
tags:
  - redis
---
# Redis 키(Key) 관리 가이드

## 기본 개요

Redis의 키 관리는 **효율적인 데이터 조회, 삭제, 만료 설정**을 통해 메모리를 효율적으로 관리하는 것입니다. 모든 자료구조는 공통된 키 관리 규칙을 따릅니다.

- **특징**: 자동 생성/삭제, 패턴 매칭, TTL(Time To Live) 설정
- **중요**: 키 관리 전략이 Redis 성능에 큰 영향을 미침
- **활용**: 메모리 최적화, 자동 정리, 데이터 만료

---

## 🎨 키의 자동 생성과 삭제 규칙

### 기본 동작 원리

```
규칙 1: 키가 없으면 자동 생성
┌─────────────────────────────────────────┐
│ LPUSH mylist "item1"                    │
│ ↓                                       │
│ "mylist" 키가 없음                      │
│ ↓                                       │
│ 자동으로 List 자료구조 생성             │
│ ↓                                       │
│ "item1" 추가                            │
│ ↓                                       │
│ OK 반환                                 │
└─────────────────────────────────────────┘

규칙 2: 모든 아이템 삭제 시 키도 자동 삭제
┌─────────────────────────────────────────┐
│ LPOP mylist                             │
│ (마지막 아이템 제거)                    │
│ ↓                                       │
│ "mylist" 키 자동 삭제                   │
│ ↓                                       │
│ KEYS * 조회하면 "mylist" 없음          │
└─────────────────────────────────────────┘

규칙 3: 읽기 커맨드는 키 없으면 빈 값 반환
┌─────────────────────────────────────────┐
│ LRANGE nonexistent 0 -1                 │
│ ↓                                       │
│ (empty array) 반환                      │
│ (에러 아님, 정상)                       │
└─────────────────────────────────────────┘

⚠️ 예외: Stream은 마지막 아이템 삭제 후에도 키 유지
XDEL stream_key message_id
→ Stream 키는 남아있음 (메모리 고려 필요)
```

### 자료구조별 동작

```
자동 생성/삭제 가능 자료구조:
✅ String      → APPEND, SET
✅ List        → LPUSH, RPUSH
✅ Set         → SADD
✅ Sorted Set  → ZADD
✅ Hash        → HSET
✅ Bitmap      → SETBIT
✅ HyperLogLog → PFADD

⚠️ 예외:
❌ Stream      → 메시지 삭제해도 키 유지 (XTRIM/EXPIRE 사용)
```

---

## 🔍 키 조회 커맨드

### 1. EXISTS: 키 존재 여부 확인

```
EXISTS key [key...]
```

**설명**: 하나 이상의 키가 존재하는지 확인합니다.

**예시**
```
EXISTS user:100 user:200 product:1
→ 반환: 2 (2개 키 존재)

EXISTS nonexistent
→ 반환: 0 (키 없음)
```

---

### 2. KEYS: 패턴 매칭으로 모든 키 조회

```
KEYS pattern
```

**설명**: 패턴에 맞는 모든 키를 조회합니다. (⚠️ 위험한 커맨드!)

**Glob 패턴 문법**

```
*       : 모든 문자 (0개 이상)
?       : 정확히 1개 문자
[abc]   : a, b, c 중 하나
[a-z]   : a~z 범위
[^ae]   : a, e 제외
```

**예시**

```
키 목록: user:100, user:200, product:1, order:1

KEYS user:*
→ user:100, user:200

KEYS *:1
→ product:1, order:1

KEYS u?er:*
→ user:100, user:200

KEYS [uo]*
→ user:100, user:200, order:1

KEYS *:[0-2]*
→ user:100, user:200, product:1
```

**⚠️ 주의사항**

```
KEYS는 위험한 커맨드!

문제:
- 모든 키를 조회하는 동안 Redis 블로킹
- 다른 모든 작업 대기
- 키가 많으면 fail-over 발생 가능

시나리오:
┌──────────────────────────┐
│ KEYS * 실행              │
├──────────────────────────┤
│ 10초 동안 작업 처리 중... │
│                          │
│ 이 시간에 다른 요청들:   │
│ - 대기 상태 ⏳           │
│ - 타임아웃 위험 ❌      │
│                          │
│ 결과: 성능 저하/연결 끊김│
└──────────────────────────┘

✅ KEYS 사용 시기:
- 개발/테스트 환경만
- 키가 매우 적을 때만
```

---

### 3. SCAN: 안전한 키 조회 (권장)

```
SCAN cursor [MATCH pattern] [COUNT count] [TYPE type]
```

**설명**: 커서 기반으로 일부 키만 조회하여 KEYS보다 안전합니다.

**파라미터**

```
cursor    : 스캔 위치 (0부터 시작)
MATCH     : 패턴 필터링 (KEYS와 같은 문법)
COUNT     : 반환 키 개수 (기본 10, 힌트일 뿐 정확하지 않음)
TYPE      : 자료구조 타입 (string, list, set 등)
```

**예시**

```
# 첫 번째 스캔
SCAN 0 MATCH user:* COUNT 10
→ 반환: ["21", ["user:100", "user:200", ...]]
        (커서 21, 키 목록)

# 두 번째 스캔 (커서 21 사용)
SCAN 21 MATCH user:* COUNT 10
→ 반환: ["27", ["user:300", "user:400", ...]]

# 세 번째 스캔
SCAN 27 MATCH user:* COUNT 10
→ 반환: ["0", [...]]
        (커서 0 = 모든 키 조회 완료)
```

**실제 동작 예시**

```
저장된 키:
- user:100, user:200, user:300
- product:1, product:2
- order:1, order:2, order:3

SCAN 0 MATCH user:*
→ 1) "21"
   2) 1) "user:100"
      2) "user:200"

SCAN 21 MATCH user:*
→ 1) "0"
   2) 1) "user:300"

SCAN 0 TYPE string
→ 문자열 타입 키만 반환

SCAN 0 TYPE list
→ 리스트 타입 키만 반환
```

**SCAN의 장점**

```
KEYS vs SCAN 비교:

KEYS user:*
├─ Redis 블로킹 (동기)
├─ 모든 키 조회 (큼)
└─ 위험! ❌

SCAN 0 MATCH user:*
├─ 점진적 조회 (비동기)
├─ 일부 키만 반환
├─ 다른 작업 처리 가능 ✅
└─ 안전! 권장됨
```

**관련 커맨드** (같은 원리)

```
SSCAN key cursor [MATCH pattern] [COUNT count]   (Set용)
HSCAN key cursor [MATCH pattern] [COUNT count]   (Hash용)
ZSCAN key cursor [MATCH pattern] [COUNT count]   (Sorted Set용)
```

---

### 4. TYPE: 자료구조 타입 확인

```
TYPE key
```

**예시**

```
TYPE user:100
→ "string"

TYPE mylist
→ "list"

TYPE myset
→ "set"

TYPE nonexistent
→ "none"
```

---

### 5. OBJECT: 키의 상세 정보 조회

```
OBJECT <subcommand> <key>
```

**Subcommand 종류**

```
ENCODING   : 내부 저장 방식
IDLETIME   : 마지막 접근 후 경과 시간(초)
REFCOUNT   : 참조 수
FREQ       : 접근 빈도
```

**예시**

```
OBJECT ENCODING user:100
→ "raw" 또는 "int" 등

OBJECT IDLETIME mykey
→ 1234 (1234초 동안 접근 없음)

OBJECT REFCOUNT mykey
→ 1
```

---

### 6. RENAME / RENAMENX: 키 이름 변경

```
RENAME key newkey
RENAMENX key newkey
```

**차이점**

```
RENAME:
- 새 키가 있으면 덮어쓰기 ⚠️
- RENAME old_key new_key
  → new_key 기존 값 삭제 후 이름 변경

RENAMENX:
- 새 키가 있으면 실패
- 안전한 변경 (덮어쓰기 방지)
- RENAMENX old_key new_key
  → new_key 없을 때만 변경
```

**예시**

```
RENAME user:100 user:100_backup
→ user:100을 user:100_backup으로 변경

RENAMENX user:200 user:200_backup
→ user:200_backup 없으면 변경
→ user:200_backup 있으면 실패
```

---

### 7. COPY: 키 복사

```
COPY source destination [REPLACE]
```

**예시**

```
COPY user:100 user:100_copy
→ user:100_copy 없을 때만 복사

COPY user:100 user:100_backup REPLACE
→ 기존 user:100_backup 삭제하고 복사 ⚠️
```

---

### 8. SORT: 아이템 정렬

```
SORT key [BY pattern] [LIMIT offset count] 
         [GET pattern] [ASC|DESC] [ALPHA] [STORE destination]
```

**설명**: List, Set, Sorted Set의 아이템을 정렬합니다.

**예시**

```
# 숫자 정렬
SORT mylist
→ 숫자 오름차순 정렬

SORT mylist DESC
→ 내림차순

# 문자 정렬
SORT mylist ALPHA
→ 사전순 정렬

SORT mylist ALPHA DESC
→ 역순 정렬

# 일부만 조회
SORT mylist LIMIT 0 10
→ 0번부터 10개만

# 정렬 후 다른 키에서 데이터 가져오기
SORT ids GET user:*->name
→ id 정렬 후 user:{id}:name 값 반환
```

---

## 🗑️ 키 삭제 커맨드

### 1. DEL: 동기 삭제

```
DEL key [key...]
```

**특징**: 키와 모든 아이템을 **동기적으로** 삭제합니다.

**예시**

```
DEL user:100 user:200 order:1
→ 반환: 3 (3개 키 삭제)

DEL nonexistent
→ 반환: 0 (키 없음)
```

**문제점**

```
❌ 큰 데이터 삭제 시 문제:

SET mylist big_data (100MB)
DEL mylist
→ 메모리 해제하는 동안 Redis 블로킹
→ 다른 모든 작업 대기 ⏳
→ 응답 지연 ⚠️
```

---

### 2. UNLINK: 비동기 삭제 (권장)

```
UNLINK key [key...]
```

**특징**: 키를 **백그라운드에서** 비동기 삭제합니다.

**동작 원리**

```
UNLINK mylist
↓
1단계: 키와 데이터의 연결 끊기 (즉시)
→ Redis 응답 가능 ✅
↓
2단계: 메모리 해제 (백그라운드, 다른 스레드)
→ Redis 블로킹 없음
```

**예시**

```
# 큰 데이터 삭제 (안전)
UNLINK big_list big_set big_hash
→ 즉시 반환, 백그라운드에서 정리

# DEL vs UNLINK
DEL user:huge_data      ⏳ 10초 블로킹
UNLINK user:huge_data   ✅ 즉시 반환
```

**비교**

```
데이터가 큰 경우:

DEL:
  ├─ 메모리 해제 중... ⏳
  ├─ Redis 블로킹
  └─ 다른 작업 대기

UNLINK:
  ├─ 연결 끊음 (즉시)
  ├─ Redis 응답 ✅
  └─ 백그라운드 정리
```

---

### 3. FLUSHALL / FLUSHDB: 전체 데이터 삭제

```
FLUSHALL [ASYNC|SYNC]
FLUSHDB [ASYNC|SYNC]
```

**차이점**

```
FLUSHDB   : 현재 DB의 모든 키 삭제
FLUSHALL  : 모든 DB의 모든 키 삭제
```

**모드**

```
SYNC (기본):
- 모든 데이터 삭제될 때까지 대기
- Redis 블로킹 ⏳
- 완료 후 OK 반환

ASYNC:
- 백그라운드에서 삭제
- 즉시 OK 반환 ✅
- 다른 작업 계속 가능
```

**예시**

```
# 동기 (위험!)
FLUSHALL
→ 모든 데이터 삭제 완료까지 대기...

# 비동기 (권장)
FLUSHALL ASYNC
→ 즉시 OK 반환, 백그라운드 삭제
```

---

## ⏰ 키 만료 시간 (TTL) 관리

### 1. EXPIRE: 초 단위 TTL 설정

```
EXPIRE key seconds [NX|XX|GT|LT]
```

**설명**: 키가 지정된 시간 후에 자동으로 삭제됩니다.

**옵션**

```
NX : 키에 TTL이 없을 때만 설정
XX : 키에 TTL이 있을 때만 설정
GT : 새 TTL이 기존 TTL보다 클 때만 설정
LT : 새 TTL이 기존 TTL보다 작을 때만 설정
```

**예시**

```
# 기본 사용
SET session:abc "user123"
EXPIRE session:abc 3600
→ 1시간 후 자동 삭제 ✅

# 옵션 활용
EXPIRE session:abc 7200 NX
→ TTL 없을 때만 2시간 설정

EXPIRE session:abc 1800 XX
→ TTL 있을 때만 30분으로 변경

EXPIRE session:abc 3600 GT
→ 새 TTL(3600초)이 기존보다 크면 변경
```

---

### 2. EXPIREAT: Unix 타임스탬프로 설정

```
EXPIREAT key unix-timestamp-seconds [NX|XX|GT|LT]
```

**예시**

```
# 특정 시점에 만료
EXPIREAT user:100 1735689600
→ 2025-01-01 00:00:00에 삭제

# 현재 시간 + 1시간
EXPIREAT user:200 $(date +%s + 3600)
```

---

### 3. PEXPIRE: 밀리초 단위 설정

```
PEXPIRE key milliseconds [NX|XX|GT|LT]
```

**예시**

```
PEXPIRE cache:data 5000
→ 5초 후 삭제 (5000ms)
```

---

### 4. TTL / PTTL: 남은 시간 확인

```
TTL key              (초 단위)
PTTL key             (밀리초 단위)
```

**반환값**

```
양수        : 남은 시간
-1          : TTL 없음 (영구 저장)
-2          : 키 없음
```

**예시**

```
EXPIRE mykey 100
TTL mykey
→ 99 (약 99초 남음)

PTTL mykey
→ 99000 (약 99초 = 99,000ms)

# TTL 없는 키
TTL permanent_key
→ -1

# 없는 키
TTL nonexistent
→ -2
```

---

### 5. EXPIRETIME: 만료 시점 조회

```
EXPIRETIME key      (초 단위)
PEXPIRETIME key     (밀리초 단위)
```

**예시**

```
EXPIRETIME mykey
→ 1735689600 (Unix 타임스탐프)

PEXPIRETIME mykey
→ 1735689600000 (밀리초)
```

---

### 6. PERSIST: TTL 제거

```
PERSIST key
```

**설명**: 키의 TTL을 제거하여 영구 저장으로 변경합니다.

**예시**

```
EXPIRE mykey 3600
TTL mykey
→ 3600

PERSIST mykey
TTL mykey
→ -1 (TTL 없음, 영구 저장)
```

---

## 🎨 TTL 실제 사용 패턴

### 패턴 1: 세션 캐시 (자동 만료)

```
사용자 로그인:
SET session:abc123 "user:100" EX 3600
→ 1시간 후 자동 삭제 ✅

장점:
- 수동으로 삭제 안 해도 됨
- 메모리 자동 관리
- 보안 강화 (오래된 세션 자동 제거)
```

---

### 패턴 2: 캐시 데이터 (짧은 TTL)

```
캐시 저장:
SET cache:product:100 "$50" EX 300
→ 5분 후 자동 새로고침 필요

캐시 갱신:
GET cache:product:100
→ nil (만료됨)
→ DB에서 재조회 후 다시 캐시
```

---

### 패턴 3: 중요 데이터 (TTL 없음)

```
사용자 정보:
SET user:100 "{...}" 
→ TTL 없음 (영구 저장) ✅

주문 데이터:
SET order:123 "{...}"
→ TTL 없음 (영구 저장) ✅

이유: 데이터 손실 방지
```

---

## ⚠️ TTL 사용 시 주의사항

### 1. Stream은 개별 메시지 TTL 불가

```
❌ 메시지별 TTL 불가능:
XADD events EX 3600 * event_type "click"
→ 전체 Stream이 3600초 후 삭제 (모든 메시지)

✅ 수동 정리 필요:
XTRIM events MAXLEN 10000
→ 최근 10,000개만 유지

또는:
XADD events MAXLEN ~ 10000 * ...
→ 메시지 추가 시 자동 정리
```

---

### 2. TTL 설정 후 덮어쓰기

```
SET mykey "value1" EX 3600
GET mykey           → "value1" ✅

SET mykey "value2"  
→ 새 값으로 덮어쓰기
→ TTL 제거됨! ⚠️

GET mykey           → "value2"
TTL mykey           → -1 (TTL 없음!)

해결책:
GETDEL mykey
SETEX mykey 3600 "new_value"
→ TTL 유지
```

---

### 3. 대량 데이터 삭제 성능

```
❌ 나쁜 방법:
FOR each_key IN million_keys:
    DEL each_key

결과: Redis 블로킹 반복 ❌

✅ 좋은 방법:
UNLINK key1 key2 key3 ... key1000
→ 배치 삭제 + 비동기

또는:
FLUSHDB ASYNC
→ 전체 DB 삭제
```

---

## 시간 복잡도

|커맨드|복잡도|설명|
|---|---|---|
|EXISTS|O(1)|키 존재 확인|
|KEYS|O(N)|⚠️ 위험 (N = 전체 키)|
|SCAN|O(1)|커서당 일부 키만|
|TYPE|O(1)|타입 확인|
|OBJECT|O(1)|메타정보 조회|
|RENAME|O(1)|이름 변경|
|COPY|O(N)|N = 데이터 크기|
|SORT|O(N+Mlog(M))|N = 아이템, M = 정렬 크기|
|DEL|O(N)|N = 삭제 아이템 수|
|UNLINK|O(1)|연결 끊기만 (정리는 BG)|
|EXPIRE|O(1)|TTL 설정|
|TTL|O(1)|남은 시간 조회|

---

## Spring Boot 예제

```java
// EXISTS 확인
Boolean exists = redisTemplate.hasKey("user:100");

// 키 조회 (SCAN 권장)
Set<String> keys = redisTemplate.keys("user:*");

// 타입 확인
DataType type = redisTemplate.type("mykey");

// TTL 설정 (초)
redisTemplate.expire("session:abc", Duration.ofHours(1));

// TTL 설정 (밀리초)
redisTemplate.pExpire("cache:data", Duration.ofMillis(5000));

// 남은 시간 확인
Long ttl = redisTemplate.getExpire("mykey", TimeUnit.SECONDS);

// TTL 제거
redisTemplate.persist("mykey");

// 키 삭제 (비동기)
redisTemplate.unlink("big_data");

// 배치 삭제
redisTemplate.delete(Arrays.asList("key1", "key2", "key3"));
```

---

## 핵심 정리

|작업|커맨드|안전도|
|---|---|---|
|**키 확인**|EXISTS|✅ 안전|
|**키 조회**|SCAN|✅ 권장|
|**키 조회**|KEYS|❌ 위험|
|**키 삭제**|DEL|⚠️ 조심|
|**키 삭제**|UNLINK|✅ 권장|
|**TTL 설정**|EXPIRE|✅ 안전|
|**TTL 확인**|TTL|✅ 안전|

---

## 정말 간단하게

```
Redis 키 관리 3대 원칙:

1️⃣ 조회: SCAN 사용 (KEYS 금지)
   → 안전하고 효율적

2️⃣ 삭제: UNLINK 사용 (DEL 지양)
   → 비동기 처리로 블로킹 방지

3️⃣ 만료: EXPIRE로 자동 정리
   → 메모리 자동 관리
```