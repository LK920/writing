---
aliases:
  - redis_네이밍 컨벤션
tags:
  - redis
  - 네임스페이스
  - 콜론
  - 네이밍컨벤션
---

# Redis 네이밍 컨벤션

## 1️⃣ 콜론으로 계층 구조 표현

Redis는 네임스페이스 개념이 없기 때문에, **콜론(`:`)을 구분자로 사용하여 계층 구조를 표현**합니다.

### 기본 예시

```
user:123              // 사용자 123의 정보
product:456           // 제품 456의 정보
order:789:items       // 주문 789의 아이템 목록
cache:session:abc123  // 세션 캐시
```

### 상세 설명

| 키 형식 | 의미 | 용도 |
|--------|------|------|
| `user:123` | 리소스 타입 : ID | 사용자 데이터 |
| `product:456` | 리소스 타입 : ID | 상품 데이터 |
| `order:789:items` | 리소스 타입 : ID : 세부속성 | 주문의 아이템 정보 |
| `cache:session:abc123` | 용도 : 타입 : ID | 세션 캐시 |

---

## 2️⃣ 네이밍 구조 다이어그램

### 기본 구조

```
리소스 타입  :  ID/식별자  :  세부속성(선택)
```

### 구체적 예시

**구조:**
```
    user        :      123
┌─────────────────────────────┐
│                             │
│   리소스 타입  :  ID        │
└─────────────────────────────┘
```

**의미:** 사용자 ID 123번의 정보

---

## 3️⃣ 나쁜 네이밍 vs 좋은 네이밍

### ❌ 나쁜 예 (혼란스러움)

```
user123
→ 무엇의 123인지 불명확
→ 다른 타입과 구분이 어려움

u:123:n
→ 약자 사용으로 가독성 낮음
→ 팀원이 의도를 파악하기 어려움

data_user_123
→ 언더스코어는 패턴 매칭이 어려움
→ Redis CLI에서 검색이 복잡해짐
```

### ✅ 좋은 예 (명확함)

```
user:123
→ 한눈에 사용자 123임을 알 수 있음
→ 다른 타입과 명확하게 구분됨

user:123:profile
→ 계층이 명확하고 읽기 쉬움
→ 속성도 바로 이해 가능

cache:session:abc123
→ 목적과 타입을 명확하게 표현
→ 재사용성과 유지보수성 높음
```

---

## 4️⃣ KEYS 패턴 매칭 활용

### Redis에 저장된 모든 키

```
user:100
user:200
user:300
product:10
product:20
product:30
order:1
order:2
cache:session:xxx
dau:2025-01-15
```

### 패턴 매칭 예시

```
KEYS user:*
→ 결과: user:100, user:200, user:300
→ 모든 사용자 키 조회

KEYS product:*
→ 결과: product:10, product:20, product:30
→ 모든 상품 키 조회

KEYS *:session:*
→ 결과: cache:session:xxx
→ 모든 세션 키 조회

KEYS user:2*
→ 결과: user:200, user:300
→ 특정 패턴의 사용자 조회 (200번대)

KEYS dau:*
→ 결과: dau:2025-01-15
→ DAU 관련 모든 키 조회
```

---

## 5️⃣ 실제 Redis에 저장되는 모습

### Hash 자료구조 예시

```
Key: "user:100"
Value: {
  "name": "John",
  "email": "john@example.com",
  "created_at": "2025-01-01"
}

Key: "user:101"
Value: {
  "name": "Jane",
  "email": "jane@example.com",
  "created_at": "2025-01-02"
}
```

### Set 자료구조 예시

```
Key: "order:789:items"
Value: ["product:1", "product:2", "product:5"]
```

### String 자료구조 예시

```
Key: "cache:session:abc123"
Value: "{ user_id: 100, expires_at: 2025-01-19, token: xyz... }"

Key: "dau:2025-01-15"
Value: (비트맵 데이터)
```

---

## 6️⃣ 네이밍 컨벤션의 장점

### 📖 가독성 향상
```
코드를 보면 즉시 무엇을 나타내는지 알 수 있음
user:123 → "사용자 123이구나"
order:789:items → "주문 789의 아이템이구나"
```

### 📦 데이터 구조화
```
유사한 데이터를 논리적으로 그룹화
같은 접두사를 가진 데이터들은 관련이 있음
관리와 유지보수가 용이
```

### 🔍 검색성 향상
```
KEYS 패턴 매칭으로 관련 데이터 쉽게 찾기
user:* → 모든 사용자 데이터
product:* → 모든 상품 데이터
특정 범위의 데이터 검색 가능
```

### 👥 협업 효율 증대
```
팀원들이 명명 규칙을 보면 즉시 의도 파악
새로운 개발자도 쉽게 이해 가능
코드 리뷰가 더 명확해짐
실수 방지 가능
```

---

## 7️⃣ 실전 예제: Spring Boot에서의 활용

### 사용자 관련 키

```
user:{userId}                  // 사용자 기본 정보
user:{userId}:profile          // 사용자 프로필
user:{userId}:settings         // 사용자 설정
user:{userId}:following        // 팔로우 리스트
user:{userId}:followers        // 팔로워 리스트
```

### 캐시 관련 키

```
cache:user:{userId}            // 사용자 정보 캐시
cache:product:{productId}      // 상품 정보 캐시
cache:session:{sessionId}      // 세션 캐시
cache:search:results:{query}   // 검색 결과 캐시
```

### 통계 관련 키

```
dau:2025-01-15                 // 일일 활성 사용자
mau:2025-01                    // 월간 활성 사용자
stats:revenue:2025-01-15       // 매출 통계
stats:visits:2025-01-15        // 방문 통계
```

### 임시 데이터 키

```
temp:email:verification:{code} // 이메일 인증 코드
temp:password:reset:{token}    // 비밀번호 재설정 토큰
temp:otp:{userId}              // OTP
```

---

## 8️⃣ 네이밍 규칙 체크리스트

### 네이밍할 때 확인 사항

- ✅ 콜론(`:`)을 계층 구분자로 사용했는가?
- ✅ 리소스 타입을 명시했는가?
- ✅ ID나 식별자가 포함되어 있는가?
- ✅ 약자를 사용하지 않았는가?
- ✅ 언더스코어(`_`) 대신 콜론(`:`)을 사용했는가?
- ✅ 팀원이 보면 즉시 의도를 파악할 수 있는가?
- ✅ KEYS 패턴 매칭이 가능한가?

---

## 💡 핵심 정리

**Redis 네이밍 컨벤션의 핵심 3가지:**

```
1. 계층 구조
   [카테고리] : [ID] : [속성]

2. 명확성
   코드를 보면 즉시 무엇인지 알 수 있어야 함

3. 검색성
   KEYS 패턴으로 관련 데이터를 쉽게 찾을 수 있어야 함
```

**정말 간단하게:**

```
나쁜 예: user123              (뭐의 123이지?)
좋은 예: user:123            (사용자 123이구나! ✅)
```

---

## 🎯 Spring Boot에서의 실제 코드 예시

```java
// RedisTemplate 사용 예시
String userId = "123";

// SET 명령어
redisTemplate.opsForValue()
  .set("user:" + userId, userJson);

// GET 명령어
String user = redisTemplate.opsForValue()
  .get("user:" + userId);

// KEYS 패턴 매칭
Set<String> allUsers = redisTemplate.keys("user:*");

// HSET 명령어
redisTemplate.opsForHash()
  .put("user:" + userId, "name", "John");

// SADD 명령어 (팔로우 리스트)
redisTemplate.opsForSet()
  .add("user:" + userId + ":following", "user:200");

// TTL 설정
redisTemplate.expire(
  "cache:session:" + sessionId,
  Duration.ofHours(1)
);
```