---
aliases:
  - 레디스_기본_개념
  - 레디스_stream
tags:
  - 레디스
  - redis
  - 레디스기본개념
  - 레디스자료구조
  - stream
---
# Redis Stream 자료구조

## 기본 개요

**메시지 브로커(Kafka 같은)처럼 동작하는 자료구조로, 실시간 이벤트와 로그성 데이터를 저장하고 처리**합니다. Append-only 방식으로 데이터를 계속 추가하며, 소비자 그룹 개념으로 분산 처리를 지원합니다.

- **특징**: 메시지 브로커, 이벤트 로깅, 분산 처리
- **저장 방식**: Append-only (데이터는 추가만 됨, 삭제 불가)
- **메시지 ID**: 타임스탬프 기반 (자동 생성 가능)
- **소비자 그룹**: 여러 워커가 메시지를 분담 처리
- **활용**: 실시간 알림, 로그 수집, 이벤트 처리, 작업 큐 등

---

## 🎨 Stream의 구조 (시각화)

### 기본 구조

```
Stream: "orders"
═══════════════════════════════════════════════════════════

┌─ 메시지 1 ─────────────────────────────────────────────┐
│ ID: 1705315200000-0                                     │
│ ┌────────────────────────────────────────────────────┐ │
│ │ order_id  │ "123"                                  │ │
│ │ user_id   │ "user:100"                             │ │
│ │ amount    │ "50000"                                │ │
│ └────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─ 메시지 2 ─────────────────────────────────────────────┐
│ ID: 1705315201000-0                                     │
│ ┌────────────────────────────────────────────────────┐ │
│ │ order_id  │ "124"                                  │ │
│ │ user_id   │ "user:200"                             │ │
│ │ amount    │ "75000"                                │ │
│ └────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─ 메시지 3 ─────────────────────────────────────────────┐
│ ID: 1705315202000-0                                     │
│ ┌────────────────────────────────────────────────────┐ │
│ │ order_id  │ "125"                                  │ │
│ │ user_id   │ "user:300"                             │ │
│ │ amount    │ "30000"                                │ │
│ └────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘

Append-Only: 새 메시지는 항상 끝에 추가됨 ➕
```

### 메시지 ID 구성

```
    1705315200000    -    0
    └─────┬──────┘   └──┬─┘
   타임스탬프(ms)    시퀀스
   (자동 생성)      (같은ms에 증가)

같은 밀리초에 여러 메시지 추가:

XADD orders * ... → 1705315200000-0 ✅
XADD orders * ... → 1705315200000-1 ✅  (시퀀스 증가)
XADD orders * ... → 1705315200000-2 ✅  (시퀀스 증가)

다음 밀리초:
XADD orders * ... → 1705315201000-0 ✅  (새로운 타임스탬프)
```

---

## Stream vs 다른 자료구조 비교

|항목|List|Sorted Set|**Stream**|
|---|---|---|---|
|**용도**|순서 있는 데이터|정렬된 데이터|메시지 브로커|
|**메시지 ID**|자동 증가 인덱스|스코어|타임스탬프 기반|
|**소비자 그룹**|❌ 없음|❌ 없음|✅ **있음**|
|**이력 추적**|❌ 없음|❌ 없음|✅ **처리 이력 저장**|
|**미확인 메시지**|❌ 없음|❌ 없음|✅ **추적 가능**|
|**분산 처리**|❌ 어려움|❌ 어려움|✅ **지원**|

---

## 🎨 소비자 그룹의 동작 원리

### 그룹 없는 경우 (모두가 모든 메시지 읽음)

```
Stream: "orders"
┌──────────────────────────────────────────┐
│ 메시지 A  →  메시지 B  →  메시지 C      │
└──────────────────────────────────────────┘
       ↗           ↗           ↗
     /             /             /
   /               /             /
 /                 /             /
Consumer1    Consumer2    Consumer3

모두가 모든 메시지 읽음 (중복!) ❌
```

### 그룹 있는 경우 (메시지 분담 처리) ✅

```
Stream: "orders"
┌──────────────────────────────────────────┐
│ 메시지 A  →  메시지 B  →  메시지 C      │
└──────────────────────────────────────────┘

소비자 그룹: "payment_workers"
   │
   ├─ Worker1: 메시지 A 읽음 ✅
   ├─ Worker2: 메시지 B 읽음 ✅
   └─ Worker3: 메시지 C 읽음 ✅

각 메시지는 정확히 한 워커만 처리!
```

### XREADGROUP 실제 동작

```
상황: 5개 메시지가 Stream에 있음

┌─────────────────────────────────────────────────────────┐
│ Stream: "orders"                                         │
│ [메시지1] → [메시지2] → [메시지3] → [메시지4] → [메시지5] │
└─────────────────────────────────────────────────────────┘

소비자 그룹 생성:
XGROUP CREATE orders payment_group 0
     (처음부터 모든 메시지 처리 가능)

Worker1 첫 번째 읽기:
XREADGROUP GROUP payment_group worker1 COUNT 2 STREAMS orders >
                                                      └─ "처리되지 않은 다음 메시지"

결과: 메시지1, 메시지2 받음 📥

┌─────────────────────────────────────────────────────────┐
│ [메시지1]✓ → [메시지2]✓ → [메시지3] → [메시지4] → [메시지5] │
│  (처리중)      (처리중)    (대기중)    (대기중)    (대기중)  │
└─────────────────────────────────────────────────────────┘

Worker2 첫 번째 읽기:
XREADGROUP GROUP payment_group worker2 STREAMS orders >

결과: 메시지3 받음 📥
(메시지1,2는 worker1이 처리 중이므로 건너뜀)

┌─────────────────────────────────────────────────────────┐
│ [메시지1]✓ → [메시지2]✓ → [메시지3]✓ → [메시지4] → [메시지5] │
│  (worker1)    (worker1)    (worker2)   (대기중)    (대기중)  │
└─────────────────────────────────────────────────────────┘

Worker1이 메시지1 처리 완료:
XACK orders payment_group 메시지1_ID

XACK (처리 완료 확인) ✅ (미확인 목록에서 제거)
```

### 미확인 메시지 추적

```
상황: Worker1이 메시지1, 2를 읽었지만 아직 XACK 안 함

미확인 메시지 상태:
┌─────────────────────────────────────┐
│ XPENDING orders payment_group        │
├─────────────────────────────────────┤
│ 미확인 메시지 수: 2                  │
│                                     │
│ ┌─ 메시지1                          │
│ │ 처리자: worker1                   │
│ │ 대기 시간: 5초                    │
│ │ 상태: 처리 중... ⏳               │
│ │                                  │
│ ├─ 메시지2                          │
│ │ 처리자: worker1                   │
│ │ 대기 시간: 3초                    │
│ │ 상태: 처리 중... ⏳               │
│ └─                                  │
└─────────────────────────────────────┘

Worker1이 메시지1 처리 완료:
XACK orders payment_group 메시지1_ID

업데이트된 미확인 목록:
┌─────────────────────────────────────┐
│ 미확인 메시지 수: 1                  │
│ ┌─ 메시지2 (아직 처리 중)           │
│ │ 처리자: worker1                   │
│ │ 대기 시간: 8초                    │
│ └─                                  │
└─────────────────────────────────────┘
```

---

## 핵심 커맨드

### 1. XADD: 메시지 추가

```
XADD key [ID] field value [field value ...]
```

**설명**: Stream에 새 메시지를 추가합니다.

**예시**

```
# 자동 ID 생성으로 메시지 추가
XADD orders * order_id "123" user_id "user:100" amount "50000"
→ 반환: "1705315200000-0" (자동 생성된 ID)

# 여러 필드 추가
XADD orders * \
  order_id "124" \
  user_id "user:200" \
  amount "75000"
→ 반환: "1705315201000-0"

# 직접 ID 지정 (일반적이지 않음)
XADD orders 1000000-0 product_name "laptop" price "1000000"
```

---

### 2. XLEN: 스트림 크기 조회

```
XLEN key
```

**설명**: Stream에 저장된 메시지 개수를 반환합니다.

**예시**

```
XLEN orders
→ 반환: 3 (3개의 메시지가 있음)
```

---

### 3. XRANGE: 범위 조회

```
XRANGE key start end [COUNT count]
```

**설명**: 특정 ID 범위의 메시지들을 조회합니다.

**예시**

```
# 첫 번째 메시지부터 마지막까지 조회
XRANGE orders - +

결과:
1) 1) "1705315200000-0"
   2) 1) "order_id"
      2) "123"
      3) "user_id"
      4) "user:100"
      5) "amount"
      6) "50000"
3) 1) "1705315201000-0"
   4) 1) "order_id"
      2) "124"
      3) "user_id"
      4) "user:200"
      5) "amount"
      6) "75000"
5) 1) "1705315202000-0"
   6) 1) "order_id"
      2) "125"
      3) "user_id"
      4) "user:300"
      5) "amount"
      6) "30000"

# 최근 2개만 조회
XRANGE orders - + COUNT 2

# 특정 범위 조회
XRANGE orders 1705315200000-0 1705315201000-0
```

---

### 4. XREAD: 메시지 읽기 (기본)

```
XREAD [COUNT count] [BLOCK milliseconds] STREAMS key id
```

**설명**: 특정 ID 이후의 메시지를 읽습니다.

**예시**

```
# ID 0 이후의 모든 메시지 (처음부터)
XREAD STREAMS orders 0

# 마지막 메시지 이후의 새 메시지만 (블로킹)
XREAD BLOCK 0 STREAMS orders $

# 상위 2개 메시지
XREAD COUNT 2 STREAMS orders 0
```

---

### 5. XGROUP CREATE: 소비자 그룹 생성

```
XGROUP CREATE key group id [MKSTREAM]
```

**설명**: 메시지를 나눠서 처리할 소비자 그룹을 만듭니다.

**예시**

```
# 소비자 그룹 생성 (ID $: 새 메시지부터 처리)
XGROUP CREATE orders payment_group $

# 소비자 그룹 생성 (ID 0: 처음부터 처리)
XGROUP CREATE orders notification_group 0
```

---

### 6. XREADGROUP: 그룹으로 메시지 읽기

```
XREADGROUP GROUP group consumer [COUNT count] [BLOCK ms] STREAMS key id
```

**설명**: 소비자 그룹의 멤버로서 메시지를 읽습니다. 다른 소비자가 읽은 메시지는 건너뜁니다.

**예시**

```
# payment_group 그룹의 worker1이 메시지 읽기
XREADGROUP GROUP payment_group worker1 STREAMS orders >

결과:
1) 1) "orders"
   2) 1) 1) "1705315200000-0"
         2) 1) "order_id"
            2) "123"
            3) "user_id"
            4) "user:100"
            5) "amount"
            6) "50000"

# worker2도 같은 그룹에서 읽기 (다른 메시지를 받음)
XREADGROUP GROUP payment_group worker2 STREAMS orders >

# 결과: worker1이 이미 받은 메시지는 건너뜀
```

---

### 7. XACK: 메시지 처리 확인

```
XACK key group id [id ...]
```

**설명**: 메시지 처리가 완료되었음을 확인합니다.

**예시**

```
# 메시지 처리 완료 확인
XACK orders payment_group "1705315200000-0"
→ 반환: 1 (1개 확인됨)

# 여러 메시지 확인
XACK orders payment_group "1705315200000-0" "1705315201000-0"
```

---

### 8. XPENDING: 미확인 메시지 조회

```
XPENDING key group [start end count] [consumer]
```

**설명**: 아직 처리되지 않은(XACK 미실행) 메시지 목록을 조회합니다.

**예시**

```
# payment_group의 모든 미확인 메시지
XPENDING orders payment_group

결과:
1) 1 (총 1개 미확인)
2) "1705315200000-0" (가장 오래된 ID)
3) "1705315200000-0" (가장 최신 ID)
4) 1) 1) "worker1"
      2) "1" (worker1이 처리 중인 메시지 1개)

# 특정 소비자의 미확인 메시지
XPENDING orders payment_group - + 10 worker1
```

---

## 시간 복잡도

|작업|시간복잡도|설명|
|---|---|---|
|XADD|**O(1)**|메시지 추가|
|XLEN|**O(1)**|개수 조회|
|XRANGE|**O(N)**|N = 조회 범위 내 메시지 수|
|XREAD|**O(N)**|스트림 크기에 따라|
|XREADGROUP|**O(N)**|미처리 메시지 수에 따라|

---

## 🎨 실제 동작 플로우

### 분산 작업 처리 흐름

```
┌────────────────────────────────────────────────────────┐
│ 1️⃣  주문 이벤트 생성                                   │
├────────────────────────────────────────────────────────┤
│ 사용자가 구매 버튼 클릭                                 │
│         ↓                                               │
│  XADD orders * order_id "001" amount "50000"           │
│  → ID: 1705315200000-0 (메시지 추가)                   │
└────────────────────────────────────────────────────────┘
                         ↓
┌────────────────────────────────────────────────────────┐
│ 2️⃣  Stream에 메시지 저장                               │
├────────────────────────────────────────────────────────┤
│ Stream: "orders"                                        │
│ ┌─────────────────────────────────────────────────────┐│
│ │ [주문001]  [주문002]  [주문003]  [주문004]  [주문005] ││
│ └─────────────────────────────────────────────────────┘│
└────────────────────────────────────────────────────────┘
                         ↓
┌────────────────────────────────────────────────────────┐
│ 3️⃣  소비자 그룹에서 메시지 분담 읽기                    │
├────────────────────────────────────────────────────────┤
│ 그룹: "payment_workers"                                 │
│                                                         │
│ Worker1 읽기:                                           │
│ XREADGROUP GROUP payment_workers worker1 STREAMS ...   │
│ → 주문001, 주문002 받음 📥                              │
│                                                         │
│ Worker2 읽기:                                           │
│ XREADGROUP GROUP payment_workers worker2 STREAMS ...   │
│ → 주문003 받음 📥                                       │
│                                                         │
│ Worker3 읽기:                                           │
│ XREADGROUP GROUP payment_workers worker3 STREAMS ...   │
│ → 주문004, 주문005 받음 📥                              │
└────────────────────────────────────────────────────────┘
                         ↓
┌────────────────────────────────────────────────────────┐
│ 4️⃣  각 워커가 병렬로 처리                               │
├────────────────────────────────────────────────────────┤
│                                                         │
│ Worker1 처리:           Worker2 처리:   Worker3 처리:   │
│ ├─ 주문001             ├─ 주문003      ├─ 주문004      │
│ │  결제 처리 💳        │  결제 처리 💳 │  결제 처리 💳 │
│ │  (3초) ⏱️            │  (2초) ⏱️     │  (4초) ⏱️     │
│ │  완료 ✅             │  완료 ✅      │  진행 중...   │
│ │                     │               │               │
│ └─ 주문002            │               ├─ 주문005      │
│    결제 처리 💳       │               │  결제 처리 💳 │
│    (2초) ⏱️           │               │  (3초) ⏱️     │
│    진행 중...         │               │  완료 ✅      │
└────────────────────────────────────────────────────────┘
                         ↓
┌────────────────────────────────────────────────────────┐
│ 5️⃣  처리 완료 후 XACK 확인                              │
├────────────────────────────────────────────────────────┤
│ XACK orders payment_workers 1705315200000-0            │
│ → 주문001 완료 확인 ✅                                  │
│                                                         │
│ XACK orders payment_workers 1705315201000-0            │
│ → 주문003 완료 확인 ✅                                  │
│                                                         │
│ XACK orders payment_workers 1705315205000-0            │
│ → 주문005 완료 확인 ✅                                  │
└────────────────────────────────────────────────────────┘
                         ↓
┌────────────────────────────────────────────────────────┐
│ 6️⃣  미확인 메시지 모니터링                              │
├────────────────────────────────────────────────────────┤
│ XPENDING orders payment_workers                         │
│                                                         │
│ 처리 중인 메시지:                                       │
│ ├─ 주문002 (worker1, 대기 5초)                         │
│ └─ 주문004 (worker3, 대기 7초)                         │
│                                                         │
│ → 혹시 오류가 나면 재할당 가능 🔄                       │
└────────────────────────────────────────────────────────┘
```

---

## 실제 사용 예제

### 예제 1: 주문 처리 시스템 (소비자 그룹 없음)

```
# 1. 주문 이벤트 추가
XADD orders * order_id "001" user_id "user:100" amount "50000"
→ ID: "1705315200000-0"

XADD orders * order_id "002" user_id "user:200" amount "75000"
→ ID: "1705315201000-0"

XADD orders * order_id "003" user_id "user:300" amount "30000"
→ ID: "1705315202000-0"

# 2. 모든 주문 조회
XRANGE orders - +

# 3. 최근 2개 주문 조회
XRANGE orders - + COUNT 2

# 4. 특정 시간 이후의 주문 조회
XRANGE orders 1705315201000-0 +
```

---

### 예제 2: 분산 작업 처리 (소비자 그룹 사용)

**시나리오**: 주문 처리를 여러 워커가 분담 처리

```
# 1. 소비자 그룹 생성 (처음부터 모든 메시지 처리)
XGROUP CREATE orders payment_workers 0

# 2. 주문 데이터 추가
XADD orders * order_id "001" status "pending" amount "50000"
XADD orders * order_id "002" status "pending" amount "75000"
XADD orders * order_id "003" status "pending" amount "30000"

# 3. Worker1이 메시지 읽기
XREADGROUP GROUP payment_workers worker1 COUNT 2 STREAMS orders >

결과: 주문 001, 002를 받음

# 4. Worker2가 메시지 읽기
XREADGROUP GROUP payment_workers worker2 COUNT 1 STREAMS orders >

결과: 주문 003을 받음
(001, 002는 worker1이 처리 중이므로 건너뜀)

# 5. Worker1이 주문 001 처리 완료
XACK orders payment_workers "1705315200000-0"

# 6. Worker1이 주문 002 처리 완료
XACK orders payment_workers "1705315201000-0"

# 7. 미처리 메시지 확인
XPENDING orders payment_workers
→ 결과: Worker2가 처리 중인 주문 003만 표시

# 8. Worker2가 주문 003 처리 완료
XACK orders payment_workers "1705315202000-0"

# 9. 다시 미처리 메시지 확인
XPENDING orders payment_workers
→ 결과: 비어있음 (모든 주문 처리 완료)
```

---

### 예제 3: 실시간 로그 수집

```
# 1. 로그 이벤트 추가
XADD logs * \
  level "INFO" \
  service "api_server" \
  message "Request received" \
  endpoint "/api/users"

XADD logs * \
  level "ERROR" \
  service "api_server" \
  message "Database connection failed" \
  error_code "DB_TIMEOUT"

XADD logs * \
  level "WARNING" \
  service "payment_service" \
  message "High response time detected" \
  duration_ms "5234"

# 2. 모든 로그 조회
XRANGE logs - +

# 3. 최근 로그 5개 조회
XREVRANGE logs + - COUNT 5

# 4. 로그 분석 그룹 생성
XGROUP CREATE logs analysis_group 0

# 5. 분석 워커가 로그 읽기
XREADGROUP GROUP analysis_group analyzer1 STREAMS logs >

# 6. 로그 분석 완료 후 확인
XACK logs analysis_group "1705315200000-0"
```

---

### 예제 4: 실시간 알림 시스템

```
# 1. 알림 메시지 추가
XADD notifications * user_id "user:100" type "order" message "주문이 배송되었습니다"
XADD notifications * user_id "user:200" type "payment" message "결제가 완료되었습니다"
XADD notifications * user_id "user:100" type "promotion" message "30% 할인 쿠폰이 도착했습니다"

# 2. 알림 전송 그룹 생성
XGROUP CREATE notifications senders 0

# 3. 발송자 1이 알림 읽기
XREADGROUP GROUP senders sender1 COUNT 2 STREAMS notifications >

# 4. 발송자 2가 알림 읽기
XREADGROUP GROUP senders sender2 STREAMS notifications >

# 5. 발송 완료
XACK notifications senders [ID1] [ID2] [ID3]
```

---

## 🎨 Append-Only 방식의 특징

### 데이터 추가만 가능

```
초기 상태:
┌──────────────────────────┐
│  (비어있음)               │
└──────────────────────────┘

XADD 실행 1️⃣:
┌──────────────────────────┐
│ [메시지1]                │
└──────────────────────────┘
    ↑
  추가 ➕

XADD 실행 2️⃣:
┌──────────────────────────┐
│ [메시지1] → [메시지2]    │
└──────────────────────────┘
              ↑
            추가 ➕

XADD 실행 3️⃣:
┌──────────────────────────┐
│ [메시지1] → [메시지2] → [메시지3] │
└──────────────────────────┘
                        ↑
                      추가 ➕

❌ 불가능한 작업:
- 메시지1 수정 불가
- 메시지2 삭제 불가
- 순서 변경 불가

✅ 가능한 작업:
- 메시지 추가 ➕
- 메시지 읽기 📖
- 오래된 메시지 제거 (XTRIM)
```

### 왜 Append-Only인가?

```
로그 시스템의 중요한 특성:

┌─────────────────────────────────────┐
│         Append-Only의 장점           │
├─────────────────────────────────────┤
│ 1. 이력 추적                        │
│    언제, 누가, 뭘 했는지 기록      │
│                                     │
│ 2. 감시 추적성 (Auditability)      │
│    모든 이벤트가 영구 기록          │
│                                     │
│ 3. 데이터 무결성                   │
│    수정/삭제 방지로 기록 보호      │
│                                     │
│ 4. 이벤트 소싱                     │
│    모든 변화를 이벤트로 저장       │
└─────────────────────────────────────┘

예시:
시간 00:00 → 주문 생성
시간 00:01 → 결제 완료
시간 00:02 → 배송 시작
시간 00:05 → 배송 완료

이 모든 과정이 기록되고 추적됨!
```

---

## 🎨 List vs Stream 비교

### 구조 비교

```
List: "simple_queue"
┌─────────────────────────────────────────┐
│ Index │ Value                           │
├─────────────────────────────────────────┤
│  0    │ "작업1"                         │
│  1    │ "작업2"                         │
│  2    │ "작업3"                         │
└─────────────────────────────────────────┘

특징:
- 간단한 큐/스택
- 인덱스 기반 접근
- 소비자 추적 불가 ❌


Stream: "task_stream"
┌──────────────────────────────────────────────────┐
│ ID              │ Field1 │ Field2 │ Field3      │
├──────────────────────────────────────────────────┤
│1705315200000-0  │ data1  │ data2  │ data3       │
│1705315201000-0  │ data1  │ data2  │ data3       │
│1705315202000-0  │ data1  │ data2  │ data3       │
└──────────────────────────────────────────────────┘

특징:
- 메시지 ID 기반 접근
- 소비자 그룹 추적 ✅
- 처리 이력 보존 ✅
```

### 처리 방식 비교

```
List를 이용한 처리:
┌─────────────┐
│  LPUSH 추가 │
└──────┬──────┘
       │
       ↓
┌─────────────┐
│ LPOP 읽기   │
├─────────────┤
│ Consumer1   │
│ Consumer2   │
│ Consumer3   │
└──────┬──────┘
       │
    중복 가능 ❌
    누가 처리했는지 추적 불가 ❌


Stream을 이용한 처리:
┌─────────────┐
│ XADD 추가   │
└──────┬──────┘
       │
       ↓
┌──────────────────────┐
│ Consumer Group 생성  │
├──────────────────────┤
│ XREADGROUP 읽기      │
│                      │
│ ├─ Worker1 → 메시지1 │
│ ├─ Worker2 → 메시지2 │  중복 없음 ✅
│ └─ Worker3 → 메시지3 │  분담 처리 ✅
└──────┬───────────────┘
       │
       ↓
    XACK 확인
    처리 이력 추적 ✅
```

---

## 🎨 Spring Boot 실제 워크플로우

```
요청: 주문 생성
┌──────────────────────┐
│ POST /orders         │
│ Body: {              │
│   user_id: "100",    │
│   amount: 50000      │
│ }                    │
└──────┬───────────────┘
       │
       ↓
┌──────────────────────────────────────┐
│ Spring Boot Controller               │
│ @PostMapping("/orders")              │
│ public void createOrder(Order req) { │
│   XADD orders * ...                  │
│ }                                    │
└──────┬───────────────────────────────┘
       │
       ↓
┌──────────────────────────────────────┐
│ Redis Stream                         │
│ XADD orders * \                      │
│   order_id "001" \                   │
│   user_id "100" \                    │
│   amount "50000"                     │
│ → ID: 1705315200000-0                │
└──────┬───────────────────────────────┘
       │
       ↓
┌──────────────────────────────────────────────────┐
│ 다른 서버/워커들이 리스닝                        │
├──────────────────────────────────────────────────┤
│                                                  │
│ 결제 서버 (Payment Service)                      │
│ ├─ XREADGROUP GROUP payment_workers worker1    │
│ └─ 주문001 결제 처리 💳                         │
│                                                  │
│ 배송 서버 (Delivery Service)                     │
│ ├─ XREADGROUP GROUP shipping_workers worker1   │
│ └─ 주문001 배송 준비 📦                         │
│                                                  │
│ 알림 서버 (Notification Service)                 │
│ ├─ XREADGROUP GROUP notification_workers ...   │
│ └─ 고객에게 알림 발송 📧                        │
└──────┬───────────────────────────────────────────┘
       │
       ↓ (처리 완료)
┌──────────────────────────────────────┐
│ XACK 확인                            │
│                                      │
│ XACK orders payment_workers "..."  │
│ XACK orders shipping_workers "..." │
│ XACK orders notification_... "..."│
└──────────────────────────────────────┘

장점:
✅ 느슨한 결합 (Loose Coupling)
   서비스들이 직접 통신 안 함
✅ 확장성 (Scalability)
   워커 추가만으로 처리량 증대
✅ 신뢰성 (Reliability)
   XACK로 처리 보장
✅ 이력 (Auditability)
   모든 이벤트 기록
```

---

## 🎨 Stream 메시지의 전체 라이프사이클

```
┌──────────────────────────────────────────────────────────────┐
│ Stream 메시지 라이프사이클                                    │
└──────────────────────────────────────────────────────────────┘

1️⃣  생성 (XADD)
    ┌─────────────────────────────┐
    │ XADD orders * ... order_id  │
    │ ↓                           │
    │ 메시지 생성 ✨              │
    │ ID: 1705315200000-0         │
    └─────────────────────────────┘
                 ↓

2️⃣  저장 (Stream에 추가)
    ┌─────────────────────────────┐
    │ Redis Stream                │
    │ ┌─────────────────────────┐ │
    │ │ [메시지1] [메시지2]     │ │
    │ │ 상태: 대기 중... ⏳     │ │
    │ └─────────────────────────┘ │
    └─────────────────────────────┘
                 ↓

3️⃣  그룹 생성 (XGROUP CREATE)
    ┌─────────────────────────────┐
    │ XGROUP CREATE orders        │
    │         payment_group $ 0   │
    │         ↓                   │
    │ 소비자 그룹 생성 👥         │
    └─────────────────────────────┘
                 ↓

4️⃣  읽기 (XREADGROUP)
    ┌─────────────────────────────┐
    │ XREADGROUP GROUP            │
    │ payment_group worker1       │
    │         ↓                   │
    │ Worker가 메시지 읽음 📖     │
    │ 상태: 처리 중... ⏳         │
    └─────────────────────────────┘
                 ↓

5️⃣  처리 (비즈니스 로직)
    ┌─────────────────────────────┐
    │ Worker1:                    │
    │ ├─ 결제 처리 💳            │
    │ ├─ 데이터 검증             │
    │ ├─ 외부 API 호출           │
    │ └─ 완료! ✅               │
    └─────────────────────────────┘
                 ↓

6️⃣  확인 (XACK)
    ┌─────────────────────────────┐
    │ XACK orders payment_group   │
    │     메시지ID               │
    │         ↓                   │
    │ 처리 완료 표시 ✅           │
    │ 상태: 완료됨              │
    └─────────────────────────────┘
                 ↓

7️⃣  모니터링 (선택사항)
    ┌─────────────────────────────┐
    │ XPENDING orders             │
    │ payment_group               │
    │         ↓                   │
    │ 미처리/처리중 메시지 확인   │
    │ 이상 감지 시 재할당         │
    └─────────────────────────────┘
                 ↓

8️⃣  정리 (선택사항)
    ┌─────────────────────────────┐
    │ XTRIM orders MAXLEN 10000   │
    │         ↓                   │
    │ 오래된 메시지 삭제          │
    │ 메모리 관리                 │
    └─────────────────────────────┘

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

상태 변화 요약:

[대기중] → [처리중] → [완료]
   ⏳        ⏳       ✅
 XADD    XREADGROUP  XACK
```

---

## 주의사항

### ⚠️ 메모리 관리

```
Stream은 Append-only이므로 계속 커짐

XTRIM으로 오래된 메시지 제거:
XTRIM orders MAXLEN 10000  (최근 10,000개만 유지)

또는 자동 트림:
XADD orders MAXLEN ~ 10000 field value
(~는 약 10,000개 유지 의미)
```

### ⚠️ 미확인 메시지 처리

```
XREADGROUP으로 메시지를 읽었으면
반드시 XACK로 확인해야 함

미확인 메시지가 쌓이면:
- XPENDING에서 계속 보임
- 장시간 미처리 시 재할당 필요
```

### ⚠️ 그룹 관리

```
소비자 그룹 삭제:
XGROUP DESTROY orders payment_workers

소비자 제거:
XGROUP DELCONSUMER orders payment_workers worker1
```

---

## Kafka vs Redis Stream

|항목|Kafka|Redis Stream|
|---|---|---|
|**용도**|대규모 메시지 브로커|중소 규모 이벤트 처리|
|**메시지 보존**|디스크 저장|메모리 저장|
|**처리량**|매우 높음 (1M+/초)|낮음 (수만/초)|
|**복잡도**|높음|낮음|
|**설정**|복잡함|간단함|
|**활용도**|회사 인프라|개별 프로젝트|

---

## Spring Boot 예제 코드

```java
// 메시지 발행
redisTemplate.opsForStream()
  .add("orders", 
    Map.of(
      "order_id", "123",
      "user_id", "user:100",
      "amount", "50000"
    )
  );

// 소비자 그룹 생성
redisTemplate.opsForStream()
  .createGroup("orders", "payment_workers", "0");

// 메시지 읽기
List<MapRecord<String, String, String>> records = 
  redisTemplate.opsForStream()
    .read(
      Consumer.from("payment_workers", "worker1"),
      StreamReadOptions.empty().count(1),
      StreamOffset.fromStart("orders")
    );

// 처리 완료 확인
redisTemplate.opsForStream()
  .acknowledge("orders", "payment_workers", recordId);
```

---

## 핵심 정리

|개념|설명|
|---|---|
|**Stream**|Append-only 메시지 로그|
|**메시지 ID**|타임스탬프 기반 자동 생성|
|**XADD**|메시지 추가|
|**XREAD**|메시지 읽기 (일반)|
|**소비자 그룹**|여러 워커의 분담 처리|
|**XREADGROUP**|그룹에서 메시지 읽기|
|**XACK**|처리 완료 확인|
|**XPENDING**|미처리 메시지 추적|

---

## 정말 간단하게

```
List: 순서 있는 데이터 (스택/큐)
Stream: 메시지 브로커 (Kafka 같은)

Stream의 강점:
- 소비자 그룹으로 분담 처리
- 미확인 메시지 추적
- 이벤트 이력 보존
```