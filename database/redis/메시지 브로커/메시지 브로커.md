---
aliases:
  - 메시지 브로커로서의 레디스
tags:
  - 메시지브로커
  - mq
  - redis
  - event_stream
  - messaging_queue
---

# 메시지 브로커란?

## 개념
모듈 간 서로 탄탄한 상호 작용이 필요하기 때문에 그 중간 매개체 역할을 하는 메시징 솔루션

## 역할
서비스 간 통신 장애 시 서비스 장애로 이어지지 않도록 처리 못한 메시지를 어디에 쌓아둔 뒤 나중에 처리하도록 만들어 주는 것

```
┌──────────┐         ┌────────────────┐         ┌──────────┐
│ Service A│────────>│ Message Broker │────────>│ Service B│
└──────────┘         │   (중간 버퍼)    │         └──────────┘
                     └────────────────┘
                            │
                      서비스 장애 발생 시
                      메시지를 보관하여
                      나중에 재처리 가능
```

## 종류
- **메시징 큐** (Messaging Queue)
- **이벤트 스트림** (Event Stream)

---

## 메시징 큐 vs 이벤트 스트림

| 구분 | 메시징 큐 (Messaging Queue) | 이벤트 스트림 (Event Stream) |
|------|---------------------------|----------------------------|
| **데이터 생성자** | Producer | Publisher |
| **데이터 소비자** | Consumer | Subscriber |
| **메시지 전달 방식** | Point-to-Point (1:1)<br>2개의 서비스에 같은 메시지를 보내려면<br>생산자가 2개의 각각 다른 큐에 푸시해야 함 | Pub/Sub (N:N)<br>특정 저장소에 하나의 메시지를 보내면<br>여러 소비자가 같은 메시지를 pull 가능 |
| **영속성** | 소비자가 데이터를 읽어가면<br>즉시 삭제됨 | 읽어간 데이터가 바로 삭제되지 않고<br>저장소 설정에 따라 특정 기간 남아있음 |
| **사용 패턴** | 1:1 (작업 큐, 태스크 분배) | N:N (이벤트 브로드캐스트, 로그 수집) |
| **Redis 자료구조** | `LIST` | `STREAM` |

### 시각적 비교

```
┌─────────────────────────────────────────────────────────────┐
│  메시징 큐 (1:1 패턴)                                          │
└─────────────────────────────────────────────────────────────┘

Producer                Queue A              Consumer A
   │                   ┌────────┐                │
   ├─ msg1 ──────────> │  msg1  │ ─────────────> ├─ 처리
   │                   └────────┘                │
   │                                             (msg1 삭제)
   │                   Queue B              Consumer B
   │                   ┌────────┐                │
   ├─ msg1 ──────────> │  msg1  │ ─────────────> ├─ 처리
                       └────────┘                │
                                                (msg1 삭제)

   ❌ 같은 메시지를 여러 곳에 보내려면 각각 전송 필요


┌─────────────────────────────────────────────────────────────┐
│  이벤트 스트림 (N:N 패턴)                                       │
└─────────────────────────────────────────────────────────────┘

Publisher              Event Stream
   │                 ┌──────────────┐
   │                 │  msg1        │ ──┬──> Subscriber A (읽음)
   ├─ msg1 ────────> │  (보관됨)     │   │
   │                 └──────────────┘   ├──> Subscriber B (읽음)
   │                       │            │
   │                   (남아있음!)       └──> Subscriber C (읽음)
   │                       │
   │                  (일정 기간 후 삭제)

   ✅ 한 번만 발행하면 여러 구독자가 동일 메시지 수신 가능
```

---

## Redis를 메시지 브로커로 사용

Redis의 **Pub/Sub** 기능을 이용하여 간단히 메시지 브로커 구현 가능

### Pub/Sub이란?

한 서비스가 특정 **채널(Channel)** 에 데이터를 **발행(Publish)** 하면, 이 채널을 **구독(Subscribe)** 하고 있는 모든 소비자가 해당 데이터를 받는 기능

```
Publisher                Channel: "news"           Subscribers
   │                     ┌──────────────┐              │
   │                     │              │              │
   ├─ PUBLISH ─────────> │   message    │ ─────────────┼──> Subscriber 1
      "news"             │              │              │
      "breaking!"        └──────────────┘              ├──> Subscriber 2
                                                       │
                                                       └──> Subscriber 3
```

### 특징

#### 1. 일회성
- 발행된 메시지를 소비자가 받은 후 즉시 삭제됨
- 저장소에 보관되지 않음

#### 2. Fire-and-Forget 패턴
- **데이터 전달 여부를 보장하지 않음**
- 발행 시점에 구독자가 없으면 메시지 손실
- 비동기 프로그래밍에서 사용되는 디자인 패턴으로, 작업을 수행하고 그 결과에 대한 응답을 기다리지 않고 바로 다음 코드를 실행
- **사용 사례**: 로깅, 이벤트 발행, 통계 데이터 수집 등

```
┌─────────────────────────────────────────────────────────────┐
│  Fire-and-Forget 패턴 동작                                    │
└─────────────────────────────────────────────────────────────┘

시나리오 1: 구독자가 있는 경우
Publisher                                      Subscriber
   │                                                │
   ├─ PUBLISH channel "msg" ─────────────────────> │ (받음!)
   │  (전송 완료, 다음 작업 진행)                      │
   │                                                │
   └─ 다음 작업...                                   └─ 처리 중...

   ✅ 메시지 전달 성공


시나리오 2: 구독자가 없는 경우
Publisher                                      (아무도 없음)
   │
   ├─ PUBLISH channel "msg" ─────────────────> (허공에...)
   │  (전송 완료, 다음 작업 진행)
   │
   └─ 다음 작업...

   ❌ 메시지 손실! (하지만 Publisher는 신경 쓰지 않음)
```

### 관련 커맨드

#### 기본 커맨드

```bash
# 메시지 발행
PUBLISH channel message

# 단일 채널 구독
SUBSCRIBE channel [channel ...]

# 패턴 기반 여러 채널 구독
PSUBSCRIBE pattern [pattern ...]
```

#### 예시

```bash
# Subscriber (터미널 1)
> SUBSCRIBE news sports
Reading messages...
1) "subscribe"
2) "news"
3) (integer) 1

# Publisher (터미널 2)
> PUBLISH news "Breaking news!"
(integer) 1  # 1명의 구독자에게 전달됨

# Subscriber (터미널 1)에 나타남
1) "message"
2) "news"
3) "Breaking news!"
```

#### PSUBSCRIBE: Glob-style 패턴 매칭

```bash
# 패턴 구독
> PSUBSCRIBE news:*

# 이제 다음 채널들이 모두 매칭됨
PUBLISH news:kr "한국 뉴스"
PUBLISH news:us "미국 뉴스"
PUBLISH news:jp "일본 뉴스"

# 패턴 예시
PSUBSCRIBE user:*:notifications  # user:123:notifications, user:456:notifications
PSUBSCRIBE log:?:error            # log:1:error, log:2:error
```

---

## 클러스터 환경에서의 Pub/Sub

### 문제점

일반 Pub/Sub은 클러스터 환경에서 **모든 노드에 메시지를 브로드캐스트**하므로 비효율적입니다.

자세한 내용: [pub,sub은 비효율적이다?](./pub,sub은%20비효율적이다%3F.md)

```
┌─────────────────────────────────────────────────────────────┐
│  일반 Pub/Sub in Cluster (비효율적)                           │
└─────────────────────────────────────────────────────────────┘

Publisher ─ PUBLISH channel "msg" ─> Node 1
                                      │
                                      ├──> Node 2 (전파)
                                      ├──> Node 3 (전파)
                                      ├──> Node 4 (전파)
                                      └──> Node 5 (전파)

   ❌ 모든 노드에 브로드캐스트 → 네트워크 낭비
```

### 해결책: Sharded Pub/Sub (Redis 7.0+)

각 채널이 **슬롯(Slot)에 매핑**되어 해당 슬롯을 담당하는 노드와 그 복제본에만 메시지가 전파됩니다.

#### 특징

- 각 채널은 특정 슬롯에 매핑됨
- 모든 노드에 전파되지 않고 **해당 슬롯의 마스터와 복제본에만** 전파
- 연결된 노드에서 채널에 접근할 수 없다면 올바른 노드로 **자동 리다이렉션**
- 불필요한 네트워크 복제 절약

```
┌─────────────────────────────────────────────────────────────┐
│  Sharded Pub/Sub (효율적)                                     │
└─────────────────────────────────────────────────────────────┘

Publisher ─ SPUBLISH channel "msg" ─> Node 1 (slot 담당)
                                       │
                                       └──> Replica (복제본만)

   ✅ 필요한 노드에만 전파 → 네트워크 효율적
```

#### 커맨드

```bash
# Sharded Publish
SPUBLISH channel message

# Sharded Subscribe
SSUBSCRIBE channel [channel ...]

# Sharded Pattern Subscribe
SPSUBSCRIBE pattern [pattern ...]
```

#### 예시

```bash
# Sharded Subscriber
> SSUBSCRIBE orders:processing
Reading messages...

# Sharded Publisher
> SPUBLISH orders:processing "new order #1234"
(integer) 1  # 해당 슬롯의 구독자에게만 전달됨
```

---

## 정리

| 구분 | Pub/Sub (일반) | Sharded Pub/Sub |
|------|---------------|-----------------|
| **도입 버전** | Redis 2.0+ | Redis 7.0+ |
| **전파 범위** | 클러스터 전체 노드 | 슬롯 담당 노드 + 복제본 |
| **효율성** | 비효율적 (브로드캐스트) | 효율적 (타겟팅) |
| **커맨드** | `PUBLISH`, `SUBSCRIBE` | `SPUBLISH`, `SSUBSCRIBE` |
| **사용 사례** | 단일 노드, 소규모 | 클러스터 환경, 대규모 |
