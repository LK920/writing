---
aliases:
  - 레디스_기본_개념
  - 레디스_sorted_set
tags:
  - 레디스
  - redis
  - 레디스기본개념
  - 레디스자료구조
  - sortedset
  - score
  - bylex
  - rev
---
# Redis Sorted Set 자료구조

## 기본 개요

**스코어(Score) 값에 따라 정렬되는 고유 문자열의 집합**입니다. Set의 유일성을 보지만 순서가 있고, List처럼 인덱스 접근이 가능합니다.

- **특징**: 중복 불가능, 스코어로 정렬, 같은 스코어면 사전 순 정렬
- **정렬**: 스코어 오름차순 → 스코어 같으면 문자열 사전 순
- **활용**: 랭킹, 점수 관리, 타임시리즈 데이터, 우선순위 큐 등
- **성능**: 인덱스 접근 시 **List O(N) vs Sorted Set O(log N)** → 매우 효율적

---

## 데이터 구조 예시

```
ZADD leaderboard 100 "user:john" 150 "user:alice" 120 "user:bob"

Redis 메모리에 저장되는 구조 (스코어 순 정렬):
{
  "leaderboard": [
    (100, "user:john"),
    (120, "user:bob"),
    (150, "user:alice")
  ]
}
```

---

## 시간 복잡도

|작업|시간복잡도|설명|
|---|---|---|
|ZADD|**O(log N)**|정렬 유지하며 삽입|
|ZRANGE (인덱스)|**O(log N + K)**|K = 조회 범위 크기|
|**ZRANGE (스코어)**|**O(log N + K)**|이진 탐색으로 빠름|
|ZCARD|**O(1)**|빠름|

**vs List**: List의 인덱스 접근은 O(N) → Sorted Set이 훨씬 효율적!

---

## 핵심 커맨드

### 저장

```
ZADD key score member [score member...]      // 아이템 추가/스코어 업데이트
```

**ZADD 옵션들:**

|옵션|동작|사용 시점|
|---|---|---|
|`XX`|기존 아이템의 스코어만 업데이트 (신규 삽입 안함)|점수 갱신만 필요|
|`NX`|새 아이템만 삽입 (기존 아이템 스코어 유지)|중복 방지하며 추가|
|`LT`|새 스코어 < 기존 스코어일 때만 업데이트|최소값만 유지|
|`GT`|새 스코어 > 기존 스코어일 때만 업데이트|최대값만 유지|

**예시:**

```
ZADD leaderboard 100 "john"           // 첫 추가: 100점
ZADD leaderboard 150 "john"           // 업데이트: 150점으로 변경 (재정렬)
ZADD leaderboard XX 200 "john"        // XX옵션: 존재하면 200으로 변경
ZADD leaderboard NX 50 "john"         // NX옵션: 이미 존재하므로 무시
ZADD leaderboard GT 180 "john"        // GT옵션: 180 > 150이므로 업데이트
```

---

## 조회: ZRANGE (가장 중요한 커맨드)

### 1️⃣ 인덱스로 조회 (기본 동작)

```
ZRANGE key start stop [WITHSCORES] [REV]
```

- `start/stop`: 인덱스 범위 (0부터 시작, -1은 마지막)
- `WITHSCORES`: 스코어도 함께 출력
- `REV`: 역순 조회 (스코어 높은 순)

**예시:**

```
ZADD rank 10 a 20 b 30 c 40 d 50 e

ZRANGE rank 0 2                    // [a, b, c] (인덱스 0~2)
ZRANGE rank 0 -1 WITHSCORES        // [10 a, 20 b, 30 c, 40 d, 50 e]
ZRANGE rank 0 2 REV WITHSCORES     // [50 e, 40 d, 30 c] (높은 점수부터)
```

---

### 2️⃣ 스코어로 조회 (BYSCORE)

```
ZRANGE key min max BYSCORE [WITHSCORES]
```

스코어의 최소값과 최대값을 지정하여 범위 조회합니다.

**포함/제외 기호:**

|기호|의미|예시|
|---|---|---|
|`[`|**포함**|`[100` = 100 포함|
|`(`|**제외**|`(100` = 100 제외|
|`-inf`|음의 무한대|최소값 이상|
|`+inf`|양의 무한대|최대값 이상|

**예시:**

```
ZADD scores 50 a 100 b 150 c 200 d 250 e

ZRANGE scores 100 200 BYSCORE           // [b, c, d] (100 ≤ score ≤ 200)
ZRANGE scores (100 200 BYSCORE          // [c, d] (100 < score ≤ 200)
ZRANGE scores 100 (200 BYSCORE          // [b, c] (100 ≤ score < 200)
ZRANGE scores (100 (200 BYSCORE         // [c] (100 < score < 200)
ZRANGE scores 200 +inf BYSCORE          // [d, e] (score ≥ 200)
ZRANGE scores -inf 100 BYSCORE          // [a, b] (score ≤ 100)
```

---

### 3️⃣ 사전순 조회 (BYLEX) - 같은 스코어일 때만 사용

```
ZRANGEBYLEX key min max
```

**조건**: 모든 아이템의 스코어가 같아야 합니다! (중요!)

**기호:**

|기호|의미|
|---|---|
|`[`|**문자열 포함** (inclusive)|
|`(`|**문자열 제외** (exclusive)|
|`-`|사전 시작 (모든 문자)|
|`+`|사전 끝 (모든 문자)|

---

## ⚠️ BYLEX의 핵심: 사전순 비교 규칙

Redis 문서: "Longer strings are considered greater than shorter strings if the common part is identical"

**즉, 짧은 문자열이 긴 문자열보다 작습니다!**

### 사전순 정렬 예시

```
apple < banana < cherry < date < fig

그런데!
"b" < "banana"     ← b가 더 짧으므로 작음
"d" < "date"       ← d가 더 짧으므로 작음
```

따라서 실제 순서는:

```
b < banana < c < cherry < d < date < f < fig
```

### 실행 결과 분석

**당신의 쿼리:**

```
ZRANGEBYLEX mySortedSet [b [d
→ banana, cherry

분석: "b" ≤ x ≤ "d"
  apple: ❌ (b보다 작음)
  banana: ✅ (b ≤ banana ≤ d)
  cherry: ✅ (b ≤ cherry ≤ d)
  date: ❌ (date > d ← d < date이므로!)
  fig: ❌ (fig > d)
```

```
ZRANGEBYLEX mySortedSet [banana [date
→ banana, cherry, date

분석: "banana" ≤ x ≤ "date"
  apple: ❌ (banana보다 작음)
  banana: ✅ (banana ≤ banana ≤ date)
  cherry: ✅ (banana ≤ cherry ≤ date)
  date: ✅ (banana ≤ date ≤ date) ← date가 범위 안!
  fig: ❌ (date보다 큼)
```

```
ZRANGEBYLEX mySortedSet (b [d
→ banana, cherry

분석: "b" < x ≤ "d"
  apple: ❌ (b보다 작거나 같음)
  banana: ✅ (b < banana ≤ d)
  cherry: ✅ (b < cherry ≤ d)
  date: ❌ (date > d)
  fig: ❌ (fig > d)
```

---

## 💡 핵심 정리

**BYLEX 사용 시 주의할 점:**

1. 범위를 지정할 때 **실제 아이템이 아니라 문자열 자체로 비교**됨
2. 짧은 문자열 < 긴 문자열 (같은 접두사일 때)
3. `[b [d`와 `[banana [date`는 다른 범위를 의미함
4. 실무에서는 **거의 사용하지 않음** (너무 복잡하고 BYSCORE가 충분함)

---

## 실무 활용 예상

|상황|커맨드|
|---|---|
|게임 랭킹 (높은 점수순)|ZADD ranking 100 user:john; ZRANGE ranking 0 -1 REV|
|특정 점수 범위 사용자|ZRANGE ranking 1000 5000 BYSCORE|
|로그 저장 (타임스탬프 스코어)|ZADD logs `date +%s` "event data"|
|우선순위 큐|ZADD queue 1 task:high; ZPOPMIN queue|
|실시간 스코어보드|ZADD scores `expr time % 10` user; ZREVRANGE scores 0 9|