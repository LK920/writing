---
aliases:
  - 캐시로서의 레디스
tags:
  - redis
  - cache
  - 캐싱전략
  - 읽기전략
  - 쓰기전략
  - 삭제방식
  - ttl
  - eviction
  - 캐시스탬피드
  - maxmemory
  - maxmemory-policy
  - per알고리즘
  - look-aside
  - read-through
  - write-through
  - write-behind
  - cache-invalidation
  - lru
  - lfu
  - 근사알고리즘
  - passive-deletion
  - active-deletion
---
# 캐시란?
데이터를 빠르고 효율적으로 저장할 수 있는 임시 저장소 
캐시 도입 시점
- 잘 변화되지 않는 데이터
- 자주 검색되는 데이터
---
# 캐시로서의 레디스
- 사용이 간단
- 인메모리 데이터 저장소 -> 빠름
- 고가용성 -> 센티널, 클러스터를 이용하여 페일오버 처리, 스케일 아웃
## 캐싱 전략
### 읽기 전략
#### Look aside (Lazy Loading)
- 우선 캐시에 데이터가 있으면 데이터 반환하고 없으면 DB에 접근하여 데이터 조회 후 캐시에 새로 저장하고 반환한다.
	- 캐시 히트 : 캐시에 조회했는데 데이터 있음
	- 캐시 미스 : 캐시에 조회했는데 데이터 없음
	- 캐시 워밍 : 최초 캐시 사용시에 사용할 데이터를 미리 넣어두는 작업
	- lazy loading : 필요한 데이터가 없을 경우에만 db 조회하여 데이터 저장하는 방식
	- 장점
		- 레디스에 문제가 생겨도 db에 접근하여 조회 가능한 구조
		- 필요한 데이터만 캐시에 저장되므로 캐시 공간 효율적 사용
	- 단점
		- 캐시 미스 발생 시 레이턴시 증가 (캐시 조회 + DB 조회 + 캐시 저장)
		- 어플리케이션에서 레디스 캐시 접근이 많을 시에 캐시미스가 발생할 경우 db 조회 급증하여 성능이슈 발생 가능

#### Read through
- 캐시에서 데이터를 읽으며, 캐시가 DB 조회를 대신 수행하는 방식
- 애플리케이션은 캐시하고만 통신하고, 캐시가 DB와 통신을 담당
- 장점
	- 애플리케이션 로직이 단순해짐 (캐시만 바라보면 됨)
	- 캐시 미스 시 자동으로 DB 조회 후 캐시 저장
- 단점
	- 캐시와 DB 사이의 로직 구현 필요 (캐시 계층이 복잡해짐)
	- 첫 요청은 항상 느림 (캐시 미스)
### 쓰기 전략
> **쓰기 전략과 캐시 일관성**: 캐시 데이터와 원본 데이터가 동일한 값을 유지하는 것

#### Write through
- DB에 데이터 업데이트 할 때마다 캐시에도 동시에 쓰기
- 장점
	- 데이터 일관성 유지 (캐시와 DB가 항상 동기화)
	- 캐시 데이터가 항상 최신 상태
- 단점
	- 모든 쓰기 작업이 캐시와 DB 양쪽에서 발생하여 쓰기 레이턴시 증가
	- 사용하지 않는 데이터도 캐시에 저장되어 리소스 낭비 가능
- 사용 사례: 데이터 일관성이 중요한 금융 거래, 재고 관리 시스템

#### Cache invalidation (삭제 전략)
- DB에 업데이트할 때마다 캐시에서 해당 데이터 삭제
- 캐시에 데이터가 없으니 이후 데이터 읽을 때 DB 조회 후 캐시 저장 처리 (Look aside와 결합)
- 장점
	- 삭제 리소스가 새로운 데이터 저장 리소스보다 적게 듦
	- 구현이 간단함
	- 불필요한 데이터가 캐시에 남지 않음
- 단점
	- 삭제 후 첫 조회 시 캐시 미스 발생 (느림)
- 사용 사례: 대부분의 일반적인 웹 애플리케이션 (게시글, 사용자 프로필 등)

#### Write behind (Write back)
- 캐시에 우선적으로 쓰고 일정 시간 후에 비동기적으로 DB에 저장
- 장점
	- 쓰기 성능이 매우 빠름 (캐시에만 쓰면 됨)
	- 대용량 쓰기 발생 시 I/O로 인한 성능 저하 예방
	- DB 쓰기를 배치 처리하여 효율성 증가
- 단점
	- 캐시 장애 시 데이터 손실 위험 (DB에 아직 저장 안됨)
	- 데이터 일관성 보장 안됨 (eventual consistency)
	- 구현이 복잡함
- 사용 사례: 실시간 정확도가 중요하지 않은 경우 (좋아요 수, 조회수, 로그 데이터)
### 삭제 전략
#### Expiration (TTL)
- 캐시 데이터의 만료시간을 설정하여 자동 삭제 처리
- 만료 시간 설정 기본 단위는 초
- TTL key 명령어: 남은 시간 반환
	- -1: 만료시간이 설정되어 있지 않음
	- -2: 키가 존재하지 않음
- 주의사항
	- INCR/RENAME 등 데이터 조작, 키 이름 변경 시에는 만료 시간 변경되지 않음
	- 기존 키에 새로운 값을 덮어 씌울 때는 만료 시간이 유지되지 않고 사라짐 (SET 명령어 사용 시)

#### Eviction
- 명시적으로 캐시 데이터를 삭제하는 경우
- DEL 명령어 사용 또는 애플리케이션에서 삭제 처리
### 만료된 키는 메모리에서 즉시 삭제되는가?
레디스에서는 만료되었다고 해서 즉시 삭제되는 것은 아니다. 삭제에는 **Passive 방식**과 **Active 방식**이 있음

#### Passive 방식 (수동적 삭제)
- 클라이언트가 만료된 키에 접근할 때 해당 키를 메모리에서 삭제
- 장점: CPU 리소스를 거의 사용하지 않음
- 단점: 접근되지 않는 만료된 키는 메모리에 계속 남아있음

#### Active 방식 (능동적 삭제)
- 레디스가 주기적으로 만료된 키를 찾아 삭제
- 1초에 10번씩 다음 과정을 반복:
	1. TTL이 설정된 키 중 20개를 무작위로 선택
	2. 만료된 키를 모두 삭제
	3. 만료된 키가 25% 이상이면 처음부터 다시 반복
- 장점: 만료된 키가 메모리에 오래 남지 않음
- 단점: CPU 리소스 사용

### 메모리 관리와 maxmemory-policy 설정
메모리 용량을 초과하는 양의 데이터가 저장되면 레디스 내부 정책(Eviction Policy)을 사용해 어떤 키를 삭제할지 결정

#### maxmemory 설정
- 레디스가 사용할 수 있는 최대 메모리 용량 설정
- 예: `maxmemory 2gb`

#### maxmemory-policy 설정
메모리가 초과될 때의 처리 방식을 정의

**1. noeviction (기본값)**
- 삭제 처리를 하지 않음
- 메모리 초과 시 쓰기 명령에 대해 에러 반환
- 읽기 명령은 계속 동작

**2. LRU Eviction (Least Recently Used)**
- 가장 최근에 사용되지 않은 데이터부터 삭제
- **근사 LRU 알고리즘** 사용: 모든 키를 추적하지 않고 샘플링하여 삭제 대상 선택 (메모리 효율적)
	- `volatile-lru`: 만료 시간이 설정되어 있는 키만 대상
	- `allkeys-lru`: 모든 키 대상

**3. LFU Eviction (Least Frequently Used)**
- 가장 사용 빈도가 낮은 데이터부터 삭제
- 과거에 자주 사용된 키는 살아남을 수 있음 (접근 빈도 기반)
- **근사 LFU 알고리즘** 사용
	- `volatile-lfu`: 만료시간이 설정되어 있는 키만 대상
	- `allkeys-lfu`: 모든 키 대상

**4. Random Eviction**
- 무작위로 키를 선택하여 삭제
	- `volatile-random`: 만료 시간이 설정된 키 중에서 무작위 선택
	- `allkeys-random`: 모든 키 중에서 무작위 선택

**5. TTL 기반**
- `volatile-ttl`: 만료 시간이 가장 짧게 남은 키부터 삭제 (미리 삭제), 근사 알고리즘

> **근사 알고리즘이란?** 정확한 LRU/LFU를 구현하려면 모든 키의 접근 시간/빈도를 추적해야 하지만, 레디스는 메모리 효율을 위해 샘플링 방식을 사용합니다. 무작위로 5개(기본값)의 키를 선택하여 그 중 가장 오래된/적게 사용된 키를 삭제합니다.
### 캐시 스탬피드 현상 (Cache Stampede / Thundering Herd)
#### 문제 상황
여러 개의 애플리케이션 서버가 동시에 같은 캐시 키를 사용하고 있을 때, 해당 키가 만료되면:
1. 모든 서버가 동시에 캐시 미스 발생
2. 모든 서버가 동시에 DB에 같은 쿼리 요청
3. DB에 순간적으로 과부하 발생
4. 모든 서버가 동시에 캐시에 같은 데이터 저장

**Look aside 방식에서 특히 주의해야 함**

#### 해결 방법

**1. 적절한 만료시간 설정**
- 만료시간이 너무 짧지 않게 설정
- 랜덤한 시간을 추가하여 키들이 동시에 만료되지 않도록 함
```java
// 예시: TTL을 300~330초 사이로 랜덤하게 설정
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.Random;
import java.util.concurrent.TimeUnit;

@Autowired
private RedisTemplate<String, String> redisTemplate;

Random random = new Random();
int ttl = 300 + random.nextInt(31); // 0~30 사이의 랜덤값
redisTemplate.opsForValue().set(key, value, ttl, TimeUnit.SECONDS);
```

**2. 락(Lock)을 이용한 갱신**
- 캐시 미스 발생 시 첫 번째 요청만 DB 조회하도록 락 설정
- 나머지 요청들은 락이 해제될 때까지 대기 또는 재시도
```java
import org.springframework.data.redis.core.RedisTemplate;
import java.time.Duration;

String lockKey = "lock:" + key;
// setIfAbsent: 키가 없을 때만 설정 (NX 옵션과 동일)
Boolean lockAcquired = redisTemplate.opsForValue()
    .setIfAbsent(lockKey, "1", Duration.ofSeconds(10));

if (Boolean.TRUE.equals(lockAcquired)) {
    try {
        // DB에서 데이터 조회 후 캐시 저장
        String data = db.query();
        redisTemplate.opsForValue().set(key, data, ttl, TimeUnit.SECONDS);
    } finally {
        redisTemplate.delete(lockKey);
    }
} else {
    // 짧은 시간 대기 후 재시도
    Thread.sleep(100);
}
```

**3. 조기 재계산 (Probabilistic Early Recomputation, PER)**
- 캐시가 만료되기 전에 확률적으로 미리 갱신하는 알고리즘
- 키가 만료되기 전에 재계산이 일어나므로 캐시 미스를 예방

**PER 알고리즘 수식:**
```
currentTime - (timeToCompute * beta * log(random())) >= expiry
```

**파라미터 설명:**
- `currentTime`: 현재 시간
- `expiry`: 키의 만료 시간
- `timeToCompute`: 캐시 값을 다시 계산하는 데 걸리는 시간 (DB 조회 + 처리 시간)
- `beta`: 조기 갱신 민감도 (기본값 1.0, 클수록 더 일찍 갱신)
- `random()`: 0~1 사이의 난수

**동작 원리:**
- 만료 시간에 가까워질수록 조기 재계산 확률이 높아짐
- 계산 시간(`timeToCompute`)이 길수록 더 일찍 재계산 시작
- 여러 요청이 와도 확률적으로 일부만 재계산 수행

**예시:**
```java
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import java.util.Random;
import java.util.concurrent.TimeUnit;

@Service
public class CacheService {

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    public String getFromCacheWithPER(String key, int ttl, double beta) {
        String cachedData = redisTemplate.opsForValue().get(key);

        if (cachedData != null) {
            long currentTime = System.currentTimeMillis() / 1000; // 초 단위
            Long expiry = redisTemplate.getExpire(key, TimeUnit.SECONDS); // 남은 시간

            if (expiry != null && expiry > 0) {
                double timeToCompute = 0.5; // DB 조회 시간 (예: 0.5초)

                // PER 알고리즘: 조기 재계산 여부 결정
                Random random = new Random();
                double delta = timeToCompute * beta * Math.log(random.nextDouble());

                if (currentTime - delta >= expiry) {
                    // 조기 재계산
                    String data = db.query();
                    redisTemplate.opsForValue().set(key, data, ttl, TimeUnit.SECONDS);
                    return data;
                }
            }
            return cachedData;
        } else {
            // 캐시 미스
            String data = db.query();
            redisTemplate.opsForValue().set(key, data, ttl, TimeUnit.SECONDS);
            return data;
        }
    }
}

// 사용 예시
@Autowired
private CacheService cacheService;

String result = cacheService.getFromCacheWithPER("user:123", 300, 1.0);
```

**4. 캐시 워밍 (Cache Warming)**
- 서버 시작 시 또는 배치 작업으로 미리 캐시에 데이터를 적재
- 주요 데이터에 대해서만 적용