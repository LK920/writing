---
aliases:
  - 세션스토어
tags:
  - redis
  - session
  - sessionstore
  - 분산시스템
  - sticky-session
  - hash
  - ttl
  - 세션관리
  - 로드밸런싱
  - 고가용성
  - persistence
  - aof
  - rdb
---
# 세션 스토어로서의 레디스

## 세션이란?
서비스를 사용하는 클라이언트(사용자)의 상태 정보를 의미
- 로그인 정보, 장바구니, 사용자 설정 등
- HTTP는 stateless 프로토콜이므로 세션을 통해 상태를 유지
## 세션 스토어가 필요한 이유

### 단일 서버 환경
- 클라이언트가 한 웹서버에만 접근하는 경우
- 해당 웹서버의 메모리에 세션 정보를 저장하면 충분함

### 분산 환경의 문제점

#### 1. Sticky Session 방식의 문제
- **Sticky Session**: 특정 클라이언트를 항상 같은 서버로 라우팅하는 방식
- 문제점:
	- 트래픽 분산이 제대로 이루어지지 않음
	- 특정 서버에 부하가 집중될 수 있음
	- 해당 서버 장애 시 세션 정보 손실

#### 2. 세션 복제 방식의 문제
- 모든 웹서버에 세션을 복제하여 저장하는 방식
- 문제점:
	- 불필요한 저장 공간 낭비 (모든 서버에 중복 저장)
	- 동기화 오버헤드 발생
	- 서버 수가 많아질수록 비효율적

### 중앙 집중식 세션 스토어
별도의 **세션 스토어**를 두어 모든 웹서버가 공유
- 어떤 웹서버에 연결되더라도 세션 스토어에서 데이터 조회 가능
- 진정한 로드 밸런싱과 고가용성 확보
- 서버 증설/축소가 자유로움 (세션 정보 유지)

## 캐시와 세션 스토어의 차이

| 구분 | 캐시 | 세션 스토어 |
|------|------|-------------|
| **역할** | DB의 보조 역할 (복제본) | 원본 데이터 저장소 |
| **데이터 원본** | DB에 원본 존재 | 세션 스토어가 원본 |
| **데이터 손실** | 손실되어도 DB에서 복구 가능 | 손실 시 복구 불가능 |
| **공유 범위** | 여러 사용자가 공유 가능 | 특정 사용자에게만 유효 |
| **데이터 특성** | 읽기 중심, 변경 빈도 낮음 | 읽기/쓰기 모두 빈번 |
| **일관성 요구** | Eventually Consistent 허용 | Strong Consistency 필요 |

**캐시**는 데이터베이스의 데이터를 복제한 상태이기 때문에 삭제돼도 다시 조회 가능
**세션 스토어**의 데이터는 여러 사용자 간 공유되지 않으며, 특정 사용자 ID에 한해 유효

## 레디스를 세션 스토어로 사용하는 이유

### 장점
1. **빠른 성능**: 인메모리 저장소로 응답 속도가 매우 빠름
2. **TTL 지원**: 세션 만료 시간 자동 관리
3. **다양한 자료구조**: Hash, String 등을 활용한 효율적인 저장
4. **고가용성**: Redis Sentinel, Cluster를 통한 장애 대응
5. **확장성**: 수평 확장이 용이함

### 주로 사용하는 자료구조: Hash

#### Hash를 사용하는 이유
- 세션 데이터는 여러 필드로 구성됨 (user_id, name, email, cart, preferences 등)
- Hash를 사용하면 필드별로 개별 접근/수정 가능
- 메모리 효율적

#### 예시: Hash를 이용한 세션 저장

```java
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.Map;
import java.util.HashMap;
import java.util.Arrays;
import java.util.concurrent.TimeUnit;

@Autowired
private RedisTemplate<String, Object> redisTemplate;

ObjectMapper objectMapper = new ObjectMapper();

// 세션 저장
String sessionId = "sess:user123";
Map<String, Object> sessionData = new HashMap<>();
sessionData.put("user_id", "123");
sessionData.put("username", "john_doe");
sessionData.put("email", "john@example.com");
sessionData.put("login_time", "2025-01-04T10:00:00");
sessionData.put("cart", objectMapper.writeValueAsString(Arrays.asList("item1", "item2")));

// Hash로 저장 + TTL 30분 설정
redisTemplate.opsForHash().putAll(sessionId, sessionData);
redisTemplate.expire(sessionId, 1800, TimeUnit.SECONDS);  // 30분

// 세션 조회
Map<Object, Object> userSession = redisTemplate.opsForHash().entries(sessionId);
System.out.println(userSession);
// {user_id=123, username=john_doe, email=john@example.com, ...}

// 특정 필드만 수정 (장바구니 업데이트)
String updatedCart = objectMapper.writeValueAsString(
    Arrays.asList("item1", "item2", "item3")
);
redisTemplate.opsForHash().put(sessionId, "cart", updatedCart);

// 세션 연장 (사용자 활동 시)
redisTemplate.expire(sessionId, 1800, TimeUnit.SECONDS);

// 로그아웃 시 세션 삭제
redisTemplate.delete(sessionId);
```

#### String을 사용하는 방식도 가능

```java
import org.springframework.data.redis.core.RedisTemplate;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;

@Autowired
private RedisTemplate<String, String> redisTemplate;

// 전체 세션을 JSON으로 직렬화하여 String에 저장
ObjectMapper objectMapper = new ObjectMapper();
Map<String, String> sessionData = new HashMap<>();
sessionData.put("user_id", "123");
sessionData.put("username", "john_doe");
sessionData.put("email", "john@example.com");

String sessionJson = objectMapper.writeValueAsString(sessionData);
redisTemplate.opsForValue().set("sess:user123", sessionJson, 1800, TimeUnit.SECONDS);  // 30분 TTL

// 조회 시 역직렬화 필요
String sessionStr = redisTemplate.opsForValue().get("sess:user123");
Map<String, String> session = objectMapper.readValue(
    sessionStr,
    Map.class
);
```

**Hash vs String 선택 기준:**
- **Hash 사용**: 세션 내 특정 필드만 자주 업데이트하는 경우
- **String 사용**: 세션을 통째로 읽고 쓰는 경우, 간단한 구조

## 세션 관리 베스트 프랙티스

### 1. 적절한 TTL 설정
```java
import java.util.concurrent.TimeUnit;

// 일반 세션: 30분
redisTemplate.expire(sessionId, 1800, TimeUnit.SECONDS);

// "로그인 상태 유지" 기능: 14일
redisTemplate.expire(sessionId, 14, TimeUnit.DAYS);
```

### 2. 세션 키 네이밍 규칙
```
sess:{user_id}:{session_token}
예: sess:123:a1b2c3d4e5f6
```

### 3. 활동 기반 세션 연장
```java
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import java.util.concurrent.TimeUnit;

@Service
public class SessionService {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    /**
     * 사용자 활동 시 세션 자동 연장
     */
    public void extendSessionOnActivity(String sessionId) {
        if (Boolean.TRUE.equals(redisTemplate.hasKey(sessionId))) {
            redisTemplate.expire(sessionId, 1800, TimeUnit.SECONDS);
        }
    }
}
```

### 4. 중복 로그인 방지
```java
import org.springframework.data.redis.core.RedisTemplate;
import java.util.Set;

// 동일 사용자의 기존 세션 삭제
String pattern = "sess:" + userId + ":*";
Set<String> oldSessions = redisTemplate.keys(pattern);

if (oldSessions != null && !oldSessions.isEmpty()) {
    redisTemplate.delete(oldSessions);
}

// 새 세션 생성
redisTemplate.opsForHash().putAll(newSessionId, sessionData);
```

## 캐시와 세션 스토어를 동일한 레디스에서 운영?

**질문**: 결국 레디스의 인메모리를 세션 스토어의 역할로 사용하는게 아닌가? 논리적인 구분은 다르나 물리적으로 레디스 내에서 이뤄지는게 아닌가?

**답변**: 맞습니다! 물리적으로는 동일한 레디스를 사용할 수 있지만, **논리적 역할과 데이터 특성이 다르므로 분리하여 관리**하는 것이 권장됩니다.

### 동일 레디스에서 운영 시 분리 방법

#### 1. DB 번호로 분리 (가장 간단)
```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisStandaloneConfiguration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;

@Configuration
public class RedisConfig {

    // DB 0: 캐시 용도
    @Bean(name = "cacheRedisTemplate")
    public RedisTemplate<String, Object> cacheRedisTemplate() {
        RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();
        config.setHostName("localhost");
        config.setPort(6379);
        config.setDatabase(0);

        LettuceConnectionFactory factory = new LettuceConnectionFactory(config);
        factory.afterPropertiesSet();

        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);
        return template;
    }

    // DB 1: 세션 용도
    @Bean(name = "sessionRedisTemplate")
    public RedisTemplate<String, Object> sessionRedisTemplate() {
        RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();
        config.setHostName("localhost");
        config.setPort(6379);
        config.setDatabase(1);

        LettuceConnectionFactory factory = new LettuceConnectionFactory(config);
        factory.afterPropertiesSet();

        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);
        return template;
    }
}

// 사용 시
@Autowired
@Qualifier("cacheRedisTemplate")
private RedisTemplate<String, Object> cacheRedisTemplate;

@Autowired
@Qualifier("sessionRedisTemplate")
private RedisTemplate<String, Object> sessionRedisTemplate;
```

#### 2. 키 Prefix로 분리
```java
@Autowired
private RedisTemplate<String, Object> redisTemplate;

// 캐시: cache: prefix
redisTemplate.opsForValue().set("cache:user:123", userData);

// 세션: sess: prefix
redisTemplate.opsForHash().putAll("sess:user:123", sessionData);
```

#### 3. 별도 레디스 인스턴스 운영 (권장 - 프로덕션)
- **캐시 전용 레디스**: 캐시 데이터 손실 허용, 느슨한 persistence 설정
- **세션 전용 레디스**: 데이터 손실 불가, 강한 persistence 설정 (AOF 사용)

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisStandaloneConfiguration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;

@Configuration
public class MultiRedisConfig {

    // 캐시 전용 레디스 (6379)
    @Bean(name = "cacheRedisTemplate")
    public RedisTemplate<String, Object> cacheRedisTemplate() {
        RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();
        config.setHostName("cache-redis.example.com");
        config.setPort(6379);

        LettuceConnectionFactory factory = new LettuceConnectionFactory(config);
        factory.afterPropertiesSet();

        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);
        return template;
    }

    // 세션 전용 레디스 (6380)
    @Bean(name = "sessionRedisTemplate")
    public RedisTemplate<String, Object> sessionRedisTemplate() {
        RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();
        config.setHostName("session-redis.example.com");
        config.setPort(6380);

        LettuceConnectionFactory factory = new LettuceConnectionFactory(config);
        factory.afterPropertiesSet();

        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);
        return template;
    }
}
```

### 분리해야 하는 이유

| 이유 | 설명 |
|------|------|
| **데이터 중요도** | 캐시는 날아가도 되지만, 세션은 날아가면 사용자가 로그아웃됨 |
| **Persistence 설정** | 캐시는 RDB만, 세션은 AOF 필요 |
| **메모리 정책** | 캐시는 LRU로 자동 삭제 가능, 세션은 삭제되면 안됨 |
| **장애 영향 범위** | 별도 인스턴스면 한쪽 장애가 다른 쪽에 영향 없음 |
| **성능 격리** | 캐시 부하가 세션 조회에 영향 주지 않음 |
