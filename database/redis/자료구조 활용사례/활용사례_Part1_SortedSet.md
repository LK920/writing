---
aliases:
  - Redis 랭킹 구현
  - Sorted Set 활용사례
tags:
  - Redis
  - SortedSet
  - 랭킹시스템
  - 리더보드
  - 실시간랭킹
  - 게임개발
  - 검색기록
  - NoSQL
  - 캐시
  - 성능최적화
---

# Redis 자료구조 활용사례 Part 1: 게임 랭킹, RDBMS 대신 Redis로 구현하면? (Sorted Set)

> 이 시리즈는 책에서 소개된 다양한 자료구조를 실전에서 활용하는 방법을 소개합니다.
> - **Part 1: 게임 랭킹, RDBMS 대신 Redis로 구현하면? (Sorted Set)** (현재 글)
> - Part 2: 좋아요 중복 방지, Redis Set으로 간단하게 해결
> - Part 3: 1000만 사용자 DAU를 1.2MB로 추적하는 방법 (Bitmap)
> - Part 4: 12KB로 무제한 카운팅? HyperLogLog의 마법

---

## 1. Sorted Set을 이용한 리더보드

### 개요
리더보드는 경쟁자들의 순위와 점수를 보여주는 순위표입니다. Sorted Set은 점수별로 자동 정렬되기 때문에 리더보드 구현에 최적화되어 있습니다.

### 리더보드 유형
- **절대적 리더보드**: 모든 유저를 정렬하여 상위권만 표시
- **상대적 리더보드**: 유저와 인접한 경쟁자만 표시

### 주요 기능

#### 랭킹 생성 및 추가
Key 값을 `daily-score:날짜` 형식으로 명명하고, Score에는 점수, Member에는 유저 ID를 입력합니다.

```redis
ZADD daily-score:20251103 1 player:1
```

#### 랭킹 조회
`ZRANGE`를 이용하여 조회할 수 있으며, 기본적으로 오름차순이므로 `REV` 옵션을 사용하여 내림차순으로 정렬합니다.

```redis
# 전체 랭킹 조회 (내림차순)
ZRANGE daily-score:20251103 0 -1 WITHSCORES REV

# 상위 10명만 조회
ZRANGE daily-score:20251103 0 9 WITHSCORES REV
```

#### 점수 업데이트
`ZINCRBY`를 이용하여 member의 점수를 증감할 수 있으며, 점수 추가 시 자동으로 재정렬됩니다.

```redis
# player:1에게 100점 추가
ZINCRBY daily-score:20251103 100 player:1
```

#### 랭킹 합산
주간/월간/년간 스코어를 합산하여 누적 랭킹을 구현할 수 있습니다. `ZUNIONSTORE` 커맨드를 사용하여 여러 키의 점수를 합산합니다.

```redis
# 3일간의 일간 스코어를 합산하여 주간 스코어 생성
ZUNIONSTORE weekly-score 3 daily-score:20251101 daily-score:20251102 daily-score:20251103
```

합산 시 스코어에 가중치를 적용할 수도 있습니다. `WEIGHTS` 옵션으로 각 키에 대한 가중치 비율을 설정합니다.

```redis
# 최근 날짜에 더 높은 가중치 부여
ZUNIONSTORE weekly-score 3 daily-score:20251101 daily-score:20251102 daily-score:20251103 WEIGHTS 1 1.5 2
```

### 활용 예시
- 게임 랭킹 시스템
- 판매량 순위
- 성적 순위표
- 인기 게시글 랭킹

---

## 2. Sorted Set을 이용한 최근 검색 기록

### 개요
사용자가 최근에 검색한 내역을 확인할 수 있는 기능입니다. Sorted Set을 사용하면 중복 제거 및 최신순 정렬이 자동으로 처리됩니다.

### RDBMS 대신 Redis를 사용하는 이유

#### 최근 검색 기록의 요구사항
- 유저별로 독립적인 검색 기록 보유
- 중복 검색어 제거
- 최신 검색 순으로 N개만 표시

#### RDBMS의 한계
- 저장 → 최신 N개 조회 → N개만 남기기의 반복적인 작업 필요
- DB 접근이 빈번해짐 (읽기/쓰기 부하 증가)
- 검색 기록이 많아질수록 정렬 작업이 빈번해지고 관리할 테이블이 많아짐

#### Redis Sorted Set의 장점
- 저장 시점부터 중복 제거가 자동으로 처리됨
- Score로 시간을 사용하면 정렬이 자동으로 유지됨
- Key 명을 통해 유저를 식별할 수 있어 간단한 구조 유지

### 사용 방식

#### 추가/업데이트
Score를 시간 기반으로 사용(타임스탬프 형식)하고, Key에는 유저 ID를 포함하며, Member는 검색어를 저장합니다.

```redis
# 유저 123이 2025년 11월 3일 11시 35분 01초에 "코듀로이" 검색
ZADD search:123 20251103113501 "코듀로이"

# 유저 123이 2025년 11월 4일 20시 21분 24초에 "코듀로이" 재검색
# → Score가 업데이트됨 (중복 제거 + 최신 시간으로 갱신)
ZADD search:123 20251104202124 "코듀로이"
```

#### 조회
유저 ID만 알면 최신 검색 기록을 조회할 수 있습니다. N개 조회 시 인덱스는 0부터 (N-1)까지 지정합니다.

```redis
# 유저 123의 최신 검색 기록 5개 조회
ZRANGE search:123 0 4 REV WITHSCORES
```

#### 삭제 (오래된 검색어 삭제)
음수 인덱스를 활용하여 오래된 데이터를 삭제할 수 있습니다. `ZREMRANGEBYRANK`로 범위 지정 삭제가 가능합니다.

```redis
# 유저 123의 최신 데이터 5개만 유지하고 나머지 삭제
# 6번째 이전의 모든 데이터 삭제 (-6부터 음수 끝까지)
ZREMRANGEBYRANK search:123 0 -6
```

### 활용 예시
- 쇼핑몰 검색 기록
- 유튜브 검색 히스토리
- 지도 앱 최근 검색
- 음악 앱 검색 기록

---

## 정리

Sorted Set은 **자동 정렬**과 **점수 기반 관리**가 핵심입니다:

- **리더보드**: 점수를 기준으로 자동 정렬, 합산 및 가중치 적용 가능
- **최근 검색 기록**: 타임스탬프를 점수로 사용하여 시간순 자동 정렬, 중복 자동 제거

Sorted Set을 사용하면 정렬과 관련된 복잡한 로직을 Redis가 자동으로 처리해주므로, 개발자는 비즈니스 로직에만 집중할 수 있습니다.

---

> **다음 글 예고**: Part 2에서는 Set 자료구조를 활용한 태그 기능, 좋아요 처리, 랜덤 데이터 추출을 다룹니다.
