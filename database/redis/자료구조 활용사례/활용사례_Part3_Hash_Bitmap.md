---
aliases:
  - Redis DAU 측정
  - Bitmap 활용사례
tags:
  - Redis
  - Bitmap
  - Hash
  - DAU
  - 메모리최적화
  - 사용자분석
  - 채팅앱
  - 읽지않은메시지
  - 비트연산
  - 데이터분석
---

# Redis 자료구조 활용사례 Part 3: 1000만 사용자 DAU를 1.2MB로 추적하는 방법 (Bitmap)

> 이 시리즈는 책에서 소개된 다양한 자료구조를 실전에서 활용하는 방법을 소개합니다.
> - Part 1: 게임 랭킹, RDBMS 대신 Redis로 구현하면? (Sorted Set)
> - Part 2: 좋아요 중복 방지, Redis Set으로 간단하게 해결
> - **Part 3: 1000만 사용자 DAU를 1.2MB로 추적하는 방법 (Bitmap)** (현재 글)
> - Part 4: 12KB로 무제한 카운팅? HyperLogLog의 마법

---

## 1. Hash를 이용한 읽지 않은 메시지 수 카운팅

### 개요
채팅 애플리케이션에서 사용자가 속한 채널별로 읽지 않은 메시지를 효율적으로 관리하는 방법입니다.

### 기존 방식의 문제점

채팅 메시지가 도착할 때마다 DB에 직접 UPDATE를 수행하면:
- 빈번한 DB 쓰기 작업으로 인한 부하 발생
- 실시간 처리 성능 저하

### Redis Hash를 이용한 개선 방식

Redis와 같은 인메모리 DB에 일시적으로 저장 후, 필요한 시점에 한꺼번에 DB에 업데이트하는 방식으로 성능을 개선할 수 있습니다.

### 데이터 구조

```
Key: user:{사용자ID}
Field: channel:{채널ID}
Value: 읽지 않은 메시지 수
```

**예시:**
```
user:123
  ├─ channel:4234 → 3
  ├─ channel:5678 → 7
  └─ channel:9012 → 1
```

### 사용 방법

#### 새 메시지 도착 시 카운트 증가
```redis
# 채널 4234에 새 메시지가 도착하면 카운트 +1
HINCRBY user:123 channel:4234 1
```

#### 메시지 읽음 처리 시 카운트 감소
```redis
# 사용자가 메시지 1개를 읽으면 카운트 -1
HINCRBY user:123 channel:4234 -1
```

#### 특정 채널의 읽지 않은 메시지 수 조회
```redis
# 채널 4234의 읽지 않은 메시지 수 조회
HGET user:123 channel:4234
```

#### 모든 채널의 읽지 않은 메시지 수 조회
```redis
# 사용자 123의 모든 채널별 읽지 않은 메시지 수 조회
HGETALL user:123
# 결과: channel:4234 3, channel:5678 7, channel:9012 1
```

#### 채널 진입 시 카운트 초기화
```redis
# 사용자가 채널에 진입하여 모든 메시지를 읽음
HDEL user:123 channel:4234
# 또는
HSET user:123 channel:4234 0
```

### 장점
- 빠른 읽기/쓰기 성능
- 채널별로 독립적인 카운트 관리
- 여러 채널의 정보를 한 번에 조회 가능
- DB 부하 감소

### 활용 예시
- 슬랙, 디스코드 등 채팅 앱의 읽지 않은 메시지 배지
- 이메일 읽지 않은 메일 수
- 알림 센터의 읽지 않은 알림 수
- 멀티 채널 메신저

---

## 2. Bitmap을 이용한 DAU 구하기

### 개요

**DAU (Daily Active User)**: 하루 동안 서비스에 방문한 순수 사용자 수

주요 특징:
- 하루에 여러 번 방문하더라도 1명으로 카운팅
- 사용자의 유니크한 수를 파악할 수 있는 핵심 지표

### 기존 방식의 한계

#### 배치 처리 방식
- 사용자 접속 로그를 활용해 날마다 배치 처리 수행
- 실시간 데이터 확인 불가

#### Set 자료구조 사용 시
- 구현은 가능하나 메모리 사용량이 큼
- 키 하나당 최대 200~300만 개의 아이템 권장
- 사용자가 많아질수록 메모리 용량 급증

### Bitmap 자료구조의 장점

#### 메모리 효율성
- 사용자 ID는 0 이상의 정수로 관리
- 키당 최대 512MB (비트맵은 String 자료구조 기반)
- **예시**: 사용자 1,000만 명 기준 약 **1.2MB** 크기 (매우 효율적!)

#### 성능
- 빠른 비트 연산
- 실시간 조회 가능

### 기본 사용 방법

#### 1. 사용자 방문 기록
유저 ID가 14인 유저가 접근했을 때 오프셋 14를 1로 설정합니다.

```redis
SETBIT uv:20251103 14 1
```

**내부 표현:**
```
uv:20251103 → 0000 0000 0000 0010 ...
               ↑    ↑    ↑    ↑
              위치 0   8   12   14 (1로 설정됨)
```

#### 2. 해당 일자 DAU 확인
```redis
# 비트맵 중 1인 값의 개수를 가져옴 (= 방문한 유저 수)
BITCOUNT uv:20251103
```

### 비트 연산을 활용한 고급 기능

`BITOP` 커맨드를 사용하여 AND, OR, XOR, NOT 연산을 수행할 수 있습니다.

#### 예제: 3일 연속 접속한 유저 구하기

**1일차 (2025-11-01): 유저 1, 7, 10, 14, 15가 접속**
```redis
SETBIT uv:20251101 1 1
SETBIT uv:20251101 7 1
SETBIT uv:20251101 10 1
SETBIT uv:20251101 14 1
SETBIT uv:20251101 15 1
```
→ uv:20251101 비트맵: `0100 0001 0001 0011`

**2일차 (2025-11-02): 유저 3, 4, 7, 8, 9, 14가 접속**
```redis
SETBIT uv:20251102 3 1
SETBIT uv:20251102 4 1
SETBIT uv:20251102 7 1
SETBIT uv:20251102 8 1
SETBIT uv:20251102 9 1
SETBIT uv:20251102 14 1
```
→ uv:20251102 비트맵: `0001 1001 1100 0010`

**3일차 (2025-11-03): 유저 3, 7, 11, 14가 접속**
```redis
SETBIT uv:20251103 3 1
SETBIT uv:20251103 7 1
SETBIT uv:20251103 11 1
SETBIT uv:20251103 14 1
```
→ uv:20251103 비트맵: `0001 0001 0001 0010`

#### AND 연산: 3일 모두 접속한 유저
```redis
BITOP AND event:202511-3days uv:20251101 uv:20251102 uv:20251103

# 결과 확인
BITCOUNT event:202511-3days
# 유저 7, 14 → 2명
```

#### OR 연산: 3일 중 한 번이라도 접속한 유저
```redis
BITOP OR event:202511-any uv:20251101 uv:20251102 uv:20251103

# 결과 확인
BITCOUNT event:202511-any
# 유저 1, 3, 4, 7, 8, 9, 10, 11, 14, 15 → 10명
```

### 비트맵 데이터 활용

비트맵은 내부적으로 String 자료구조로 저장되므로 `GET` 커맨드로 조회할 수 있습니다.

```redis
GET event:202511-3days
```

필요한 경우 다음과 같은 방식으로 비트 값을 추출할 수 있습니다:
1. 각 문자를 이진 비트로 변환
2. 모든 비트를 왼쪽에서 오른쪽으로 순회하면서 비트 값 추출
3. 1로 설정된 비트의 인덱스를 수집 (= 방문한 유저 ID 목록)

### 활용 예시
- DAU/WAU/MAU 측정
- 연속 출석 체크 이벤트
- N일 연속 접속 유저 분석
- 사용자 리텐션 분석

---

## 정리

Hash와 Bitmap은 **메모리 효율성**과 **빠른 연산**이 핵심입니다:

- **Hash**: 여러 필드-값 쌍을 하나의 키로 묶어 관리, 채널별/카테고리별 데이터 관리에 최적
- **Bitmap**: 대용량 유니크 사용자 추적, 극도로 적은 메모리로 수백만 사용자 관리

Hash는 관련된 데이터를 그룹화하여 관리할 때, Bitmap은 대규모 사용자의 방문 여부를 추적할 때 탁월한 성능을 발휘합니다.

---

> **다음 글 예고**: Part 4에서는 HyperLogLog를 활용한 애플리케이션 미터링과 Geospatial을 활용한 위치 기반 서비스를 다룹니다.
