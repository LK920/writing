---
aliases:
  - 레디스_기본_개념
  - 레디스_hyperloglog
tags:
  - 레디스
  - redis
  - 레디스기본개념
  - 레디스자료구조
  - hyperloglog
---
# Redis HyperLogLog 자료구조

## 기본 개요

**중복되지 않는 고유한 원소의 개수(카디널리티)를 추정하는 자료구조**입니다. Set과 유사하지만 **데이터 자체를 저장하지 않고 추정값만 저장**하는 획기적으로 효율적인 구조입니다.

- **본질**: 입력 데이터 처리 후 패턴만 저장 (실제 데이터 미저장)
- **메모리**: 데이터 개수 관계없이 **항상 12KB 이하**
- **저장 가능**: 최대 2^64개 아이템 카디널리티 추정 가능
- **정확도**: 약 99% (오차율 약 0.81%)
- **활용**: 일일 방문자 수, 웹사이트 UU(유니크 사용자), 실시간 통계 등

---

## Set vs HyperLogLog 비교

|항목|Set|HyperLogLog|
|---|---|---|
|**저장 데이터**|모든 원소 보존|데이터 보존 X|
|**메모리**|데이터량에 따라 증가|항상 12KB|
|**메모리 예시**|1억 개 = 약 100MB|1억 개 = 12KB|
|**정확도**|100% 정확|약 99% (오차 최대 1%)|
|**개수 조회**|SCARD|PFCOUNT|
|**데이터 조회**|SMEMBERS 가능|불가능|
|**용도**|유일한 데이터 관리|개수만 추정|

---

## 추정(Probabilistic Counting)의 개념

### HyperLogLog는 왜 데이터를 저장하지 않나?

```
입력: "user:100", "user:200", "user:300"

Set의 방식 (모든 데이터 저장):
메모리: ["user:100", "user:200", "user:300"]

HyperLogLog의 방식 (패턴만 저장):
1. 각 입력을 해시 함수로 변환
2. 해시값의 "패턴"만 저장 (실제 데이터 X)
3. 여러 패턴을 분석해서 "아, 대략 3명 정도인 것 같은데?" 추정
4. 메모리: 패턴 정보만 (약 12KB)
```

---

## 메모리 효율성 비교

### 시나리오: 구글 같은 서비스의 일일 방문자 수

**방법 1: Set 사용 (비효율)**

```
일일 방문자: 약 50억 명

SET google:dau:2025-01-15 "session:1"
SET google:dau:2025-01-15 "session:2"
...
SET google:dau:2025-01-15 "session:5000000000"

필요 메모리: 50억 × 약 100바이트 = 약 500GB 😱
```

**방법 2: HyperLogLog 사용 (효율적) ✅**

```
PFADD google:dau:2025-01-15 "session:1"
PFADD google:dau:2025-01-15 "session:2"
...
PFADD google:dau:2025-01-15 "session:5000000000"

필요 메모리: 약 12KB
결과: 약 50억 명 (±1% 오차)

차이: 약 40,000배 메모리 절감!
```

### 메모리 규모별 추정

```
방문자 수       | Set 메모리 | HyperLogLog 메모리 | 절감율
1,000명        | 약 100KB   | 12KB              | 약 8배
1,000,000명    | 약 100MB   | 12KB              | 약 8,000배
1,000,000,000명| 약 100GB   | 12KB              | 약 8,000,000배
```

---

## 핵심 커맨드

### 데이터 추가

```
PFADD key element [element...]     // 원소 추가 (중복 자동 제거)
```

**특징**: Set의 SADD처럼 보이지만, 내부적으로는 데이터를 저장하지 않음

```
PFADD dau:2025-01-15 "user:100"
PFADD dau:2025-01-15 "user:200"
PFADD dau:2025-01-15 "user:300"
PFADD dau:2025-01-15 "user:100"   // 중복, 무시됨
```

### 카디널리티 조회

```
PFCOUNT key [key...]               // 고유 원소 개수 추정
```

**예시 1: 단일 날짜 방문자 수**

```
PFCOUNT dau:2025-01-15
→ 결과: 약 3 (정확값: 3)
```

**예시 2: 여러 날짜 합친 방문자 (합집합 추정)**

```
PFCOUNT dau:2025-01-13 dau:2025-01-14 dau:2025-01-15
→ 결과: 약 8 (3일간 중복 제거한 총 유니크 방문자)
```

### 여러 HyperLogLog 합치기

```
PFMERGE dest key [key...]          // 여러 HyperLogLog를 합쳐서 새 key 생성
```

**예시: 월간 UU(유니크 사용자) 계산**

```
PFMERGE mau:2025-01 \
  dau:2025-01-01 dau:2025-01-02 dau:2025-01-03 ... dau:2025-01-31

PFCOUNT mau:2025-01
→ 결과: 1월 총 유니크 방문자 수 (중복 제거)
```

---

## 시간 복잡도

|작업|시간복잡도|설명|
|---|---|---|
|PFADD|**O(1)**|매우 빠름 (데이터 저장 X)|
|PFCOUNT|**O(1)**|매우 빠름|
|PFMERGE|**O(N)**|HyperLogLog 개수에 따라|

---

## 실제 사용 예제

### 예제 1: 쇼핑몰 일일 방문자 수

```
2025-01-15 방문 기록:
PFADD shop:dau:2025-01-15 "customer:100"
PFADD shop:dau:2025-01-15 "customer:200"
PFADD shop:dau:2025-01-15 "customer:300"
PFADD shop:dau:2025-01-15 "customer:100"  // 중복 방문, 무시

결과 조회:
PFCOUNT shop:dau:2025-01-15
→ 약 3명 (정확: 3명)

메모리: 12KB (아무리 많아도 12KB)
```

### 예제 2: 주간 방문자 통계

```
월요일~금요일 방문자 추적:
PFADD shop:dau:2025-01-13 "customer:100" "customer:200" ...
PFADD shop:dau:2025-01-14 "customer:200" "customer:300" ...
PFADD shop:dau:2025-01-15 "customer:100" "customer:400" ...
PFADD shop:dau:2025-01-16 "customer:300" "customer:500" ...
PFADD shop:dau:2025-01-17 "customer:100" "customer:600" ...

주간 순방문자 (중복 제거):
PFCOUNT shop:dau:2025-01-13 \
        shop:dau:2025-01-14 \
        shop:dau:2025-01-15 \
        shop:dau:2025-01-16 \
        shop:dau:2025-01-17
→ 약 6명 (5일간 중복 제거된 고객)
```

### 예제 3: 월간 UU 저장

```
월간 UU를 한 번에 계산해서 저장:
PFMERGE shop:mau:2025-01 \
  shop:dau:2025-01-01 shop:dau:2025-01-02 ... shop:dau:2025-01-31

PFCOUNT shop:mau:2025-01
→ 1월 총 유니크 고객 수

다음달을 위해 저장:
PFMERGE shop:mau:2025-02 \
  shop:dau:2025-02-01 shop:dau:2025-02-02 ... shop:dau:2025-02-28
```

### 예제 4: IP 주소로 방문자 추적

```
웹사이트 일일 유니크 방문자 (중복 접속자 제거):

PFADD website:dau:2025-01-15 "192.168.1.100"
PFADD website:dau:2025-01-15 "192.168.1.200"
PFADD website:dau:2025-01-15 "192.168.1.100"  // 같은 IP 재방문
PFADD website:dau:2025-01-15 "10.0.0.50"

PFCOUNT website:dau:2025-01-15
→ 약 3명 (IP 기준 유니크 방문자)
```

---

## 언제 뭘 쓰나?

### Set 사용 ✅

```
✅ 정확한 명단이 필요할 때
✅ "정확히 누가 왔나?" 알고 싶을 때
✅ 1% 오차도 허용 못 할 때

예: 친구 목록, 팔로우 리스트, 금융 거래 기록
```

### HyperLogLog 사용 ✅

```
✅ "대략 몇 명이 왔는가?"만 알면 될 때
✅ 메모리가 중요할 때 (대규모 데이터)
✅ 정확도 1% 오차는 괜찮을 때

예: 일일 방문자 수, 웹사이트 UU, 앱 다운로드 수
```

---

## 주의사항

### ⚠️ 쓰면 안 되는 경우

1. **정확한 리스트 필요**: 친구 목록, 팔로우 목록처럼 정확한 데이터 필요
2. **높은 정확도 요구**: 금융 거래, 의료 데이터처럼 1% 오차도 허용 못 함
3. **개별 데이터 조회 필요**: "누가 방문했나?" 리스트를 봐야 할 때

### ✅ 쓰면 좋은 경우

1. **대규모 데이터**: 1억 건 이상의 데이터
2. **메모리 효율성**: 공간 절감이 중요함
3. **통계 목적**: 대략적인 트렌드와 수치만 필요
4. **집계 연산**: 여러 시간대의 데이터를 합쳐서 분석

---

## 정확도 이해하기

### 오차율

```
HyperLogLog의 표준 오차율: 약 0.81%

예시:
실제 값 = 1,000,000명
추정값 = 약 1,008,100명 ~ 991,900명 (±1% 범위)

대부분의 통계 목적으로는 충분히 정확함!
```

### 오차가 크게 느껴질 때 vs 작게 느껴질 때

```
작은 데이터셋 (1~1000):
100명 ± 1% = 99~101명 (오차 1명)
→ 오차가 눈에 띔

큰 데이터셋 (1억 이상):
1억명 ± 1% = 99백만~101백만명 (오차 100만명)
→ 전체 관점에선 무시할 수 있는 오차
```

---

## 실무 활용 패턴

### 일일 방문자 통계 시스템

```
아침마다 실행:
PFMERGE dau:2025-01-15 \
  sessions:hour:00 sessions:hour:01 ... sessions:hour:23

저녁에 월간 통계 생성:
PFMERGE mau:2025-01 \
  dau:2025-01-01 dau:2025-01-02 ... dau:2025-01-31

대시보드에 표시:
오늘 방문자: PFCOUNT dau:2025-01-15
이달 방문자: PFCOUNT mau:2025-01
```

### Spring Boot 예제

```java
// 사용자 방문 기록
redisTemplate.opsForHyperLogLog()
  .add("dau:2025-01-15", userId);

// 일일 유니크 방문자 수
Long dau = redisTemplate.opsForHyperLogLog()
  .size("dau:2025-01-15");

// 월간 유니크 방문자 수
redisTemplate.opsForHyperLogLog()
  .union("mau:2025-01", 
    "dau:2025-01-01", "dau:2025-01-02", ... "dau:2025-01-31");
  
Long mau = redisTemplate.opsForHyperLogLog()
  .size("mau:2025-01");
```

---

## 핵심 정리

|용어|의미|
|---|---|
|**카디널리티**|중복을 제거한 고유한 원소의 개수|
|**추정**|정확하지 않지만 대략 맞는 값 (±1% 오차)|
|**Set**|모든 데이터 저장 + 100% 정확한 개수|
|**HyperLogLog**|데이터 미저장 + 추정된 개수|
|**패턴 저장**|HyperLogLog가 실제 데이터 대신 저장하는 것|

---

## 정말 간단하게

```
Set: "오늘 온 모든 손님의 이름 기록하기"
HyperLogLog: "오늘 대략 몇 명이 왔는지 추정하기"

Set: 정확하지만 메모리 많이 씀
HyperLogLog: 대략이지만 메모리 극도로 절감
```
	
